<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>calis RNG game</title>
    
    <meta name="theme-color" content="#2d0051">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icons/icon-192x192.png">
    <style>
        body {
            font-family: 'Courier New', monospace;
            background-color: #4a148c;
            color: #ffffff;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            color: #ffffff;
        }
        .main-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto;
            gap: 20px;
        }
        
        .main-container > div:first-child {
            grid-column: 1;
            grid-row: 1;
        }
        
        .main-container > div:nth-child(2) {
            grid-column: 2;
            grid-row: 1;
        }
        
        .main-container > div:last-child {
            grid-column: 1 / span 2;
            grid-row: 2;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        #terminal {
            background-color: #2d0051;
            border: 2px solid #ff69b4;
            border-radius: 5px;
            padding: 20px;
            min-height: 400px;
            max-height: 500px;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        .output-line {
            margin: 5px 0;
        }
        .command {
            color: #ff69b4;
        }
        .welcome-message {
            color: #ff69b4;
            font-weight: bold;
        }
        .stats {
            background-color: #2d0051;
            border: 2px solid #ff69b4;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .stat-item {
            margin: 8px 0;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            background-color: #808080;
            color: #ffffff;
            border: 2px solid #ff69b4;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
        }
        button:hover {
            background-color: #a0a0a0;
        }
        button:active {
            transform: scale(0.95);
        }
        button:disabled {
            background-color: #555;
            border-color: #888;
            color: #aaa;
            cursor: not-allowed;
        }
        button.active {
            background-color: #ff69b4;
            color: #000;
        }
        #inventory, #index, #pending-rolls {
            background-color: #2d0051;
            border: 2px solid #ff69b4;
            border-radius: 5px;
            padding: 20px;
            min-height: 400px;
            max-height: 500px;
            overflow-y: auto;
        }
        .inventory-item {
            background-color: #4a148c;
            border: 1px solid #ff69b4;
            padding: 10px;
            margin: 5px 0;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .inventory-item:hover {
            background-color: #5a1a9c;
            transform: translateX(5px);
        }
        .section-header {
            font-size: 18px;
            margin-bottom: 10px;
            color: #ff69b4;
            font-weight: bold;
        }
        .clickable-roll {
            cursor: pointer;
            display: inline-block;
            transition: all 0.2s;
        }
        .clickable-roll:hover {
            transform: scale(1.05);
            text-shadow: 0 0 10px currentColor;
        }
        .index-item {
            background-color: #4a148c;
            border: 1px solid #ff69b4;
            padding: 8px;
            margin: 5px 0;
            border-radius: 3px;
        }
        .index-item.discovered {
            border-color: #00ff00;
        }
        .index-item.locked {
            opacity: 0.5;
            border-color: #666;
        }
        
        .autoroll-settings {
            background-color: #2d0051;
            border: 2px solid #ff69b4;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .autoroll-setting-item {
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .autoroll-setting-item label {
            flex-shrink: 0;
        }
        
        .autoroll-setting-item input[type="number"] {
            background-color: #4a148c;
            color: #ffffff;
            border: 1px solid #ff69b4;
            padding: 5px 10px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            width: 150px;
        }
        
        .autoroll-setting-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        /* NEW: Scientific Notation Settings */
        .scientific-setting {
            background-color: #2d0051;
            border: 2px solid #00ffff;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .scientific-setting-item {
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .scientific-setting-item label {
            flex-shrink: 0;
            min-width: 250px;
        }
        
        .scientific-setting-item input[type="number"] {
            background-color: #4a148c;
            color: #ffffff;
            border: 1px solid #00ffff;
            padding: 5px 10px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            width: 200px;
        }
        
        /* NEW: UI Customization */
        .ui-customization {
            background-color: #2d0051;
            border: 2px solid #FFA500;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .ui-customization-item {
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .ui-customization-item label {
            flex-shrink: 0;
            min-width: 150px;
            color: #FFA500;
        }
        
        .ui-customization-item input[type="color"] {
            width: 60px;
            height: 30px;
            cursor: pointer;
            border: 2px solid #FFA500;
            border-radius: 3px;
        }
        
        /* Rank colors */
        .rank-1-1000 { color: #ffffff; }
        .rank-1000-10000 { color: #ffff00; }
        .rank-10000-100000 { color: #00ffff; }
        .rank-100000-1000000 { color: #0000cd; }
        .rank-1000000-100000000 { color: #ff0000; }
        .rank-100000000-1000000000 { color: #8b0000; }
        .rank-1000000000-10000000000 { color: #00ff00; }
        .rank-10000000000-100000000000 { color: #ffc0cb; } 
        .rank-100000000000-1000000000000 { color: #a9a9a9; } 
        .rank-1000000000000-100000000000000 { color: #ff69b4; }
        .rank-improbable { color: #008080; }
        .variant-roll {} 
        
        .rank-rainbow {
            background: linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: rainbow-shift 3s linear infinite;
            background-size: 200% 100%;
        }

        /* FIXED: Unobtainable rank style */
        .rank-unobtainable {
    position: relative;
    display: inline-block;
    color: transparent;
    background: linear-gradient(90deg, #000000, #ffffff);
    -webkit-background-clip: text;
    background-clip: text;
    font-weight: bold;
    text-shadow: 
        -1px -1px 0 #808080,
        0 -1px 0 #808080,
        1px -1px 0 #808080,
        -1px 0 0 #808080,
        1px 0 0 #808080,
        -1px 1px 0 #808080,
        0 1px 0 #808080,
        1px 1px 0 #808080;
}
        
        .rank-unobtainable::before {
            content: 'Unobtainable';
            position: absolute;
            left: 0;
            top: 0;
            color: #808080;
            z-index: 1;
            text-shadow: 
                -1px -1px 0 #808080,
                0 -1px 0 #808080,
                1px -1px 0 #808080,
                -1px 0 0 #808080,
                1px 0 0 #808080,
                -1px 1px 0 #808080,
                0 1px 0 #808080,
                1px 1px 0 #808080;
        }
        
        .secret-nonavacious {
            filter: drop-shadow(0 0 5px #00BFFF); 
        }
        
        @keyframes rainbow-shift {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }

        /* --- CUTSCENE STYLES --- */
        #cutscene-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000000;
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out; 
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .cutscene-active #cutscene-overlay {
            opacity: 1;
            pointer-events: all;
        }
        
        .cutscene-flash #cutscene-overlay {
            background-color: #ffffff;
        }

        #star-element {
            position: absolute; 
            top: 50%; 
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            opacity: 0;
            transition: opacity 0.5s ease-in;
            filter: drop-shadow(0 0 15px currentColor);
            background-color: currentColor; 
        }
        
        .star-4 {
            clip-path: polygon(50% 0%, 61% 39%, 100% 50%, 61% 61%, 50% 100%, 39% 61%, 0% 50%, 39% 39%);
        }
        
        .star-6 {
            clip-path: polygon(50% 0%, 65% 20%, 100% 30%, 80% 50%, 100% 70%, 65% 80%, 50% 100%, 35% 80%, 0% 70%, 20% 50%, 0% 30%, 35% 20%);
        }
        
        .star-8 {
            clip-path: polygon(50% 0%, 58% 30%, 100% 30%, 66% 50%, 100% 70%, 58% 70%, 50% 100%, 42% 70%, 0% 70%, 34% 50%, 0% 30%, 42% 30%);
        }
        
        .star-12 {
            clip-path: polygon(50% 0%, 55% 15%, 70% 15%, 75% 0%, 80% 15%, 95% 15%, 100% 30%, 95% 45%, 100% 70%, 95% 85%, 100% 85%, 75% 100%, 70% 85%, 55% 85%, 50% 100%, 45% 85%, 30% 85%, 25% 100%, 20% 85%, 5% 85%, 0% 70%, 5% 45%, 0% 30%, 5% 15%, 20% 15%, 25% 0%, 30% 15%, 45% 15%);
        }

        /* --- END CUTSCENE STYLES --- */

        /* --- NEW: SHAPES GUI STYLES --- */
        #shapes-gui {
            background-color: #2d0051;
            border: 2px solid #00FF00; /* Green border for new UI */
            padding: 20px;
            border-radius: 5px;
            display: none; /* Hidden by default */
        }

        /* NEW: Container for clickable shapes */
        .shapes-field {
            background-color: #1a0033;
            border: 1px dashed #00FF00;
            min-height: 200px;
            max-height: 300px;
            overflow: hidden; 
            position: relative;
            margin-bottom: 15px;
        }

        /* NEW: Styles for the individual clickable polygon */
        .clickable-shape {
            position: absolute;
            width: 30px;
            height: 30px;
            cursor: pointer;
            transition: transform 0.2s, opacity 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            font-weight: bold;
            color: #000;
            text-shadow: 0 0 3px currentColor;
            border-radius: 2px;
            animation: float 5s ease-in-out infinite alternate; 
        }

        @keyframes float {
            0% { transform: translateY(0px) rotate(0deg); }
            100% { transform: translateY(-5px) rotate(5deg); }
        }

        /* Shape-specific clip-paths for visual polygons */
        .shape-Triangle { clip-path: polygon(50% 0%, 0% 100%, 100% 100%); }
        .shape-Square { clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%); }
        .shape-Pentagon { clip-path: polygon(50% 0%, 100% 38%, 81% 100%, 19% 100%, 0% 38%); }
        .shape-Hexagon { clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%); }
        .shape-7-Sided-Polygon { clip-path: polygon(50% 0%, 90% 20%, 100% 60%, 75% 100%, 25% 100%, 0% 60%, 10% 20%); }
        .shape-Octagon { clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%); }
        .shape-Circle { border-radius: 50%; }

        /* Retained for the smaller log */
        .shape-spawn-output {
            background-color: #1a0033;
            border: 1px solid #00FF00;
            padding: 10px;
            min-height: 50px;
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 15px;
        }
        
        .shape-spawn-line {
            margin: 5px 0;
            color: #00FF00; /* Bright green text */
        }
        
        .shapes-upgrades {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        /* --- END NEW STYLES --- */

        /* --- NEW: CLICKER GUI STYLES --- */
        #clicker-gui {
            background-color: #2d0051;
            border: 2px solid #FFD700; /* Gold border */
            padding: 20px;
            border-radius: 5px;
            display: none;
        }

        #clover-clicker:active {
            transform: scale(0.9);
        }
        /* --- END NEW STYLES --- */
        
        /* --- NEW: SATANIC SECRET STYLE (MODIFIED) --- */
        .satanic-wrapper {
            position: relative;
            display: inline-block; 
            z-index: 0; /* Create stacking context */
        }
        
        .satanic-wrapper::before {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            width: 2.5em; /* Scaled with text */
            height: 2.5em; /* Scaled with text */
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><polygon points="50,5 61,40 98,40 68,62 79,96 50,75 21,96 32,62 2,40 39,40" style="fill:red;"/></svg>');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            
            /* Center and set behind text */
            transform: translate(-50%, -50%); 
            z-index: -1; 
            opacity: 0.75; /* Make it a bit subtle */
            
            /* 6.66 RPM = 9.009 seconds per rotation */
            animation: rotate-pentagram 9.009s linear infinite;
        }
        
        @keyframes rotate-pentagram {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
        /* --- END NEW STYLE --- */

        /* --- NEW: CORRUPTED SECRET STYLE --- */
        .secret-corrupted {
            display: inline-block; /* Needed for transform */
            animation: corrupted-shake 30ms linear infinite;
            filter: invert(100%);
        }
        
        @keyframes corrupted-shake {
            0%    { transform: rotate(0deg); }
            16.67% { transform: rotate(22.5deg); }
            33.33% { transform: rotate(45deg); }
            50%    { transform: rotate(0deg); }
            66.67% { transform: rotate(-22.5deg); }
            83.33% { transform: rotate(-45deg); }
            100%   { transform: rotate(0deg); }
        }
        /* --- END NEW STYLE --- */

        /* --- NEW: Complex rank animation --- */
        .rank-complex {
            background: linear-gradient(90deg, #ff0000, #00ff00, #0000ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: complex-shift 2s linear infinite;
            background-size: 300% 100%;
            font-weight: bold;
        }
        
        @keyframes complex-shift {
            0% { background-position: 0% 50%; }
            100% { background-position: 300% 50%; }
        }
        /* --- END Complex rank animation --- */

        /* --- NEW: Pending rolls styles --- */
        .pending-roll-item {
            background-color: #3a0d6e;
            border: 1px solid #ffff00;
            padding: 10px;
            margin: 5px 0;
            border-radius: 3px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .pending-roll-buttons {
            display: flex;
            gap: 5px;
        }
        
        .pending-accept-btn {
            background-color: #00ff00;
            color: #000;
            border: 1px solid #00ff00;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .pending-decline-btn {
            background-color: #ff0000;
            color: #000;
            border: 1px solid #ff0000;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }
        /* --- END Pending rolls styles --- */

        /* --- NEW: Hardcore mode styles --- */
        .hardcore-rank {
            border-left: 3px solid #ff0000;
            padding-left: 5px;
            font-style: italic;
        }
        
        .hardcore-mode-active {
            background-color: #2d0051;
            border: 2px solid #ff0000;
        }
        
        .hardcore-mode-active .stat-item {
            color: #ff6666;
        }

        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto;
            }
            
            .main-container > div:first-child,
            .main-container > div:nth-child(2),
            .main-container > div:last-child {
                grid-column: 1;
                grid-row: auto;
            }
            
            .main-container > div:last-child {
                display: block;
            }
        }

        @media (max-width: 768px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body class="cutscene-inactive">
    <h1>calis RNG game</h1>
    
    <div class="stats">
        <div class="stat-item">Currency: <span id="currency">0.00</span></div>
        <div class="stat-item">Geometrix: <span id="geometrix">0.00</span></div>
        <div class="stat-item">Total Upgrades: <span id="upgrades">0</span></div>
        <div class="stat-item">Luck: +<span id="luck">0.000</span></div>
        <div class="stat-item">Luck Multiplier: <span id="luckMulti">1.00</span>x</div>
        <div class="stat-item">Secret Luck: <span id="secretLuck">1.00</span>x</div>
        <div class="stat-item">Variant Chance: <span id="variantChance">1.00</span>x</div>
        <div class="stat-item">Next Upgrade Cost: <span id="upgradeCost">50.00</span></div>
        <div class="stat-item">Bulk Roll (Lvl <span id="bulkRollLevel">0</span>): <span id="bulkRollAmount">1</span> roll/click</div>
        <div class="stat-item">Next Bulk Roll Cost: <span id="bulkRollCost">500,000.00</span></div>
        <div class="stat-item">Inventory: <span id="inventoryCount">0</span>/<span id="inventoryMax">10</span></div>
        <div class="stat-item">Pending Rolls: <span id="pendingCount">0</span>/<span id="pendingMax">30</span></div>
        <div class="stat-item">Rarest Roll: <span id="rarest">None yet</span></div>
        <div class="stat-item">Ranks Discovered: <span id="ranksDiscovered">0</span>/<span id="totalRanks">60</span></div>
        <div class="stat-item">Secrets Enabled: <span id="secretsEnabled">Yes</span></div>
        <!-- NEW: Hardcore mode status -->
        <div class="stat-item">Hardcore Mode: <span id="hardcoreStatus">OFF</span></div>
        <!-- NEW: Scientific Notation Status -->
        <div class="stat-item">Scientific Notation: <span id="sciNotationStat">ON (‚â•1e18)</span></div>
    </div>

    <!-- NEW: Scientific Notation Settings -->
    <div class="scientific-setting">
        <div class="section-header">Scientific Notation Settings</div>
        <div class="scientific-setting-item">
            <label>Scientific notation threshold (‚â•):</label>
            <input type="number" id="sciNotationThreshold" value="1000000000000000000" min="1" step="0.000001">
        </div>
        <div class="scientific-setting-item">
            <button onclick="toggleScientificNotation()">Toggle Scientific Notation: <span id="sciNotationStatus">ON</span></button>
        </div>
        <div class="scientific-setting-item" style="color: #00ffff; font-size: 12px;">
            Note: Numbers ‚â• threshold will display in scientific notation (e.g., 1.23e18)
        </div>
    </div>

    <!-- NEW: UI Customization -->
    <div class="ui-customization">
        <div class="section-header" style="color: #FFA500;">UI Customization</div>
        <div class="ui-customization-item">
            <label>Background Color:</label>
            <input type="color" id="ui-bg-color" value="#4a148c">
        </div>
        <div class="ui-customization-item">
            <label>Button Background:</label>
            <input type="color" id="ui-button-bg" value="#808080">
        </div>
        <div class="ui-customization-item">
            <label>Button Outline:</label>
            <input type="color" id="ui-button-outline" value="#ff69b4">
        </div>
        <div class="ui-customization-item">
            <label>HC Mode UI Color:</label>
            <input type="color" id="ui-hc-color" value="#ff0000">
        </div>
        <div class="ui-customization-item">
            <label>Text Color:</label>
            <input type="color" id="ui-text-color" value="#ffffff">
        </div>
        <div class="ui-customization-item">
            <button onclick="applyUICustomization()" style="background-color: #FFA500; border-color: #FFA500; color: #000;">Apply UI Changes</button>
            <button onclick="resetUICustomization()" style="background-color: #808080; border-color: #ff69b4; color: #fff;">Reset to Default</button>
        </div>
    </div>

    <div class="autoroll-settings" style="padding-bottom: 5px;">
        <div class="section-header">Auto Accept Settings</div>
        <div class="autoroll-setting-item">
            <label>Accept on value ‚â•:</label>
            <input type="number" id="autoAcceptThreshold" value="0" step="0.000001" placeholder="Enter minimum value">
        </div>
        <div class="autoroll-setting-item">
            <label>Accept on base rank ‚â•:</label>
            <input type="number" id="autoAcceptTrueRNG" value="0" step="0.000001" placeholder="Enter minimum base value">
        </div>
        <div class="autoroll-setting-item">
            <label>Accept on secret rarity ‚â•:</label>
            <input type="number" id="autoAcceptSecretThreshold" value="0" step="0.000001" placeholder="Enter minimum rarity">
        </div>
        <div class="autoroll-setting-item">
            <input type="checkbox" id="autoAcceptNewRank">
            <label for="autoAcceptNewRank">Accept on new rank discovery</label>
        </div>
        
        <!-- NEW: Auto Stop Settings -->
        <div class="section-header" style="margin-top: 15px;">Auto Stop Settings</div>
        <div class="autoroll-setting-item">
            <label>Stop on value ‚â•:</label>
            <input type="number" id="autoStopThreshold" value="0" step="0.000001" placeholder="Enter minimum value">
        </div>
        <div class="autoroll-setting-item">
            <label>Stop on base rank ‚â•:</label>
            <input type="number" id="autoStopTrueRNG" value="0" step="0.000001" placeholder="Enter minimum base value">
        </div>
        <div class="autoroll-setting-item">
            <label>Stop on secret rarity ‚â•:</label>
            <input type="number" id="autoStopSecretThreshold" value="0" step="0.000001" placeholder="Enter minimum rarity">
        </div>
        <div class="autoroll-setting-item">
            <input type="checkbox" id="autoStopNewRank">
            <label for="autoStopNewRank">Stop on new rank discovery</label>
        </div>
        
        <!-- UPDATED: Import / Export Save with base64url encoding -->
        <div class="section-header" style="margin-top: 15px;">Import / Export Save</div>
        <textarea id="saveDataTextarea" style="width: 95%; min-height: 80px; background-color: #4a148c; color: #ffffff; border: 1px solid #ff69b4; font-family: 'Courier New', monospace; margin-bottom: 15px; padding: 5px; resize: vertical;" placeholder="Paste save data here and click 'Import Save'"></textarea>
        <div class="controls" style="grid-template-columns: 1fr 1fr; margin-bottom: 10px;">
            <button onclick="exportSave()">Export Save</button>
            <button onclick="importSave()">Import Save</button>
        </div>
        <!-- NEW: Hardcore mode warning -->
        <div id="hardcore-warning" style="color: #ff0000; display: none; margin-top: 10px; padding: 10px; background-color: #3a0d6e; border: 1px solid #ff0000;">
            <strong>‚ö†Ô∏è Hardcore Mode Active:</strong> Bulk=1, Luck=1, Variant=1, Secret=1, Events disabled
        </div>
    </div>

    <div class="controls">
        <button onclick="roll()">Roll (r)</button>
        <button id="autoRollBtn" onclick="toggleAutoRoll()">Auto Roll</button>
        <button onclick="buyUpgrade()">Buy Upgrade</button>
        <button id="buyBulkRollBtn" onclick="buyBulkRoll()">Buy Bulk Roll</button>
        <button onclick="showRarest()">Show Rarest</button>
        <button onclick="clearTerminal()">Clear Terminal</button>
        <button onclick="saveGame()">Save Game</button>
        <button id="cutsceneToggleBtn" onclick="toggleCutscenes()">Cutscenes: ON</button>
        <button id="secretToggleBtn" onclick="toggleSecrets()">Secrets: ON</button>
        <!-- NEW: Hardcore mode toggle -->
        <button id="hardcoreToggleBtn" onclick="toggleHardcoreMode()">Hardcore Mode: OFF</button>
    </div>
    
    <div class="main-container">
        <div>
            <div id="terminal"></div>
        </div>
        <div>
            <div id="inventory">
                <div class="section-header">Inventory</div>
                <div class="controls" style="grid-template-columns: 1fr 1fr; margin-bottom: 10px;">
                    <button onclick="sortInventory('leastRarest')">Least Rarest</button>
                    <button onclick="sortInventory('mostRarest')">Most Rarest</button>
                </div>
                <div id="inventoryContent">Empty</div>
            </div>
        </div>
        <div>
            <div class="right-column">
                <div id="index">
                    <div class="section-header">Index (Ranks Discovered)</div>
                    <div id="indexContent">Roll to discover ranks!</div>
                </div>
                
                <!-- UPDATED: Always show pending rolls section -->
                <div id="pending-rolls">
                    <div class="section-header">Pending Rolls</div>
                    <div id="pendingContent">Empty</div>
                </div>
                
                <div class="controls" id="shapes-unlock-controls">
                    <button id="unlockShapesBtn" onclick="unlockShapes()">Unlock Shapes GUI (5,000,000.00 Currency)</button>
                </div>
                
                <div id="shapes-gui">
                    <div class="section-header" style="color: #00FF00;">Shapes GUI</div>
                    
                    <div id="shapes-field" class="shapes-field"></div>

                    <div class="stat-item">Current Shape Luck: +<span id="shapeLuckBonus">0.0</span>x</div>
                    <div class="stat-item">Shapes/Spawn: <span id="bulkShapeAmount">1</span> (Lvl <span id="bulkShapeLevel">0</span>)</div>
                    <div class="stat-item">Spawn Cooldown: <span id="shapeCooldown">2.0000</span>s</div>
                    
                    <div class="shape-spawn-output" id="shape-spawn-output" style="height: 50px;">Waiting for first spawn...</div>

                    <div class="shapes-upgrades">
                        <button id="buyShapeLuckBtn" onclick="buyShapeLuckUpgrade()">Shape Luck (+0.1x) - Cost: <span id="shapeLuckCost">5.00</span> GMX</button>
                        <button id="buyLuckMultiBtn" onclick="buyLuckMultiUpgrade()">Luck Multiplier (x2.00) - Cost: <span id="luckMultiCost">100.00</span> GMX</button>
                        <button id="buyBulkShapeBtn" onclick="buyBulkShapeUpgrade()">Bulk/Cooldown Lvl <span id="bulkShapeLevelBtn">1</span> - Cost: <span id="bulkShapeCost">50.00</span> GMX</button>
                        <button id="buyClickerUnlockBtn" onclick="unlockClicker()">Unlock Clicker - Cost: 1,000,000.00 GMX</button>
                    </div>
                </div>
                
                <div id="clicker-gui">
                    <div class="section-header" style="color: #FFD700;">Clicker</div>
                    
                    <div class="stats" style="background-color: #2d0051; border-color: #FFD700; padding: 10px; margin-bottom: 10px;">
                        <div class="stat-item">Fortunium: <span id="fortunium">0.00</span></div>
                        <div class="stat-item">Fortunium Luck: +<span id="fortuniumLuck">0.00</span>x</div>
                    </div>

                    <div id="clover-field" style="text-align: center; margin-bottom: 15px;">
                         <span id="clover-clicker" style="font-size: 80px; cursor: pointer; display: inline-block; transition: transform 0.1s; user-select: none;">üçÄ</span>
                    </div>

                    <div class="clicker-upgrades" style="display: flex; flex-wrap: wrap; gap: 10px;">
                        <button id="buyGmxMultiBtn" onclick="buyFortuniumUpgrade('gmx')">GMX Multi (+0.5x) - Cost: <span id="gmxMultiCost">75.00</span> FOR</button>
                        <button id="buyFortuniumLuckBtn" onclick="buyFortuniumUpgrade('fortuniumLuck')">Fortunium Luck (+0.5x) - Cost: <span id="fortuniumLuckCost">125.00</span> FOR</button>
                        <button id="buyClickerLuckBtn" onclick="buyFortuniumUpgrade('luck')">Luck Multi (+0.5x) - Cost: <span id="clickerLuckCost">1000.00</span> FOR</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="cutscene-overlay">
        <div id="star-element" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);"></div>
    </div>

    <script>
        // --- CONSTANTS ---
        const POWER_EXPONENT = -2.4;
        const AUTO_ROLL_DELAY_MS = 5;
        const UPGRADE_COST_MULTIPLIER = 1.15;
        const LUCK_PER_UPGRADE = 2.5;
        const INVENTORY_PER_UPGRADE = 10;
        const VARIANT_CHANCE_PER_UPGRADE = 0.05;
        const MAX_VARIANT_CHANCE_MULTIPLIER = 12.5;
        const SECRET_LUCK_PER_UPGRADE = 0.25;
        const MAX_SECRET_LUCK = 7.5;
        const BULK_ROLL_COST_MULTIPLIER = 1.75;
        const MAX_BULK_ROLL_LEVEL = 9;
        const MAX_VARIANTS_PER_ROLL = 5; 
        
        // CUTSCENE CONSTANTS
        const CUTSCENE_DURATION_MS = 7000;
        const STAR_FADE_IN_MS = 2000;
        const SPIN_ACCEL_MS = 5000;
        const SIZE_UPDATE_INTERVAL_MS = 10; 
        const SIZE_MULTIPLIER_PER_UPDATE = 1.02;
        const WHITE_FLASH_DURATION_MS = 1000; 

        // --- NEW EVENT CONSTANTS ---
        const EVENT_CHECK_INTERVAL_MS = 1000; 

        const EVENTS = [
            { 
                name: "Error", 
                chance: 1/40.4, 
                duration: 40000,
                description: "makes nil, Title Label Missing and unknown's rarity be easier by x4",
                targets: ["nil", "Title Label Missing", "?!? unknown ?!?"],
                multiplier: 4 
            },
            { 
                name: "Lol", 
                chance: 1/69, 
                duration: 20000,
                description: "makes every meme related secret easier by 6.94x and boosts future event chances",
                targets: ["r", "fish", "cheese", "c", "cheese : cheddar", "LEGACY In im table ?!?!?", "QHAR ?!?", "7 GRAND DAD"],
                multiplier: 6.94,
                eventChanceBoost: 69 
            },
            { 
                name: "UNDEFINED", 
                chance: 1/300, 
                duration: 30000,
                description: "makes ranks 'unknown,' 'title label missing' and 'absolute zero' be x5 times easier",
                targets: ["?!? unknown ?!?", "Title Label Missing", ":[{(absolute zero)}]:"],
                multiplier: 5
            },
            { 
                name: "Modified", 
                chance: 1/750, 
                duration: 7500,
                description: "makes every variant x2.5 times easier",
                targets: [],
                multiplier: 2.5
            },
            { 
                name: "Self Insert", 
                chance: 1/777, 
                duration: 77700,
                description: "makes cali^2 easier by x777,777.777",
                targets: ["cali^2"],
                multiplier: 777777.777
            },
            { 
                name: "Hellish", 
                chance: 1/66.66, 
                duration: 25000,
                description: "makes ‚õßSatanic‚õß, Seize and Insanity x6.66 easier",
                targets: ["‚õßSatanic‚õß", "Seize", "Insanity"],
                multiplier: 6.66 
            },
            {
                name: "ULTRA",
                chance: 1/10000,
                duration: 3333,
                description: "EVERY SECRET IS x100 EASIER FOR A FEW SECONDS.",
                targets: ["ALL_SECRETS"],
                multiplier: 100
            },
            { 
                name: "Hidden", 
                chance: 1/1000, 
                duration: 15000,
                description: "makes EVERY secret X7.77 easier",
                targets: ["ALL_SECRETS"],
                multiplier: 7.77
            }
        ];

        // UPDATED VARIANTS ARRAY WITH NEW VARIANTS
        const VARIANTS = [
            { name: "Shiny", chance: 1/100, multiplier: 25, color: "#FFD700" },
            { name: "Gilded", chance: 1/125, multiplier: 125, color: "#FFA500" },
            { name: "Crystalized", chance: 1/500, multiplier: 250, color: "#e642f5" },
            { name: "Spectral", chance: 1/625, multiplier: 625, color: "#9400D3" },
            { name: "Extraordinary", chance: 1/1250, multiplier: 1250, color: "#FF1493" },
            { name: "Myriad", chance: 1/2500, multiplier: 2500, color: "#00FFFF" },
            { name: "Charred", chance: 1/4000, multiplier: 4000, color: "#FF4500" },
            { name: "Expert", chance: 1/7500, multiplier: 7500, color: "#00BFFF" },
            { name: "Wind", chance: 1/12500, multiplier: 12500, color: "#ADD8E6" }, 
            { name: "Mega", chance: 1/25000, multiplier: 25000, color: "#FF00FF" }, 
            { name: "Small", chance: 1/35000, multiplier: 35000, color: "#BEBEBE" }, 
            { name: "Monument", chance: 1/55555, multiplier: 55555, color: "#8B4513" }, 
            { name: "ETERNAL DAWN", chance: 1/77777, multiplier: 77777, color: "#FFFFFF" },
            { name: ">Finale<", chance: 1/100000, multiplier: 100000, color: "#D2691E" },
            { name: "Solar", chance: 1/250000, multiplier: 250000, color: "#FFA500" },
            { name: "Atomic", chance: 1/494500, multiplier: 494500, color: "#32CD32" },
            { name: "Luminous", chance: 1/625000, multiplier: 625000, color: "#90ccdb" },
            { name: "Charged", chance: 1/750000, multiplier: 750000, color: "#90db90" },
            { name: "Ultimate", chance: 1/1e6, multiplier: 1e6, color: "#1e4259" },
            { name: "Ionized", chance: 1/2.5e6, multiplier: 2.5e6, color: "#c29bdb" },
            { name: "monochrome", chance: 1/1.6666e4, multiplier: 1.6666e4, color: "#5c5c5c" },
            { name: "GIANT", chance: 1/5e6, multiplier: 5e6, color: "#7dbd6a" },
            // NEW VARIANTS
            { 
                name: "Negative", 
                chance: 1/5625, 
                multiplier: -1, 
                color: "#000000", 
                bypassCap: true,
                isNegative: true 
            },
            { 
                name: "Dull", 
                chance: 1/147382, 
                power: -1, 
                color: "#666666", 
                bypassCap: true,
                isDull: true
            }
        ];

        // UPDATED RANK TIERS with Theoretical
        const RANK_TIERS = [
            { min: 1, max: 5, name: "Common" },
            { min: 5, max: 25, name: "Natural" },
            { min: 25, max: 50, name: "Uncommon" },
            { min: 50, max: 100, name: "Normal" },
            { min: 100, max: 500, name: "Divine" },
            { min: 500, max: 1000, name: "Grandiose" },
            { min: 1000, max: 2500, name: "Decent" },
            { min: 2500, max: 7500, name: "Unreal" },
            { min: 7500, max: 25000, name: "Cosmic" },
            { min: 25000, max: 100000, name: "Eternal" },
            { min: 100000, max: 500000, name: "Iridescent" },
            { min: 500000, max: 777777.77, name: "Exceptional" },
            { min: 777777.77, max: 788888.78, name: "Unordinary" },
            { min: 788888.78, max: 1e6, name: "Radioactive" },
            { min: 1e6, max: 5e6, name: "Heavenly" },
            { min: 5e6, max: 1e7, name: "Fantasy" },
            { min: 1e7, max: 5e7, name: "Unattainable" },
            { min: 5e7, max: 1e8, name: "Gigantic" },
            { min: 1e8, max: 2.5e8, name: "Epsilon" },
            { min: 2.5e8, max: 5e8, name: "Terafined" },
            { min: 5e8, max: 1e9, name: "Eclipse" },
            { min: 1e9, max: 5e9, name: "Infinitude" },
            { min: 5e9, max: 1e10, name: "Theoretical" },
            { min: 1e10, max: 1e11, name: "Unseeable" }, 
            { min: 1e11, max: 1e12, name: "Impassive" }, 
            { min: 1e12, max: 1e13, name: "Unrollable" },
            { min: 1e13, max: 1e14, name: "MACROSCOPIC" },
            { min: 1e14, max: 1e15, name: "Null" },
            { min: 1e15, max: 1e18, name: "Imaginary" },
            { min: 1e18, max: 1e21, name: "Impossible" },
            { min: 1e21, max: 1e24, name: "Astronomical" },
            { min: 1e24, max: 1e30, name: "Colossal" }, 
            { min: 1e30, max: Infinity, name: "Improbable" }
        ];

        // UPDATED SECRET RANKS WITH NEW ADDITIONS
        const SECRET_RANKS_CHANCES = [
            { name: "nil", chance: 1/17500, rarity: 17500 }, 
            { name: "Title Label Missing", chance: 1/4040.404, rarity: 4040.404 },
            { name: "?!? unknown ?!?", chance: 1/6666.666, rarity: 6666.666 },
            { name: "r", chance: 1/6942, rarity: 6942 },
            { name: "?!? bewilderment ?!?", chance: 1/450285, rarity: 450285 },
            { name: "Interminable", chance: 1/7777, rarity: 7777 },
            { name: "fish", chance: 1/7979, rarity: 7979 },
            { name: "cheese", chance: 1/9995, rarity: 9995 },
            { name: "üíØ", chance: 1/10000, rarity: 10000 },
            { name: "Minimal", chance: 1/15000, rarity: 15000 },
            { name: "c", chance: 1/33333, rarity: 33333 },
            { name: "Seize", chance: 1/97525, rarity: 97525 }, 
            { name: "Florescent", chance: 1/264839, rarity: 264839 },
            { name: "œÄ", chance: 1/314159, rarity: 314159 },
            { name: "breaktime", chance: 1/705372, rarity: 705372, timeBased: true },
            { name: "~Nonavacious~", chance: 1/575630, rarity: 575630 }, 
            { name: "Insanity", chance: 1/666666, rarity: 666666 }, 
            { name: "Grand", chance: 1/1e6, rarity: 1e6 },
            { name: "SUPERNOVA", chance: 1/7.271338e8, rarity: 7.271338e8 },
            { name: "pure", chance: 1/400000, rarity: 400000 },
            { name: "Omnipotence. the almighty one. Allseeing, supernatural. The perfect rank, Perfectionist.", chance: 1/1e18, rarity: 1e18 },
            { name: "7 GRAND DAD", chance: 1/777.777, rarity: 777.777, requiresGrand: true },
            { name: ":[{(absolute zero)}]:", chance: 1/1e6, rarity: 1e6 },
            { name: "alpha", chance: 1/123456, rarity: 123456 },
            { name: "beta", chance: 1/1234567, rarity: 1234567 },
            { name: "gamma", chance: 1/12345678, rarity: 12345678 },
            { name: "Defined", chance: 1/1.5e6, rarity: 1.5e6 },
            { name: "Finale.. wait, how'd this get here?", chance: 1/2.5e6, rarity: 2.5e6 },
            { name: "Pseudopseudohypoparathyroidism", chance: 1/5e6, rarity: 5e6 },
            { name: "secret^2", chance: 1/1e7, rarity: 1e7 },
            { name: "cheese: cheddar", chance: 1/1.5e7, rarity: 1.5e7 },
            { name: "QHAR ?!?", chance: 1/2.5e7, rarity: 2.5e7 },
            { name: "!! EUPHORIA !!", chance: 1/56789000, rarity: 56789000 },
            { name: "CORRUPTED", chance: 1/648236826.394, rarity: 648236826.394, eventOnly: "Hellish" },
            { name: "Chargoggagoggmanchauggauggagoggchaubunagungamaugg", chance: 1/77777777.77, rarity: 77777777.77 },
            { name: "‚õßSatanic‚õß", chance: 1/1e9, rarity: 1e9 },
            { name: "CATASTROPHIC", chance: 1/575765.565, rarity: 575765.5265, multiplier: 575765.565 },
            { name: "LEGACY In im table ?!?!?", chance: 1/11111111111111.111, rarity: 11111111111111.111, multiplier: 11111111111111.11 },
            { name: "Destroyed", chance: 0, rarity: Infinity, eventOnly: "Hidden", eventChance: 1/100000000 },
            { name: "cali^2", chance: 1/1e12, rarity: 1e12 },
            { name: "c : omega c", chance: 1/5.555e8, rarity: 5.555e8 },
            { name: "one", chance: 1/1.1111111e11, rarity: 1.1111111111e11 },
            { name: "NEXUS", chance: 1/1.0001e9, rarity: 1e9 },
            { name: "SUPREMITY", chance: 1/6.1862863e13, rarity: 6.1862863e13 },
            { name: "Mythical", chance: 1/750000, rarity: 750000 },
            { name: "Guardian", chance: 1/1234072637263827, rarity: 1234072637263827 },
            { name: "Obscure", chance: 1/6942069420, rarity: 6942069420 },
            { name: "Possible", chance: 1/28284.2712475, rarity: 28284.2712475 },
            { name: "chezburger", chance: 1/1.5e10, rarity: 1.5e10 },
            { name: "coal osal !!!", chance: 1/5551112, rarity: 5551112 },
            { name: "Obscam", chance: 1/888.8888888e6, rarity: 888.8888888e6 },
            { name: "probable", chance: 1/7.5e7, rarity: 7.5e7 },
            { name: "WHAT THE FUCK", chance: 1/1e50, rarity: 1e50, multiplier: 1e50 }
        ];

        // FIX: Sort by chance ascending (rarest first) 
        SECRET_RANKS_CHANCES.sort((a, b) => a.chance - b.chance); 

        // --- NEW ---
        const EUPHORIA_SYMBOLS = ['%', '@', '#', '^', '$', '*', '&', '>', '<', '?'];
        // UPDATED: Total ranks count (updated for new ranks)
        const TOTAL_RANKS = 90;

        // --- NEW: SHAPES CONSTANTS ---
        const UNLOCK_SHAPES_COST = 5000000;
        const SHAPE_SPAWN_INTERVAL_MS = 2000;
        const MAX_SHAPE_LUCK_LEVEL = 5;
        const SHAPE_LUCK_BONUS = 0.1;
        const SHAPE_LUCK_COST_MULTIPLIER = 1.75;
        const LUCK_MULTI_COST_MULTIPLIER = 1000;
        const BULK_SHAPE_COST_MULTIPLIER = 5;
        const MAX_BULK_SHAPE_LEVEL = 4;
        const SHAPE_COOLDOWN_DECREASE_MS = 333.3333;
        const SHAPE_DESPAWN_TIME_MS = 5000;
        
        const SHAPES = [
            { name: "Triangle", chance: 1/2, rarity: 2, color: "#FFFF00" },
            { name: "Square", chance: 1/5, rarity: 5, color: "#00FF00" },
            { name: "Pentagon", chance: 1/10, rarity: 10, color: "#00FFFF" },
            { name: "Hexagon", chance: 1/25, rarity: 25, color: "#FF00FF" }, 
            { name: "7 Sided Polygon", chance: 1/50, rarity: 50, color: "#FFA500" },
            { name: "Octagon", chance: 1/100, rarity: 100, color: "#800080" },
            { name: "Circle", chance: 1/500, rarity: 500, color: "#FF0000" }
        ];

        // --- NEW: CLICKER CONSTANTS ---
        const UNLOCK_CLICKER_COST = 333333.33;
        const MAX_CLICKER_LUCK_LEVEL = 4;

        // --- NEW: COMPLEX RANK CONSTANT ---
        const COMPLEX_CHANCE = 1/75000;

        // --- NEW: HARDCORE MODE CONSTANT ---
        const HARDCORE_MODE_ENABLED = true;

        // --- NEW: SCIENTIFIC NOTATION CONSTANTS ---
        const DEFAULT_SCI_THRESHOLD = 1e18;

        // --- GAME STATE VARIABLES ---
        let currency = 0;
        let totalUpgrades = 0;
        let upgradeCost = 50;
        let highestBaseRoll = 0; 
        let highestFinalRoll = { 
            value: 0,
            baseValue: 0,
            rank: 'None yet',
            variants: [],
            isSecret: false
        };
        let autoRollInterval = null;
        let maxInventory = 10;
        let inventory = [];
        let rollIndex = 1;
        let acceptedRolls = new Set();
        let discoveredRanks = new Set();
        
        // NEW: Pending rolls system
        let pendingRolls = [];
        let maxPendingRolls = maxInventory * 3;
        
        // NEW: Secrets toggle
        let secretsEnabled = true;
        
        // NEW: Hardcore mode
        let hardcoreMode = false;
        let originalBulkRollLevel = 0;
        let originalLuck = 0;
        let originalVariantChance = 1;
        let originalSecretLuck = 1;
        
        // NEW: Scientific notation settings
        let sciNotationThreshold = DEFAULT_SCI_THRESHOLD;
        let sciNotationEnabled = true;
        
        // Auto-Accept Variables
        let autoAcceptThreshold = 0;
        let autoAcceptSecretThresholdValue = 0;
        let autoAcceptOnNewRank = false;
        let autoAcceptTrueRNGValue = 0;
        
        // Auto-Stop Variables
        let autoStopThreshold = 0;
        let autoStopSecretThresholdValue = 0;
        let autoStopOnNewRank = false;
        let autoStopTrueRNGValue = 0;
        
        let bulkRollLevel = 0;
        let bulkRollCost = 500000;
        let isCutscenePlaying = false; 
        
        // NEW: Cutscene state variable 
        let cutscenesEnabled = true; 
        
        // --- NEW EVENT VARIABLES ---
        let currentEvent = null; 
        let eventEndTime = 0;    
        let eventInterval = null;
        let eventCheckChance = 1; 

        // --- NEW: SHAPES VARIABLES ---
        let geometrix = 0;
        let shapesUnlocked = false;
        let shapeLuckLevel = 0;
        let shapeLuckCost = 5;
        let luckMultiLevel = 0;
        let luckMultiCost = 100;
        let bulkShapeLevel = 0;
        let bulkShapeCost = 50;
        let shapeInterval = null;
        let activeShapes = [];

        // --- NEW: CLICKER VARIABLES ---
        let clickerUnlocked = false;
        let fortunium = 0;
        let fortuniumLuck = 0;
        
        let gmxMultiLevel = 0;
        let gmxMultiCost = 75;
        
        let fortuniumLuckLevel = 0;
        let fortuniumLuckCost = 125;
        
        let clickerLuckLevel = 0;
        let clickerLuckCost = 1000;

        // --- NEW: EUPHORIA EFFECT ---
        let activeEuphoriaIntervals = {};

        // --- NEW: Bewilderment animation intervals ---
        let activeBewildermentIntervals = {};

        // --- NEW: Animation preservation tracking ---
        let activeAnimationElements = new Set();


        // --- OPTIMIZATION: CALCULATED STATS (set by updateCalculatedStats) ---
        let currentLuck = 0;
        let secretLuckMultiplier = 1;
        let variantChanceMultiplier = 1;

        // --- NEW: CALCULATED STATS ---
        let luckMultiValue = 1;
        let shapeLuckBonus = 0;
        let currentShapeCooldown = SHAPE_SPAWN_INTERVAL_MS;

        // --- UTILITY FUNCTIONS ---
        function formatInteger(num) {
            return num.toLocaleString('en-US');
        }

        function formatNumber(num) {
            // Handle negative numbers
            if (num < 0) {
                return "-" + formatNumber(Math.abs(num));
            }
            
            // Check for scientific notation threshold
            if (sciNotationEnabled && Math.abs(num) >= sciNotationThreshold) {
                return num.toExponential(2);
            }
            
            // Original formatting
            return num.toLocaleString('en-US', { 
                minimumFractionDigits: 2, 
                maximumFractionDigits: 2 
            });
        }
        
        function formatGeometrix(num) {
            if (sciNotationEnabled && Math.abs(num) >= sciNotationThreshold) {
                return num.toExponential(2);
            }
            return num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }
        
        function formatCooldown(ms) {
            return (ms / 1000).toFixed(4);
        }

        function escapeHTML(str) {
            if (!str) return '';
            return str.replace(/'/g, "\\'");
        }

        // --- NEW: Scientific notation functions ---
        function toggleScientificNotation() {
            sciNotationEnabled = !sciNotationEnabled;
            const statusEl = document.getElementById('sciNotationStatus');
            statusEl.textContent = sciNotationEnabled ? 'ON' : 'OFF';
            statusEl.style.color = sciNotationEnabled ? '#00ff00' : '#ff0000';
            
            updateStats();
            preserveAnimations();
            saveGame();
            
            addToTerminal(`Scientific notation ${sciNotationEnabled ? 'enabled' : 'disabled'} for numbers ‚â• ${formatNumber(sciNotationThreshold)}`, true);
        }

        // --- NEW: Hardcore mode functions ---
        function toggleHardcoreMode() {
            if (!HARDCORE_MODE_ENABLED) {
                addToTerminal('Hardcore mode is not available in this version.', true);
                return;
            }
            
            hardcoreMode = !hardcoreMode;
            
            if (hardcoreMode) {
                // Save original values
                originalBulkRollLevel = bulkRollLevel;
                originalLuck = currentLuck;
                originalVariantChance = variantChanceMultiplier;
                originalSecretLuck = secretLuckMultiplier;
                
                // Set hardcore values (default x1, +0)
                bulkRollLevel = 0;
                updateCalculatedStats();
                currentLuck = 0; // +0 luck
                variantChanceMultiplier = 1; // x1
                secretLuckMultiplier = 1; // x1
                luckMultiValue = 1; // x1 multiplier
                
                addToTerminal('‚ö†Ô∏è HARDCORE MODE ACTIVATED! Bulk=1, Luck=0, Variant=1, Secret=1, Events disabled', true, 'rank-1000000-100000000');
                
                // Update UI
                document.getElementById('hardcoreToggleBtn').textContent = 'Hardcore Mode: ON';
                document.getElementById('hardcoreToggleBtn').classList.add('active');
                document.getElementById('hardcoreStatus').textContent = 'ON';
                document.getElementById('hardcore-warning').style.display = 'block';
                document.body.classList.add('hardcore-mode-active');
            } else {
                // Restore original values
                bulkRollLevel = originalBulkRollLevel;
                updateCalculatedStats();
                currentLuck = originalLuck;
                variantChanceMultiplier = originalVariantChance;
                secretLuckMultiplier = originalSecretLuck;
                
                addToTerminal('Hardcore mode deactivated. Stats restored.', true);
                
                // Update UI
                document.getElementById('hardcoreToggleBtn').textContent = 'Hardcore Mode: OFF';
                document.getElementById('hardcoreToggleBtn').classList.remove('active');
                document.getElementById('hardcoreStatus').textContent = 'OFF';
                document.getElementById('hardcore-warning').style.display = 'none';
                document.body.classList.remove('hardcore-mode-active');
            }
            
            updateStats();
            saveGame();
        }

        // --- MODIFIED: Apply hardcore mode to event effects ---
        function getEventMultiplier(target) {
            if (hardcoreMode || !currentEvent) return 1;
            
            if (currentEvent.targets.includes("ALL_SECRETS")) {
                return currentEvent.multiplier;
            }
            
            if (currentEvent.targets.includes(target)) {
                return currentEvent.multiplier;
            }
            
            return 1;
        }

        // --- NEW: Animation preservation system ---
        function preserveAnimations() {
            // Store animation states for inventory items
            inventory.forEach((item, idx) => {
                const elementId = `inv-item-${idx}`;
                const element = document.getElementById(elementId);
                if (element && (item.rank === "!! EUPHORIA !!" || item.rank === "?!? bewilderment ?!?" || item.rank.includes("Complex"))) {
                    if (!activeAnimationElements.has(elementId)) {
                        activeAnimationElements.add(elementId);
                        // Restart animations for this element
                        if (item.rank === "!! EUPHORIA !!") {
                            setTimeout(() => initEuphoriaAnimation(elementId, "!! EUPHORIA !!"), 10);
                        }
                        if (item.rank === "?!? bewilderment ?!?") {
                            setTimeout(() => initBewildermentAnimation(elementId), 10);
                        }
                    }
                }
            });
            
            // Store animation states for terminal rolls
            document.querySelectorAll('.clickable-roll').forEach(el => {
                if (el.id && (el.textContent.includes("!! EUPHORIA !!") || el.textContent.includes("?!? bewilderment ?!?"))) {
                    if (!activeAnimationElements.has(el.id)) {
                        activeAnimationElements.add(el.id);
                        // The animations should already be running, but we ensure they persist
                    }
                }
            });
        }

        // --- MODIFIED: Sort inventory functions to use BASE value ---
        function sortInventory(type) {
            if (type === 'leastRarest') {
                inventory.sort((a, b) => (a.baseValue || a.value) - (b.baseValue || b.value));
            } else if (type === 'mostRarest') {
                inventory.sort((a, b) => (b.baseValue || b.value) - (a.baseValue || a.value));
            }
            updateInventoryDisplay();
            preserveAnimations(); // Preserve animations after sorting
            addToTerminal(`Inventory sorted by ${type === 'mostRarest' ? 'most rarest (Base Value)' : 'least rarest (Base Value)'}.`, true);
            saveGame();
        }

        // --- MODIFIED: Centralized function to calculate multipliers after upgrades ---
        function updateCalculatedStats() {
            // Base luck from main upgrades
            currentLuck = hardcoreMode ? 0 : totalUpgrades * LUCK_PER_UPGRADE; // Changed to 0 for HC
            
            // Shape luck (Upgrade 1)
            shapeLuckBonus = shapeLuckLevel * SHAPE_LUCK_BONUS;
            
            // Clicker Luck (Upgrade 3)
            const clickerLuckBonus = clickerLuckLevel * 0.5;
            
            // Luck Multiplier (Upgrade 2) + Clicker Luck
            luckMultiValue = hardcoreMode ? 1 : (Math.pow(2, luckMultiLevel) + clickerLuckBonus); // Changed for HC
            
            // Apply Luck Multiplier to main game mechanics
            secretLuckMultiplier = hardcoreMode ? 1 : Math.min(1 + (totalUpgrades * SECRET_LUCK_PER_UPGRADE), MAX_SECRET_LUCK) * luckMultiValue;
            variantChanceMultiplier = hardcoreMode ? 1 : Math.min(1 + (totalUpgrades * VARIANT_CHANCE_PER_UPGRADE), MAX_VARIANT_CHANCE_MULTIPLIER) * luckMultiValue;
            
            // Calculate shape cooldown from Upgrade 3
            currentShapeCooldown = Math.max(
                SHAPE_SPAWN_INTERVAL_MS - (bulkShapeLevel * SHAPE_COOLDOWN_DECREASE_MS), 
                SHAPE_SPAWN_INTERVAL_MS - (MAX_BULK_SHAPE_LEVEL * SHAPE_COOLDOWN_DECREASE_MS)
            );
            
            // Update pending rolls max based on current inventory
            maxPendingRolls = maxInventory * 3;
        }

        // --- MODIFIED: getVariants to handle new variants ---
        function getVariants(baseValue) {
            let selectedVariants = [];
            let totalMultiplier = 1;
            let hasNegative = false;
            let hasDull = false;

            let eventVariantMultiplier = hardcoreMode ? 1 : (currentEvent && currentEvent.name === "Modified" ? currentEvent.multiplier : 1);
            
            // First check for special bypass-cap variants
            for (let i = VARIANTS.length - 1; i >= 0; i--) {
                const variant = VARIANTS[i];
                
                // Skip regular variants if we're checking for bypass variants
                if (!variant.bypassCap) continue;
                
                const adjustedChance = variant.chance * variantChanceMultiplier * eventVariantMultiplier;
                
                if (Math.random() < adjustedChance) {
                    selectedVariants.push(variant);
                    
                    if (variant.isNegative) {
                        hasNegative = true;
                        totalMultiplier *= -1;
                    }
                    
                    if (variant.isDull) {
                        hasDull = true;
                        // Dull variant will be applied later
                    }
                }
            }
            
            // Then check for regular variants (up to MAX_VARIANTS_PER_ROLL)
            for (let i = VARIANTS.length - 1; i >= 0; i--) {
                const variant = VARIANTS[i];
                // Skip special variants that we already handled
                if (variant.bypassCap) continue;
                
                const adjustedChance = variant.chance * variantChanceMultiplier * eventVariantMultiplier;
                
                while (selectedVariants.length < MAX_VARIANTS_PER_ROLL && Math.random() < adjustedChance) {
                    selectedVariants.push(variant);
                    totalMultiplier *= variant.multiplier;
                }
            }
            
            let modifiedValue = baseValue * totalMultiplier;
            
            // Apply Dull transformation if needed (powers RNG by -1)
            if (hasDull) {
                if (modifiedValue !== 0) {
                    modifiedValue = Math.pow(modifiedValue, -1);
                }
            }
            
            if (selectedVariants.length > 0) {
                selectedVariants.sort((a, b) => {
                    // Sort Negative and Dull first
                    if (a.bypassCap && !b.bypassCap) return -1;
                    if (!a.bypassCap && b.bypassCap) return 1;
                    return (b.multiplier || 0) - (a.multiplier || 0);
                });
                return { 
                    variants: selectedVariants, 
                    modifiedValue: modifiedValue 
                };
            }
            return null;
        }

        function generateRoll() {
            const totalLuck = currentLuck * luckMultiValue;
            const baseRoll = Math.pow(Math.random(), 3 / POWER_EXPONENT) * (1 + totalLuck);
            return { value: baseRoll, variant: null };
        }
        
        // --- MODIFIED: To handle 7 GRAND DAD with fixed 1/777.777 chance ---
        function getSecretRank() {
            if (!secretsEnabled) return null;
            
            const rand = Math.random();
            
            let hiddenEventMultiplier = hardcoreMode ? 1 : (currentEvent && currentEvent.targets.includes("ALL_SECRETS") ? currentEvent.multiplier : 1);
            
            // Filter out destroyed and corrupted in HC mode
            const availableSecrets = hardcoreMode ? 
                SECRET_RANKS_CHANCES.filter(secret => 
                    secret.name !== "Destroyed" && secret.name !== "CORRUPTED"
                ) : 
                SECRET_RANKS_CHANCES;
            
            for (const secret of availableSecrets) {
                let chanceMultiplier = 1;
                let adjustedChance = secret.chance;

                // Event-Only Check
                if (secret.eventOnly) {
                    if (!currentEvent || currentEvent.name !== secret.eventOnly) {
                        continue;
                    }
                    // For Destroyed rank during Hidden event
                    if (secret.name === "Destroyed" && currentEvent.name === "Hidden" && secret.eventChance) {
                        adjustedChance = secret.eventChance;
                    }
                }

                // Time-based logic for 'breaktime'
                if (secret.timeBased && secret.name === "breaktime") {
                    const now = new Date();
                    const utc3OffsetMs = -3 * 60 * 60 * 1000;
                    const utc3Time = new Date(now.getTime() + utc3OffsetMs);
                    const dayOfWeek = utc3Time.getUTCDay();

                    if (dayOfWeek >= 1 && dayOfWeek <= 5) {
                        adjustedChance = 0;
                    } else {
                        adjustedChance = 1 / 705372;
                    }
                }

                if (!hardcoreMode && currentEvent && currentEvent.targets.includes(secret.name)) {
                    chanceMultiplier = currentEvent.multiplier;
                }
                
                // Skip 7 GRAND DAD here - handled separately in roll()
                if (secret.name === "7 GRAND DAD" && secret.requiresGrand) {
                    continue;
                }
                
                if (rand < adjustedChance * secretLuckMultiplier * chanceMultiplier * hiddenEventMultiplier) {
                    // Check for morts luck
                    if (secret.name === 'cali^2') {
                        if (Math.random() < 1/1e6) {
                            return { name: "morts luck", chance: 1/1e18, rarity: 1e18 };
                        }
                    }
                    return secret;
                }
            }
            return null;
        }

        // --- NEW: Rounding issue detection ---
        function checkRoundingIssue(value) {
            // Check if value is very close to a round number
            const rounded = Math.round(value);
            const diff = Math.abs(value - rounded);
            
            // If difference is extremely small but not zero (floating point precision issue)
            if (diff < 1e-6 && diff > 0) {
                return true;
            }
            
            // Check for common floating point issues
            const strValue = value.toString();
            if (strValue.includes('9999999999') || strValue.includes('0000000001')) {
                return true;
            }
            
            return false;
        }

        // MODIFIED: To handle Unobtainable rank and rounding issues
        function getRankInfo(value) {
            // Check for rounding issue
            if (checkRoundingIssue(value)) {
                return { 
                    name: "Improbable", 
                    value: value, 
                    rankNum: RANK_TIERS.length,
                    isUnobtainable: false
                };
            }
            
            // First, check if the value falls in the Unattainable tier
            for (let i = 0; i < RANK_TIERS.length; i++) {
                const tier = RANK_TIERS[i];
                if (value >= tier.min && value < tier.max) {
                    let rankName = tier.name;
                    let isUnobtainable = false;
                    
                    // Check if this is Unattainable and should be replaced with Unobtainable
                    if (tier.name === "Unattainable" && Math.random() < 1/200) {
                        rankName = "Unobtainable";
                        value *= 250000; // Multiply RNG by 250000
                        isUnobtainable = true;
                    }
                    
                    // Add [HC] suffix if in hardcore mode
                    if (hardcoreMode && !rankName.includes("[HC]")) {
                        rankName = rankName + " [HC]";
                    }
                    
                    return { 
                        name: rankName, 
                        value: value, 
                        rankNum: i + 1,
                        isUnobtainable: isUnobtainable
                    };
                }
            }
            
            let finalRankName = RANK_TIERS[RANK_TIERS.length - 1].name;
            if (hardcoreMode && !finalRankName.includes("[HC]")) {
                finalRankName = finalRankName + " [HC]";
            }
            
            return { 
                name: finalRankName, 
                value: value, 
                rankNum: RANK_TIERS.length,
                isUnobtainable: false
            };
        }

        // MODIFIED: To handle Unobtainable rank styling and hardcore mode
        function getRankClassAndColor(value, variants = [], rankName = "") {
            let color = "#ffffff";
            let className = "rank-1-1000";
            
            // Check for Unobtainable first
            if (rankName.includes("Unobtainable")) {
                className = "rank-unobtainable";
                color = "#000000";
            }
            // Check for Complex rank
            else if (rankName && rankName.includes("Complex")) {
                className = "rank-complex";
                color = "#ffffff";
            }
            else if (value >= 1e30) { className = "rank-improbable"; color = "#008080"; }
            else if (value >= 1e15) { className = "rank-rainbow"; color = "#ff7f00"; }
            else if (value >= 1e12) { className = "rank-1000000000000-100000000000000"; color = "#ff69b4"; }
            else if (value >= 1e11) { className = "rank-100000000000-1000000000000"; color = "#a9a9a9"; } 
            else if (value >= 1e10) { className = "rank-10000000000-100000000000"; color = "#ffc0cb"; } 
            else if (value >= 1e9) { className = "rank-1000000000-10000000000"; color = "#00ff00"; }
            else if (value >= 1e8) { className = "rank-100000000-1000000000"; color = "#8b0000"; }
            else if (value >= 1e6) { className = "rank-1000000-100000000"; color = "#ff0000"; }
            else if (value >= 1e5) { className = "rank-100000-1000000"; color = "#0000cd"; }
            else if (value >= 10000) { className = "rank-10000-100000"; color = "#00ffff"; }
            else if (value >= 1000) { className = "rank-1000-10000"; color = "#ffff00"; }
            
            // Add hardcore class if applicable
            if (hardcoreMode && rankName.includes("[HC]")) {
                className += " hardcore-rank";
            }
            
            return { className, color };
        }

        function getRankClass(value, variants = []) {
            return getRankClassAndColor(value, variants).className;
        }

        function addToTerminal(text, isCommand = false, className = "") {
            const terminal = document.getElementById('terminal');
            const line = document.createElement('div');
            line.className = 'output-line';
            if (isCommand) line.classList.add('command');
            if (className) line.classList.add(className);
            line.innerHTML = text;

            if (terminal.children.length > 100) {
                terminal.removeChild(terminal.firstChild);
            }

            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
            
            // Preserve animations after adding to terminal
            setTimeout(preserveAnimations, 50);
        }
        
        // NEW: Toggle Secrets Function 
        function toggleSecrets() {
            secretsEnabled = !secretsEnabled;
            const btn = document.getElementById('secretToggleBtn');
            const state = secretsEnabled ? 'ON' : 'OFF';
            btn.textContent = `Secrets: ${state}`;
            document.getElementById('secretsEnabled').textContent = secretsEnabled ? 'Yes' : 'No';
            addToTerminal(`Secrets turned ${state}.`, true);
            saveGame();
        }

        // NEW: Toggle Cutscenes Function 
        function toggleCutscenes() {
            cutscenesEnabled = !cutscenesEnabled;
            const btn = document.getElementById('cutsceneToggleBtn');
            const state = cutscenesEnabled ? 'ON' : 'OFF';
            btn.textContent = `Cutscenes: ${state}`;
            addToTerminal(`Cutscenes turned ${state}.`, true);
            saveGame();
        }

        // --- MODIFIED: To update all new stats including scientific notation ---
        function updateStats() {
            document.getElementById('currency').textContent = formatNumber(currency);
            document.getElementById('geometrix').textContent = formatGeometrix(geometrix);
            document.getElementById('upgrades').textContent = totalUpgrades;
            
            // Use pre-calculated global values
            document.getElementById('luck').textContent = currentLuck.toFixed(3);
            document.getElementById('luckMulti').textContent = luckMultiValue.toFixed(2);
            document.getElementById('secretLuck').textContent = secretLuckMultiplier.toFixed(2);
            document.getElementById('variantChance').textContent = variantChanceMultiplier.toFixed(2);
            
            document.getElementById('upgradeCost').textContent = formatNumber(upgradeCost);
            document.getElementById('inventoryCount').textContent = inventory.length;
            document.getElementById('inventoryMax').textContent = maxInventory;
            document.getElementById('pendingCount').textContent = pendingRolls.length;
            document.getElementById('pendingMax').textContent = maxPendingRolls;
            document.getElementById('ranksDiscovered').textContent = discoveredRanks.size;
            document.getElementById('totalRanks').textContent = TOTAL_RANKS;
            document.getElementById('secretsEnabled').textContent = secretsEnabled ? 'Yes' : 'No';
            document.getElementById('hardcoreStatus').textContent = hardcoreMode ? 'ON' : 'OFF';
            
            // Update scientific notation status
            document.getElementById('sciNotationStatus').textContent = sciNotationEnabled ? 'ON' : 'OFF';
            document.getElementById('sciNotationStatus').style.color = sciNotationEnabled ? '#00ff00' : '#ff0000';
            document.getElementById('sciNotationStat').textContent = `${sciNotationEnabled ? 'ON' : 'OFF'} (‚â•${formatNumber(sciNotationThreshold)})`;
            
            document.getElementById('bulkRollLevel').textContent = bulkRollLevel;
            document.getElementById('bulkRollAmount').textContent = bulkRollLevel + 1;
            
            const bulkCostEl = document.getElementById('bulkRollCost');
            const bulkBtnEl = document.getElementById('buyBulkRollBtn');
            
            if (bulkRollLevel >= MAX_BULK_ROLL_LEVEL) {
                bulkCostEl.textContent = "MAXED";
                if (bulkBtnEl) {
                    bulkBtnEl.disabled = true;
                    bulkBtnEl.textContent = "Bulk Roll (MAXED)";
                }
            } else {
                bulkCostEl.textContent = formatNumber(bulkRollCost);
                if (bulkBtnEl) {
                    bulkBtnEl.disabled = currency < bulkRollCost;
                    bulkBtnEl.textContent = "Buy Bulk Roll";
                }
            }
            
            // Dynamic Event Status Display
            const statsContainer = document.querySelector('.stats');
            let eventStat = document.getElementById('eventStat');
            if (!eventStat) {
                eventStat = document.createElement('div');
                eventStat.className = 'stat-item';
                eventStat.id = 'eventStat';
                statsContainer.appendChild(eventStat);
            }
            const eventName = currentEvent ? currentEvent.name : "None";
            const timeLeft = currentEvent ? Math.max(0, eventEndTime - Date.now()) : 0;
            const timeLeftFormatted = (timeLeft / 1000).toFixed(1);
            eventStat.innerHTML = `Active Event: <span style="color: ${currentEvent ? '#00FFFF' : '#ffffff'};">${eventName}</span> (${timeLeftFormatted}s)`;
            
            // Rarest Roll
            if (highestFinalRoll.value > 0 || highestFinalRoll.rank === "CORRUPTED") {
                const { className, color } = getRankClassAndColor(highestFinalRoll.value, highestFinalRoll.variants, highestFinalRoll.rank);
                let rankClass = className;
                let rollColor = color;
                let displayName = highestFinalRoll.rank;
                let displayValue = highestFinalRoll.value;
                let suffix = "";

                if (displayName === "~Nonavacious~") {
                    rankClass += " secret-nonavacious";
                }
                
                if (displayName === "CORRUPTED") {
                    rankClass += " secret-corrupted";
                    rollColor = "#FFFFFF";
                }
                
                // Special display for stats
                if (displayName === "‚õßSatanic‚õß") {
                    suffix = ` (Actual: ${formatNumber(highestFinalRoll.value)})`;
                    displayValue = -666.66;
                }
                if (displayName === "Finale.. wait, how'd this get here?") {
                    suffix = ` (Actual: ${formatNumber(highestFinalRoll.value)})`;
                    displayValue = 1e10;
                }
                
                document.getElementById('rarest').innerHTML = 
                    `<span class="satanic-wrapper"><span class="${rankClass}" style="color: ${rollColor};">${formatNumber(displayValue)} [${displayName}]${suffix}</span></span>`;
            }

            // NEW: Update Cutscene Toggle Button 
            const cutsceneBtn = document.getElementById('cutsceneToggleBtn');
            if (cutsceneBtn) {
                cutsceneBtn.textContent = `Cutscenes: ${cutscenesEnabled ? 'ON' : 'OFF'}`;
            }

            // NEW: Update Secrets Toggle Button
            const secretBtn = document.getElementById('secretToggleBtn');
            if (secretBtn) {
                secretBtn.textContent = `Secrets: ${secretsEnabled ? 'ON' : 'OFF'}`;
            }

            // NEW: Update Hardcore Mode Button
            const hardcoreBtn = document.getElementById('hardcoreToggleBtn');
            if (hardcoreBtn) {
                hardcoreBtn.textContent = `Hardcore Mode: ${hardcoreMode ? 'ON' : 'OFF'}`;
                if (hardcoreMode) {
                    hardcoreBtn.classList.add('active');
                } else {
                    hardcoreBtn.classList.remove('active');
                }
            }

            // --- Shapes GUI Updates - ALWAYS refresh ---
            const shapesGui = document.getElementById('shapes-gui');
            if (shapesGui) {
                shapesGui.style.display = shapesUnlocked ? 'block' : 'none';
                shapesGui.offsetHeight; // Force reflow
            }
            
            const shapesUnlockControls = document.getElementById('shapes-unlock-controls');
            if (shapesUnlockControls) {
                shapesUnlockControls.style.display = shapesUnlocked ? 'none' : 'grid';
            }
            
            document.getElementById('unlockShapesBtn').disabled = currency < UNLOCK_SHAPES_COST;

            if (shapesUnlocked) {
                document.getElementById('shapeLuckBonus').textContent = shapeLuckBonus.toFixed(1);
                document.getElementById('bulkShapeAmount').textContent = bulkShapeLevel + 1;
                document.getElementById('bulkShapeLevel').textContent = bulkShapeLevel;
                document.getElementById('shapeCooldown').textContent = formatCooldown(currentShapeCooldown);
                
                // Shape Luck Button
                const shapeLuckBtn = document.getElementById('buyShapeLuckBtn');
                document.getElementById('shapeLuckCost').textContent = formatGeometrix(shapeLuckCost);
                if (shapeLuckLevel >= MAX_SHAPE_LUCK_LEVEL) {
                    shapeLuckBtn.disabled = true;
                    shapeLuckBtn.innerHTML = `Shape Luck (MAXED)`;
                } else {
                    shapeLuckBtn.disabled = geometrix < shapeLuckCost;
                    shapeLuckBtn.innerHTML = `Shape Luck (+0.1x) - Cost: <span id="shapeLuckCost">${formatGeometrix(shapeLuckCost)}</span> GMX`;
                }
                
                // Luck Multi Button
                const luckMultiBtn = document.getElementById('buyLuckMultiBtn');
                document.getElementById('luckMultiCost').textContent = formatGeometrix(luckMultiCost);
                luckMultiBtn.disabled = geometrix < luckMultiCost;

                // Bulk Shape Button
                const bulkShapeBtn = document.getElementById('buyBulkShapeBtn');
                document.getElementById('bulkShapeCost').textContent = formatGeometrix(bulkShapeCost);
                if (bulkShapeLevel >= MAX_BULK_SHAPE_LEVEL) {
                    bulkShapeBtn.disabled = true;
                    bulkShapeBtn.innerHTML = `Bulk/Cooldown (MAXED)`;
                } else {
                    bulkShapeBtn.disabled = geometrix < bulkShapeCost;
                    bulkShapeBtn.innerHTML = `Bulk/Cooldown Lvl <span id="bulkShapeLevelBtn">${bulkShapeLevel + 1}</span> - Cost: <span id="bulkShapeCost">${formatGeometrix(bulkShapeCost)}</span> GMX`;
                }

                // Clicker Unlock Button
                const clickerUnlockBtn = document.getElementById('buyClickerUnlockBtn');
                if (clickerUnlockBtn) {
                     if (clickerUnlocked) {
                        clickerUnlockBtn.disabled = true;
                        clickerUnlockBtn.textContent = "Clicker Unlocked";
                    } else {
                        clickerUnlockBtn.disabled = geometrix < UNLOCK_CLICKER_COST;
                        clickerUnlockBtn.textContent = `Unlock Clicker - Cost: ${formatGeometrix(UNLOCK_CLICKER_COST)} GMX`;
                    }
                }
            }

            // --- Clicker GUI Updates - ALWAYS refresh ---
            const clickerGui = document.getElementById('clicker-gui');
            if (clickerGui) {
                clickerGui.style.display = clickerUnlocked ? 'block' : 'none';
                clickerGui.offsetHeight; // Force reflow
            }
            
            if (clickerUnlocked) {
                document.getElementById('fortunium').textContent = formatNumber(fortunium);
                document.getElementById('fortuniumLuck').textContent = fortuniumLuck.toFixed(2);
                
                // GMX Multi Button
                const gmxMultiBtn = document.getElementById('buyGmxMultiBtn');
                document.getElementById('gmxMultiCost').textContent = formatNumber(gmxMultiCost);
                gmxMultiBtn.disabled = fortunium < gmxMultiCost;
                gmxMultiBtn.innerHTML = `GMX Multi (+0.5x) - Cost: <span id="gmxMultiCost">${formatNumber(gmxMultiCost)}</span> FOR`;

                // Fortunium Luck Button
                const fortuniumLuckBtn = document.getElementById('buyFortuniumLuckBtn');
                document.getElementById('fortuniumLuckCost').textContent = formatNumber(fortuniumLuckCost);
                fortuniumLuckBtn.disabled = fortunium < fortuniumLuckCost;

                // Clicker Luck Button
                const clickerLuckBtn = document.getElementById('buyClickerLuckBtn');
                document.getElementById('clickerLuckCost').textContent = formatNumber(clickerLuckCost);
                if (clickerLuckLevel >= MAX_CLICKER_LUCK_LEVEL) {
                    clickerLuckBtn.disabled = true;
                    clickerLuckBtn.innerHTML = `Luck Multi (MAXED)`;
                } else {
                    clickerLuckBtn.disabled = fortunium < clickerLuckCost;
                    clickerLuckBtn.innerHTML = `Luck Multi (+0.5x) - Cost: <span id="clickerLuckCost">${formatNumber(clickerLuckCost)}</span> FOR`;
                }
            }
            
            // Preserve animations after updating stats
            preserveAnimations();
        }

        // --- MODIFIED: To handle EUPHORIA animation persistence, Unobtainable, and new ranks ---
        function updateInventoryDisplay() {
            const inventoryContent = document.getElementById('inventoryContent');
            if (inventory.length === 0) {
                inventoryContent.innerHTML = 'Empty';
            } else {
                inventoryContent.innerHTML = inventory.map((item, idx) => {
                    const { className: rankClass, color: rollColor } = getRankClassAndColor(item.value, item.variants, item.rank);
                    let displayClass = rankClass;
                    if (item.rank === "~Nonavacious~") {
                        displayClass += " secret-nonavacious";
                    }
                    if (item.rank === "CORRUPTED") {
                        displayClass += " secret-corrupted";
                    }
                    
                    let variantText = '';
                    if (item.variants && item.variants.length > 0) {
                        variantText = item.variants.map(v => `<span style="color: ${v.color}; font-weight: bold;">[${v.name}]</span>`).join('') + ' ';
                    }
                    let suffix = "";
                    let displayValue = item.value;
                    if (item.rank === "100") suffix = " * üíØ";
                    if (item.rank === ":[{(absolute zero)}]:") suffix = " * 0";
                    
                    // Special display for inventory
                    if (item.rank === "‚õßSatanic‚õß") {
                        suffix = ` (Actual: ${formatNumber(item.value)})`;
                        displayValue = -666.66;
                    }
                    if (item.rank === "Finale.. wait, how'd this get here?") {
                        suffix = ` (Actual: ${formatNumber(item.value)})`;
                        displayValue = 1e10;
                    }
                    
                    let content = `<span class="${displayClass}" style="color: ${rollColor};">${formatNumber(displayValue)} [${item.rank}]${suffix}</span>`;
                    // Wrap if satanic
                    if (item.rank === "‚õßSatanic‚õß") {
                        content = `<span class="satanic-wrapper">${content}</span>`;
                    }
                    
                    return `<div class="inventory-item" onclick="removeFromInventory(${idx})" id="inv-item-${idx}">
                        #${formatInteger(item.index)}: ${variantText}${content}
                    </div>`; 
                }).join('');
            }
            
            // Initialize animations for inventory items
            inventory.forEach((item, idx) => {
                const elementId = `inv-item-${idx}`;
                if (item.rank === "!! EUPHORIA !!" && !activeEuphoriaIntervals[elementId]) {
                    initEuphoriaAnimation(elementId, "!! EUPHORIA !!");
                }
                if (item.rank === "?!? bewilderment ?!?" && !activeBewildermentIntervals[elementId]) {
                    initBewildermentAnimation(elementId);
                }
            });
        }

        // --- MODIFIED: To add new secret ranks to index and fix sorting ---
        function updateIndexDisplay() {
            const indexContent = document.getElementById('indexContent');
            
            // Sort normal ranks by min value
            const sortedNormalRanks = [...RANK_TIERS].sort((a, b) => a.min - b.min);
            
            // Sort secret ranks by chance (rarity)
            const sortedSecretRanks = [...SECRET_RANKS_CHANCES].sort((a, b) => a.chance - b.chance);
            
            let html = '<div style="margin-bottom: 15px;"><strong>Normal Ranks:</strong></div>';
            
            sortedNormalRanks.forEach(tier => {
                const discovered = discoveredRanks.has(tier.name) || discoveredRanks.has(tier.name + " [HC]");
                let rankClass = getRankClass((tier.min + tier.max) / 2); 
                if (tier.name === "Improbable") {
                    rankClass = "rank-improbable";
                }
                html += `<div class="index-item ${discovered ? 'discovered' : 'locked'}">
                    ${discovered ? `<span class="${rankClass}">${tier.name}</span>` : '???'}
                </div>`;
            });
            
            // Add Unobtainable separately
            const unobtainableDiscovered = discoveredRanks.has("Unobtainable") || discoveredRanks.has("Unobtainable [HC]");
            html += `<div class="index-item ${unobtainableDiscovered ? 'discovered' : 'locked'}">
                ${unobtainableDiscovered ? `<span class="rank-unobtainable">Unobtainable</span>` : '???'}
            </div>`;
            
            html += '<div style="margin: 15px 0;"><strong>Secret Ranks:</strong></div>';
            
            sortedSecretRanks.forEach(rankInfo => {
                const rankName = rankInfo.name;
                if (rankInfo.timeBased) return;
                
                const discovered = discoveredRanks.has(rankName);
                let rankStyle = `color: #ff69b4;`;
                
                if (rankName === "CORRUPTED") {
                    rankStyle = `color: #ffffff; filter: invert(100%); display: inline-block;`;
                }
                
                html += `<div class="index-item ${discovered ? 'discovered' : 'locked'}">
                    ${discovered ? `<span style="${rankStyle}">${rankName}</span>` : '???'}
                </div>`;
            });
            
            // Add time-based and special ranks
            const breaktimeDiscovered = discoveredRanks.has("breaktime");
            html += `<div class="index-item ${breaktimeDiscovered ? 'discovered' : 'locked'}">
                ${breaktimeDiscovered ? `<span style="color: #ff69b4;">breaktime</span>` : '???'}
            </div>`;

            const mortsLuckDiscovered = discoveredRanks.has("morts luck");
            const mortsLuckStyle = `color: #ff0000; font-weight: bold;`;
            html += `<div class="index-item ${mortsLuckDiscovered ? 'discovered' : 'locked'}">
                ${mortsLuckDiscovered ? `<span style="${mortsLuckStyle}">morts luck</span>` : '???'}
            </div>`;
            
            indexContent.innerHTML = html;
        }

        // --- UPDATED: Pending rolls display - always visible ---
        function updatePendingDisplay() {
            const pendingContent = document.getElementById('pendingContent');
            
            if (pendingRolls.length === 0) {
                pendingContent.innerHTML = 'Empty';
            } else {
                pendingContent.innerHTML = pendingRolls.map((item, idx) => {
                    const { className: rankClass, color: rollColor } = getRankClassAndColor(item.value, item.variants, item.rank);
                    let displayClass = rankClass;
                    
                    if (item.rank === "~Nonavacious~") displayClass += " secret-nonavacious";
                    if (item.rank === "CORRUPTED") displayClass += " secret-corrupted";
                    
                    let variantText = '';
                    if (item.variants && item.variants.length > 0) {
                        variantText = item.variants.map(v => `<span style="color: ${v.color}; font-weight: bold;">[${v.name}]</span>`).join('') + ' ';
                    }
                    
                    return `<div class="pending-roll-item">
                        <div>
                            #${formatInteger(item.index)}: ${variantText}<span class="${displayClass}" style="color: ${rollColor};">${formatNumber(item.value)} [${item.rank}]</span>
                        </div>
                        <div class="pending-roll-buttons">
                            <button class="pending-accept-btn" onclick="acceptPendingRoll(${idx})">Accept</button>
                            <button class="pending-decline-btn" onclick="declinePendingRoll(${idx})">Decline</button>
                        </div>
                    </div>`;
                }).join('');
            }
        }

        // --- NEW: Accept pending roll ---
        function acceptPendingRoll(idx) {
            const pending = pendingRolls[idx];
            if (addToInventory(pending.value, pending.rank, pending.index, pending.variants, pending.baseValue)) {
                pendingRolls.splice(idx, 1);
                updatePendingDisplay();
                addToTerminal(`Accepted pending roll #${formatInteger(pending.index)} (${pending.rank})`, true);
                updateStats();
                saveGame();
            } else {
                addToTerminal('Cannot accept: inventory full!', true);
            }
        }

        // --- NEW: Decline pending roll ---
        function declinePendingRoll(idx) {
            const pending = pendingRolls[idx];
            pendingRolls.splice(idx, 1);
            updatePendingDisplay();
            addToTerminal(`Declined pending roll #${formatInteger(pending.index)} (${pending.rank})`, true);
            updateStats();
            saveGame();
        }

        function addToInventory(value, rank, index, variants = [], baseValue = null) {
            if (inventory.length >= maxInventory) {
                return false;
            }
            const isSecret = SECRET_RANKS_CHANCES.map(r => r.name).includes(rank.replace(" [HC]", "")) || 
                            rank === "morts luck" || 
                            rank === "breaktime" || 
                            rank.includes("Unobtainable");
            inventory.push({ value, rank, index, variants, baseValue: baseValue || value, isSecret });
            updateInventoryDisplay();
            updateStats();
            saveGame();
            return true;
        }

        // --- NEW: Add to pending rolls ---
        function addToPendingRolls(value, rank, index, variants = [], baseValue = null) {
            if (pendingRolls.length >= maxPendingRolls) {
                return false;
            }
            
            const isSecret = SECRET_RANKS_CHANCES.map(r => r.name).includes(rank.replace(" [HC]", "")) || 
                            rank === "morts luck" || 
                            rank === "breaktime" || 
                            rank.includes("Unobtainable");
            pendingRolls.push({ value, rank, index, variants, baseValue: baseValue || value, isSecret });
            updatePendingDisplay();
            updateStats();
            return true;
        }

        // --- MODIFIED: To restart EUPHORIA animation on remove ---
        function removeFromInventory(idx) {
            const item = inventory[idx];
            
            let variantText = '';
            if (item.variants && item.variants.length > 0) {
                variantText = item.variants.map(v => `[${v.name}]`).join('') + ' ';
            }
            
            let suffix = "";
            let displayValue = item.value;
            if (item.rank === "üíØ") suffix = " * üíØ";
            if (item.rank === ":[{(absolute zero)}]:") suffix = " * 0";
            
            if (item.rank === "‚õßSatanic‚õß") {
                suffix = ` (Actual: ${formatNumber(item.value)})`;
                displayValue = -666.66;
            }
            if (item.rank === "Finale.. wait, how'd this get here?") {
                suffix = ` (Actual: ${formatNumber(item.value)})`;
                displayValue = 1e10;
            }
            
            addToTerminal(`Removed from inventory: #${formatInteger(item.index)} ${variantText}${formatNumber(displayValue)} [${item.rank}]${suffix}`, true); 
            
            acceptedRolls.delete(item.index);
            
            const rollElement = document.getElementById(`roll-${item.index}`);
            if (rollElement) {
                rollElement.style.opacity = '1';
                rollElement.style.cursor = 'pointer';
                
                rollElement.onclick = function() { 
                    tryAddToInventory(item.value, item.rank, item.index, rollElement); 
                };

                // Restart animation
                if (item.rank === "!! EUPHORIA !!") {
                    setTimeout(() => initEuphoriaAnimation(`roll-${item.index}`, "!! EUPHORIA !!"), 10);
                }
                if (item.rank === "?!? bewilderment ?!?") {
                    setTimeout(() => initBewildermentAnimation(`roll-${item.index}`), 10);
                }
            }
            
            inventory.splice(idx, 1);
            updateInventoryDisplay();
            updateStats();
            saveGame();
        }

        function playCutscene(rollValue, isSecret = false) {
            if (!cutscenesEnabled || hardcoreMode) {
                return Promise.resolve();
            }

            return new Promise(resolve => {
                const wasAutoRolling = autoRollInterval !== null;
                if (wasAutoRolling) {
                    toggleAutoRoll();
                }
                
                isCutscenePlaying = true;
                const body = document.body;
                const overlay = document.getElementById('cutscene-overlay');
                const starElement = document.getElementById('star-element');
                
                body.classList.add('cutscene-active');
                
                const { color } = getRankClassAndColor(rollValue);
                starElement.style.color = color;
                
                let starShapeClass = 'star-4'; 
                if (rollValue >= 1e12 && isSecret) {
                    starShapeClass = 'star-12';
                } else if (rollValue >= 1e9 && isSecret) {
                    starShapeClass = 'star-6';
                } else if (rollValue >= 1e12) {
                    starShapeClass = 'star-8';
                }
                
                starElement.className = starShapeClass;
                starElement.style.transform = 'translate(-50%, -50%) rotate(0deg) scale(1)'; 
                let currentScale = 1;
                let currentRotation = 0;
                let rotationSpeed = 3; 
                let sizeInterval = null;
                
                setTimeout(() => {
                    starElement.style.opacity = 1;
                }, STAR_FADE_IN_MS);
                
                const spinUpdate = () => {
                    currentRotation += rotationSpeed;
                    starElement.style.transform = `translate(-50%, -50%) rotate(${currentRotation}deg) scale(${currentScale})`; 
                    if (isCutscenePlaying) {
                        requestAnimationFrame(spinUpdate);
                    }
                };

                requestAnimationFrame(spinUpdate);

                setTimeout(() => {
                    rotationSpeed = 15; 
                    
                    sizeInterval = setInterval(() => {
                        currentScale *= SIZE_MULTIPLIER_PER_UPDATE;
                    }, SIZE_UPDATE_INTERVAL_MS);

                }, SPIN_ACCEL_MS);
                
                setTimeout(() => {
                    starElement.style.opacity = 0;
                    body.classList.add('cutscene-flash');
                    
                    setTimeout(() => {
                        isCutscenePlaying = false;
                        clearInterval(sizeInterval);
                        
                        body.classList.remove('cutscene-flash');
                        body.classList.remove('cutscene-active');
                        
                        setTimeout(() => {
                            starElement.style.transform = 'translate(-50%, -50%) rotate(0deg) scale(1)';
                            starElement.style.color = '';
                            starElement.className = '';
                            if (wasAutoRolling) {
                                toggleAutoRoll();
                            }
                            resolve();
                        }, 500);
                        
                    }, WHITE_FLASH_DURATION_MS);
                    
                }, CUTSCENE_DURATION_MS - WHITE_FLASH_DURATION_MS);
            });
        }

        // --- NEW: Bewilderment animation function ---
        function initBewildermentAnimation(elementId) {
            const element = document.getElementById(elementId);
            if (!element) return;
            
            // Store original text
            const originalText = element.textContent || element.innerText;
            if (!originalText.includes("?!? bewilderment ?!?")) return;
            
            // Create blinking effect
            let isQuestionMark = true;
            const intervalId = setInterval(() => {
                if (!document.getElementById(elementId)) {
                    clearInterval(intervalId);
                    delete activeBewildermentIntervals[elementId];
                    return;
                }
                
                if (isQuestionMark) {
                    element.textContent = originalText.replace("?!? bewilderment ?!?", "!?! bewilderment !?!");
                    element.innerHTML = element.innerHTML.replace("?!? bewilderment ?!?", "!?! bewilderment !?!");
                } else {
                    element.textContent = originalText;
                    element.innerHTML = originalText;
                }
                isQuestionMark = !isQuestionMark;
            }, 10);
            
            activeBewildermentIntervals[elementId] = intervalId;
            activeAnimationElements.add(elementId);
        }

        // --- MODIFIED: Complex rank generation (x + yi) ---
        function generateComplexRank() {
            if (Math.random() < COMPLEX_CHANCE) {
                // Generate two separate rolls for real and imaginary parts
                const totalLuck = currentLuck * luckMultiValue;
                const realPart = Math.pow(Math.random(), 3 / POWER_EXPONENT) * (1 + totalLuck);
                const imagPart = Math.pow(Math.random(), 3 / POWER_EXPONENT) * (1 + totalLuck);
                
                const rankInfoReal = getRankInfo(realPart);
                const rankInfoImag = getRankInfo(imagPart);
                
                let displayName = `Complex: ${rankInfoReal.name.replace(" [HC]", "")} + ${rankInfoImag.name.replace(" [HC]", "")}i`;
                if (hardcoreMode) {
                    displayName += " [HC]";
                }
                
                return {
                    isComplex: true,
                    realPart: realPart,
                    imagPart: imagPart,
                    realRankName: rankInfoReal.name,
                    imagRankName: rankInfoImag.name,
                    displayName: displayName
                };
            }
            return null;
        }

        // --- MODIFIED: To handle 7 Grand Dad with FIXED 1/777.777 chance ---
        async function roll() {
            if (isCutscenePlaying) {
                addToTerminal('Wait for the cutscene to finish!', true);
                return;
            }
            
            const rollResults = [];
            let maxRollValueInBulk = 0;
            let isMaxRollSecret = false;
            let newRankDiscoveredInBulk = false;
            
            // Use hardcore mode bulk (1) or normal bulk
            const bulkAmount = hardcoreMode ? 1 : (bulkRollLevel + 1);
            
            for (let i = 0; i < bulkAmount; i++) {
                // Check for Complex rank
                const complexResult = generateComplexRank();
                
                if (complexResult) {
                    // Handle complex rank (x + yi)
                    const baseValue = complexResult.realPart;
                    const variantResult = getVariants(baseValue);
                    
                    // Complex numbers use both real and imaginary parts
                    const displayValue = {
                        real: complexResult.realPart,
                        imag: complexResult.imagPart
                    };
                    
                    const variants = variantResult ? variantResult.variants : [];
                    
                    const displayName = complexResult.displayName;
                    const isSecret = false;
                    
                    rollResults.push({ 
                        baseValue: baseValue, 
                        displayValue: displayValue, 
                        complexValue: true,
                        variants, 
                        displayName, 
                        isSecret, 
                        secretRarityMultiplier: 1,
                        rankInfo: { name: displayName, rankNum: 999, isUnobtainable: false },
                        isComplex: true,
                        complexData: complexResult
                    });
                    
                    // For max roll comparison, use magnitude sqrt(real^2 + imag^2)
                    const magnitude = Math.sqrt(complexResult.realPart**2 + complexResult.imagPart**2);
                    if (magnitude > maxRollValueInBulk) {
                        maxRollValueInBulk = magnitude;
                        isMaxRollSecret = isSecret;
                    }
                    
                    const baseRankName = displayName.replace(" [HC]", "");
                    if (!discoveredRanks.has(baseRankName)) {
                        newRankDiscoveredInBulk = true;
                    }
                    
                    continue;
                }
                
                // Normal roll generation
                const rollResult = generateRoll();
                let baseValue = rollResult.value;
                
                // FIXED: Check for 7 GRAND DAD ONLY when rolling Grand (1e6 to 1e7)
                let isGrandRoll = baseValue >= 1e6 && baseValue < 1e7;
                let shouldCheck7GrandDad = isGrandRoll && Math.random() < (1/777.777);

                // Apply Lol event boost to 7 GRAND DAD
                if (shouldCheck7GrandDad && currentEvent && currentEvent.name === "Lol") {
                    shouldCheck7GrandDad = Math.random() < (1/777.777) * currentEvent.multiplier;
                }
                
                // Get variants (now includes Negative and Dull)
                const variantResult = getVariants(baseValue);
                let displayValue = variantResult ? variantResult.modifiedValue : baseValue;
                const variants = variantResult ? variantResult.variants : [];
                
                // Check for 7 GRAND DAD after variants are applied
                if (shouldCheck7GrandDad) {
                    // Create 7 GRAND DAD secret
                    const sevenGrandDad = {
                        name: "7 GRAND DAD",
                        chance: 1/777.777,
                        rarity: 777.777,
                        multiplier: 7777777
                    };
                    
                    // Apply 7 GRAND DAD multiplier
                    displayValue *= sevenGrandDad.multiplier;
                    
                    rollResults.push({ 
                        baseValue, 
                        displayValue, 
                        variants, 
                        displayName: "7 GRAND DAD", 
                        isSecret: true, 
                        secretRarityMultiplier: sevenGrandDad.multiplier,
                        rankInfo: { name: "7 GRAND DAD", rankNum: 999, isUnobtainable: false },
                        isComplex: false
                    });
                    
                    if (displayValue > maxRollValueInBulk) {
                        maxRollValueInBulk = displayValue;
                        isMaxRollSecret = true;
                    }
                    
                    const baseRankName = "7 GRAND DAD";
                    if (!discoveredRanks.has(baseRankName)) {
                        newRankDiscoveredInBulk = true;
                    }
                    
                    continue;
                }
                
                // Original secret rank logic
                const secretResult = getSecretRank(); 
                let rankInfo = getRankInfo(baseValue);
                let displayName = secretResult ? secretResult.name : rankInfo.name;
                const isSecret = !!secretResult;
                
                // Apply CATASTROPHIC multiplier if applicable
                if (displayName === "CATASTROPHIC" && secretResult.multiplier) {
                    displayValue *= secretResult.multiplier;
                }
                
                // Apply Unobtainable multiplier if applicable
                if (rankInfo.isUnobtainable) {
                    displayName = hardcoreMode ? "Unobtainable [HC]" : "Unobtainable";
                    displayValue = rankInfo.value;
                }
                
                // Apply LEGACY In im table ?!?!? multiplier
                if (displayName === "LEGACY In im table ?!?!?" && secretResult.multiplier) {
                    displayValue *= secretResult.multiplier;
                }
                
                let secretRarityMultiplier = 1;
                if (isSecret) {
                    if (secretResult.rarity) {
                        secretRarityMultiplier = secretResult.rarity;
                        displayValue *= secretRarityMultiplier;
                    } else {
                        displayValue = 0; 
                    }
                }
                
                // CORRUPTED Logic (not available in HC mode)
                if (displayName === "CORRUPTED") {
                    displayValue *= -1;
                }
                
                // Destroyed logic (not available in HC mode)
                if (displayName === "Destroyed") {
                    displayValue = 0;
                }
                
                rollResults.push({ 
                    baseValue, 
                    displayValue, 
                    variants, 
                    displayName, 
                    isSecret, 
                    secretRarityMultiplier,
                    rankInfo,
                    isComplex: false
                });
                
                if (displayValue > maxRollValueInBulk) {
                    maxRollValueInBulk = displayValue;
                    isMaxRollSecret = isSecret;
                }
                
                const baseRankName = displayName.replace(" [HC]", "");
                if (!discoveredRanks.has(baseRankName)) {
                    newRankDiscoveredInBulk = true;
                }
            }
            
            if (cutscenesEnabled && maxRollValueInBulk >= 1e9 && !hardcoreMode) {
                await playCutscene(maxRollValueInBulk, isMaxRollSecret);
            }
            
            for (const rollData of rollResults) {
                let { baseValue, displayValue, complexValue, variants, displayName, isSecret, secretRarityMultiplier, rankInfo, isComplex, complexData } = rollData;
                
                const currencyGain = Math.pow(rankInfo.rankNum, 3);
                
                const { className: rankClassBase, color: rollColorBase } = getRankClassAndColor(
                    typeof displayValue === 'object' ? Math.sqrt(displayValue.real**2 + displayValue.imag**2) : displayValue, 
                    variants, 
                    displayName
                );

                let rankClass = rankClassBase;
                let rollColor = rollColorBase;

                // Apply special classes
                if (displayName === "CORRUPTED") {
                    rankClass += " secret-corrupted";
                    rollColor = "#FFFFFF"; 
                }
                
                if (isComplex) {
                    rankClass = "rank-complex";
                }

                let suffix = "";
                let finalDisplayValue = displayValue;
                
                if (displayName === "100") suffix = ` * üíØ`;
                if (displayName === ":[{(absolute zero)}]:") suffix = ` * 0`;
                
                // Special Display Logic
                if (displayName === "‚õßSatanic‚õß") {
                    suffix = ` (Actual: ${formatNumber(displayValue)})`;
                    finalDisplayValue = -666.66;
                    rankClass = "rank-1000000-100000000";
                    rollColor = "#ff0000";
                }
                if (displayName === "Finale.. wait, how'd this get here?") {
                    suffix = ` (Actual: ${formatNumber(displayValue)})`;
                    finalDisplayValue = 1e10; 
                    rankClass = getRankClass(1e10);
                    rollColor = getRankClassAndColor(1e10).color;
                }
                
                const secretMultiplierText = (isSecret && secretRarityMultiplier > 1) ? ` (x${formatNumber(secretRarityMultiplier)})` : '';

                if (displayName === "~Nonavacious~") {
                    rankClass += " secret-nonavacious";
                }
                
                const currentIndex = rollIndex++;
                
                let newRankDiscovered = false;
                const baseRankName = displayName.replace(" [HC]", "");
                if (!discoveredRanks.has(baseRankName)) {
                    discoveredRanks.add(baseRankName);
                    addToTerminal(`üéâ NEW RANK DISCOVERED: ${displayName}!`, true);
                    updateIndexDisplay();
                    newRankDiscovered = true;
                }
                
                currency += currencyGain;
                
                if (baseValue > highestBaseRoll) {
                    highestBaseRoll = baseValue;
                }

                if ((displayName !== "CORRUPTED" && displayValue > highestFinalRoll.value) || 
                    (displayName === "CORRUPTED" && (highestFinalRoll.rank !== "CORRUPTED" || displayValue < highestFinalRoll.value))) {
                    highestFinalRoll = {
                        value: displayValue,
                        baseValue: baseValue,
                        rank: displayName,
                        variants: variants,
                        isSecret: isSecret
                    };
                }
                
                // AUTO-ACCEPT LOGIC
                const shouldAcceptOnValue = autoAcceptThreshold > 0 && displayValue >= autoAcceptThreshold;
                const shouldAcceptOnSecret = autoAcceptSecretThresholdValue > 0 && isSecret && secretRarityMultiplier >= autoAcceptSecretThresholdValue;
                const shouldAcceptOnNew = autoAcceptOnNewRank && newRankDiscovered;
                const shouldAcceptOnTrueRNG = autoAcceptTrueRNGValue > 0 && baseValue >= autoAcceptTrueRNGValue;
                const shouldAcceptCorrupted = displayName === "CORRUPTED" && (autoAcceptSecretThresholdValue > 0 || autoAcceptThreshold > 0);
                
                // AUTO-STOP LOGIC
                const shouldStopOnValue = autoStopThreshold > 0 && displayValue >= autoStopThreshold;
                const shouldStopOnSecret = autoStopSecretThresholdValue > 0 && isSecret && secretRarityMultiplier >= autoStopSecretThresholdValue;
                const shouldStopOnNew = autoStopOnNewRank && newRankDiscovered;
                const shouldStopOnTrueRNG = autoStopTrueRNGValue > 0 && baseValue >= autoStopTrueRNGValue;
                const shouldStopCorrupted = displayName === "CORRUPTED" && (autoStopSecretThresholdValue > 0 || autoStopThreshold > 0);
                
                const variantText = variants.map(v => `<span style="color: ${v.color}; font-weight: bold;">[${v.name}]</span>`).join('') + ' ';
                
                const variantDataAttr = variants.length > 0 ? `data-variants='${JSON.stringify(variants)}'` : '';
                const baseValueAttr = `data-basevalue='${baseValue}'`;
                
                let content = '';
                
                if (isComplex) {
                    // Display complex number as "real + imag i"
                    const realFormatted = formatNumber(complexData.realPart);
                    const imagFormatted = formatNumber(complexData.imagPart);
                    content = `<span class="clickable-roll ${rankClass}" style="color: ${rollColor};" onclick="tryAddToInventory(${displayValue}, '${escapeHTML(displayName)}', ${currentIndex}, this)" id="roll-${currentIndex}" ${variantDataAttr} ${baseValueAttr}>${realFormatted} + ${imagFormatted}i [${displayName}]${secretMultiplierText}${suffix}</span>`;
                } else {
                    content = `<span class="clickable-roll ${rankClass}" style="color: ${rollColor};" onclick="tryAddToInventory(${displayValue}, '${escapeHTML(displayName)}', ${currentIndex}, this)" id="roll-${currentIndex}" ${variantDataAttr} ${baseValueAttr}>${formatNumber(finalDisplayValue)} [${displayName}]${secretMultiplierText}${suffix}</span>`;
                }
                
                if (displayName === "‚õßSatanic‚õß") {
                    content = `<span class="satanic-wrapper">${content}</span>`;
                }

                addToTerminal(
                    `#${formatInteger(currentIndex)}: ${variantText}${content} (+${currencyGain.toFixed(2)} currency)`
                );

                // Initialize animations
                if (displayName === "?!? bewilderment ?!?") {
                    setTimeout(() => initBewildermentAnimation(`roll-${currentIndex}`), 100);
                }
                
                if (displayName === "!! EUPHORIA !!") {
                    initEuphoriaAnimation(`roll-${currentIndex}`, "!! EUPHORIA !!");
                }
                
                if (isComplex) {
                    activeAnimationElements.add(`roll-${currentIndex}`);
                }

                // AUTO-ACCEPT Logic
                if (autoRollInterval && (shouldAcceptOnValue || shouldAcceptOnSecret || shouldAcceptOnNew || shouldAcceptOnTrueRNG || shouldAcceptCorrupted)) {
                    
                    const rollElement = document.getElementById(`roll-${currentIndex}`);
                    
                    if (!acceptedRolls.has(currentIndex)) {
                        if (inventory.length >= maxInventory) {
                            // Send to pending rolls if inventory full
                            if (addToPendingRolls(displayValue, displayName, currentIndex, variants, baseValue)) {
                                acceptedRolls.add(currentIndex);
                                
                                if (activeEuphoriaIntervals[currentIndex]) {
                                    clearInterval(activeEuphoriaIntervals[currentIndex]);
                                    delete activeEuphoriaIntervals[currentIndex];
                                }
                                
                                if (activeBewildermentIntervals[`roll-${currentIndex}`]) {
                                    clearInterval(activeBewildermentIntervals[`roll-${currentIndex}`]);
                                    delete activeBewildermentIntervals[`roll-${currentIndex}`];
                                }
                                
                                let acceptSuffix = "";
                                if (displayName === "‚õßSatanic‚õß") acceptSuffix = ` (Actual: ${formatNumber(displayValue)})`;
                                if (displayName === "Finale.. wait, how'd this get here?") acceptSuffix = ` (Actual: ${formatNumber(displayValue)})`;
                                
                                addToTerminal(`Auto-Accepted to pending: #${formatInteger(currentIndex)} ${variantText}${formatNumber(finalDisplayValue)} [${displayName}]${acceptSuffix}`, true, 'rank-1000-10000');
                                
                                if (rollElement) {
                                    rollElement.style.opacity = '0.5';
                                    rollElement.style.cursor = 'not-allowed';
                                    rollElement.onclick = null;
                                }
                                
                                saveGame();
                            }
                        } else {
                            // Add directly to inventory
                            if (addToInventory(displayValue, displayName, currentIndex, variants, baseValue)) {
                                acceptedRolls.add(currentIndex);
                                
                                if (activeEuphoriaIntervals[currentIndex]) {
                                    clearInterval(activeEuphoriaIntervals[currentIndex]);
                                    delete activeEuphoriaIntervals[currentIndex];
                                }
                                
                                if (activeBewildermentIntervals[`roll-${currentIndex}`]) {
                                    clearInterval(activeBewildermentIntervals[`roll-${currentIndex}`]);
                                    delete activeBewildermentIntervals[`roll-${currentIndex}`];
                                }
                                
                                let acceptSuffix = "";
                                if (displayName === "‚õßSatanic‚õß") acceptSuffix = ` (Actual: ${formatNumber(displayValue)})`;
                                if (displayName === "Finale.. wait, how'd this get here?") acceptSuffix = ` (Actual: ${formatNumber(displayValue)})`;
                                
                                addToTerminal(`Auto-Accepted: #${formatInteger(currentIndex)} ${variantText}${formatNumber(finalDisplayValue)} [${displayName}]${acceptSuffix}`, true, 'rank-1000-10000');
                                
                                if (rollElement) {
                                    rollElement.style.opacity = '0.5';
                                    rollElement.style.cursor = 'not-allowed';
                                    rollElement.onclick = null;
                                }
                                
                                saveGame();
                            }
                        }
                    }
                }
                
                // AUTO-STOP Logic (stops auto-roll without accepting)
                if (autoRollInterval && (shouldStopOnValue || shouldStopOnSecret || shouldStopOnNew || shouldStopOnTrueRNG || shouldStopCorrupted)) {
                    toggleAutoRoll();
                    addToTerminal(`Auto-roll STOPPED by stop condition: #${formatInteger(currentIndex)} ${variantText}${formatNumber(finalDisplayValue)} [${displayName}]`, true, 'rank-1000000-100000000');
                    break;
                }
            }
            
            updateStats();
            preserveAnimations();
            saveGame();
        }

        // --- MODIFIED: To stop animations on accept and handle pending rolls ---
        function tryAddToInventory(value, rank, index, element) {
            if (acceptedRolls.has(index)) {
                addToTerminal(`Roll #${formatInteger(index)} has already been accepted!`, true);
                return;
            }
            
            let variants = [];
            let baseValue = value;
            
            if (element && element.dataset) {
                if (element.dataset.variants) {
                    try {
                        variants = JSON.parse(element.dataset.variants);
                    } catch (e) {
                        console.error('Error parsing variants:', e);
                    }
                }
                if (element.dataset.basevalue) {
                    baseValue = parseFloat(element.dataset.basevalue);
                }
            }
            
            // Check if inventory is full
            if (inventory.length >= maxInventory) {
                // Try to add to pending rolls
                if (addToPendingRolls(value, rank, index, variants, baseValue)) {
                    acceptedRolls.add(index);

                    // Stop animations
                    if (activeEuphoriaIntervals[index]) {
                        clearInterval(activeEuphoriaIntervals[index]);
                        delete activeEuphoriaIntervals[index];
                    }
                    
                    if (activeBewildermentIntervals[`roll-${index}`]) {
                        clearInterval(activeBewildermentIntervals[`roll-${index}`]);
                        delete activeBewildermentIntervals[`roll-${index}`];
                    }
                    
                    const variantText = variants.map(v => `[${v.name}]`).join('') + ' ';
                    
                    let suffix = "";
                    let displayValue = value;
                    if (rank === "100") suffix = " * üíØ";
                    if (rank === ":[{(absolute zero)}]:") suffix = " * 0";
                    
                    if (rank === "‚õßSatanic‚õß") {
                        suffix = ` (Actual: ${formatNumber(value)})`;
                        displayValue = -666.66;
                    }
                    if (rank === "Finale.. wait, how'd this get here?") {
                        suffix = ` (Actual: ${formatNumber(value)})`;
                        displayValue = 1e10;
                    }
                    
                    addToTerminal(`Added to pending rolls: #${formatInteger(index)} ${variantText}${formatNumber(displayValue)} [${rank}]${suffix}`, true); 
                    
                    const rollElement = document.getElementById(`roll-${index}`);
                    if (rollElement) {
                        rollElement.style.opacity = '0.5';
                        rollElement.style.cursor = 'not-allowed';
                        rollElement.onclick = null;
                    }
                    
                    saveGame();
                } else {
                    addToTerminal(`Cannot add to inventory or pending rolls: both are full!`, true);
                }
            } else {
                // Add to inventory
                if (addToInventory(value, rank, index, variants, baseValue)) {
                    acceptedRolls.add(index);

                    // Stop animations
                    if (activeEuphoriaIntervals[index]) {
                        clearInterval(activeEuphoriaIntervals[index]);
                        delete activeEuphoriaIntervals[index];
                    }
                    
                    if (activeBewildermentIntervals[`roll-${index}`]) {
                        clearInterval(activeBewildermentIntervals[`roll-${index}`]);
                        delete activeBewildermentIntervals[`roll-${index}`];
                    }
                    
                    const variantText = variants.map(v => `[${v.name}]`).join('') + ' ';
                    
                    let suffix = "";
                    let displayValue = value;
                    if (rank === "100") suffix = " * üíØ";
                    if (rank === ":[{(absolute zero)}]:") suffix = " * 0";
                    
                    if (rank === "‚õßSatanic‚õß") {
                        suffix = ` (Actual: ${formatNumber(value)})`;
                        displayValue = -666.66;
                    }
                    if (rank === "Finale.. wait, how'd this get here?") {
                        suffix = ` (Actual: ${formatNumber(value)})`;
                        displayValue = 1e10;
                    }
                    
                    addToTerminal(`Added to inventory: #${formatInteger(index)} ${variantText}${formatNumber(displayValue)} [${rank}]${suffix}`, true); 
                    
                    const rollElement = document.getElementById(`roll-${index}`);
                    if (rollElement) {
                        rollElement.style.opacity = '0.5';
                        rollElement.style.cursor = 'not-allowed';
                        rollElement.onclick = null;
                    }
                    
                    saveGame();
                }
            }
        }

        // --- MODIFIED: For Auto-Accept and Auto-Stop ---
        function toggleAutoRoll() {
            if (isCutscenePlaying) {
                addToTerminal('Cannot toggle auto-roll during a cutscene!', true);
                return;
            }
            
            const btn = document.getElementById('autoRollBtn');
            if (autoRollInterval) {
                clearInterval(autoRollInterval);
                autoRollInterval = null;
                btn.textContent = 'Auto Roll';
                btn.classList.remove('active');
                addToTerminal('Auto-rolling stopped.', true);
            } else {
                // Load Auto-Accept settings
                autoAcceptThreshold = parseFloat(document.getElementById('autoAcceptThreshold').value) || 0;
                autoAcceptTrueRNGValue = parseFloat(document.getElementById('autoAcceptTrueRNG').value) || 0;
                autoAcceptSecretThresholdValue = parseFloat(document.getElementById('autoAcceptSecretThreshold').value) || 0;
                autoAcceptOnNewRank = document.getElementById('autoAcceptNewRank').checked;
                
                // Load Auto-Stop settings
                autoStopThreshold = parseFloat(document.getElementById('autoStopThreshold').value) || 0;
                autoStopTrueRNGValue = parseFloat(document.getElementById('autoStopTrueRNG').value) || 0;
                autoStopSecretThresholdValue = parseFloat(document.getElementById('autoStopSecretThreshold').value) || 0;
                autoStopOnNewRank = document.getElementById('autoStopNewRank').checked;
                
                autoRollInterval = setInterval(roll, AUTO_ROLL_DELAY_MS);
                btn.textContent = 'Stop Auto Roll';
                btn.classList.add('active');
                
                let message = 'Auto-rolling started...';
                const acceptConditions = [];
                const stopConditions = [];
                
                if (autoAcceptThreshold > 0) acceptConditions.push(`value ‚â• ${autoAcceptThreshold}`);
                if (autoAcceptTrueRNGValue > 0) acceptConditions.push(`base ‚â• ${autoAcceptTrueRNGValue}`);
                if (autoAcceptSecretThresholdValue > 0) acceptConditions.push(`secret ‚â• ${autoAcceptSecretThresholdValue}`);
                if (autoAcceptOnNewRank) acceptConditions.push('new rank');
                
                if (autoStopThreshold > 0) stopConditions.push(`value ‚â• ${autoStopThreshold}`);
                if (autoStopTrueRNGValue > 0) stopConditions.push(`base ‚â• ${autoStopTrueRNGValue}`);
                if (autoStopSecretThresholdValue > 0) stopConditions.push(`secret ‚â• ${autoStopSecretThresholdValue}`);
                if (autoStopOnNewRank) stopConditions.push('new rank');
                
                if (acceptConditions.length > 0) {
                    message += ` (Auto-Accept: ${acceptConditions.join(', ')})`;
                }
                
                if (stopConditions.length > 0) {
                    message += ` (Auto-Stop: ${stopConditions.join(', ')})`;
                }
                
                addToTerminal(message, true);
            }
        }

        function buyUpgrade() {
            if (currency >= upgradeCost) {
                currency -= upgradeCost;
                totalUpgrades++;
                maxInventory += INVENTORY_PER_UPGRADE;
                
                updateCalculatedStats();
                
                addToTerminal(
                    `Upgrade purchased! Total upgrades: ${totalUpgrades} | Luck: +${currentLuck.toFixed(3)} | Secret Luck: ${secretLuckMultiplier.toFixed(2)}x | Inventory space: ${maxInventory} | Currency: ${currency.toFixed(2)}`,
                    true
                );
                
                upgradeCost *= UPGRADE_COST_MULTIPLIER;
                addToTerminal(`Next upgrade cost: ${upgradeCost.toFixed(2)}`);
                
                updateStats();
                saveGame();
            } else {
                addToTerminal(
                    `Not enough currency! You have ${currency.toFixed(2)} but need ${upgradeCost.toFixed(2)}`,
                    true
                );
            }
        }

        function buyBulkRoll() {
            if (hardcoreMode) {
                addToTerminal('Cannot buy bulk roll in hardcore mode!', true);
                return;
            }
            
            if (bulkRollLevel >= MAX_BULK_ROLL_LEVEL) {
                addToTerminal('Bulk Roll is already maxed out!', true);
                return;
            }
            
            if (currency >= bulkRollCost) {
                currency -= bulkRollCost;
                bulkRollLevel++;
                
                addToTerminal(
                    `Bulk Roll purchased! Level: ${bulkRollLevel} | Rolls per click: ${bulkRollLevel + 1} | Currency: ${currency.toFixed(2)}`,
                    true
                );
                
                if (bulkRollLevel < MAX_BULK_ROLL_LEVEL) {
                    bulkRollCost *= BULK_ROLL_COST_MULTIPLIER;
                    addToTerminal(`Next Bulk Roll cost: ${bulkRollCost.toFixed(2)}`);
                } else {
                    addToTerminal('Bulk Roll is now MAXED!');
                }
                
                updateStats();
                saveGame();
            } else {
                addToTerminal(
                    `Not enough currency! You have ${currency.toFixed(2)} but need ${bulkRollCost.toFixed(2)}`,
                    true
                );
            }
        }

        // MODIFIED: To handle new ranks
        function showRarest() {
            if (highestFinalRoll.value === 0 && highestFinalRoll.rank !== "CORRUPTED") {
                addToTerminal('No rolls yet!', true);
            } else {
                const { className, color } = getRankClassAndColor(highestFinalRoll.value, highestFinalRoll.variants, highestFinalRoll.rank);
                let rankClass = className;
                let rollColor = color;
                const displayName = highestFinalRoll.rank;
                let displayValue = highestFinalRoll.value;
                let suffix = "";

                if (displayName === "~Nonavacious~") {
                    rankClass += " secret-nonavacious";
                }
                
                if (displayName === "CORRUPTED") {
                    rankClass += " secret-corrupted";
                    rollColor = "#FFFFFF";
                }
                
                // Special display for rarest
                if (displayName === "‚õßSatanic‚õß") {
                    suffix = ` (Actual: ${formatNumber(highestFinalRoll.value)})`;
                    displayValue = -666.66;
                }
                if (displayName === "Finale.. wait, how'd this get here?") {
                    suffix = ` (Actual: ${formatNumber(highestFinalRoll.value)})`;
                    displayValue = 1e10;
                }

                let variantText = '';
                if (highestFinalRoll.variants && highestFinalRoll.variants.length > 0) {
                    variantText = highestFinalRoll.variants.map(v => `[${v.name}]`).join('') + ' ';
                }
                
                addToTerminal(
                    `Rarest roll: ${variantText}<span class="satanic-wrapper"><span class="${rankClass}" style="color: ${rollColor};">${formatNumber(displayValue)} [${displayName}]${suffix}</span></span>`,
                    true
                );
            }
        }

        function clearTerminal() {
            const terminal = document.getElementById('terminal');
            const welcomeMsg = terminal.querySelector('.welcome-message');
            terminal.innerHTML = '';
            if (welcomeMsg) {
                terminal.appendChild(welcomeMsg);
            }
        }

        // --- UPDATED: Import/Export Functions with base64url encoding ---
        function exportSave() {
            try {
                saveGame();
                const saveData = localStorage.getItem('calisRNGGame');
                if (!saveData) {
                    addToTerminal('No save data found!', true);
                    return;
                }
                
                // Compress the save data using base64url
                const compressedData = LZString.compressToBase64(saveData);
                document.getElementById('saveDataTextarea').value = compressedData;
                
                addToTerminal('Save data exported to text box. Copy it to save it.', true);
            } catch (e) {
                console.error('Error exporting save:', e);
                addToTerminal('Error exporting save data. Check console.', true, 'rank-1000000-100000000');
            }
        }
        
        function importSave() {
            if (!confirm("Are you sure you want to import this save? This will OVERWRITE your current progress and reload the page.")) {
                return;
            }
            
            try {
                const compressedData = document.getElementById('saveDataTextarea').value;
                if (!compressedData) {
                    addToTerminal('Paste save data into the text box first!', true);
                    return;
                }
                
                // Try to decompress with base64url first
                let decodedData;
                try {
                    decodedData = LZString.decompressFromBase64(compressedData);
                } catch (e) {
                    // If decompression fails, try as plain text
                    decodedData = compressedData;
                }
                
                if (!decodedData) {
                    addToTerminal('Invalid save data format!', true);
                    return;
                }
                
                // Validate JSON
                JSON.parse(decodedData);
                
                localStorage.setItem('calisRNGGame', decodedData);
                
                if (autoRollInterval) clearInterval(autoRollInterval);
                if (eventInterval) clearInterval(eventInterval);
                if (shapeInterval) clearInterval(shapeInterval);
                if (currentEvent && currentEvent.timeoutId) clearTimeout(currentEvent.timeoutId);
                for (const id in activeEuphoriaIntervals) {
                    clearInterval(activeEuphoriaIntervals[id]);
                }
                for (const id in activeBewildermentIntervals) {
                    clearInterval(activeBewildermentIntervals[id]);
                }
                
                addToTerminal('Import successful! Reloading game...', true, 'rank-1000000000-10000000000');
                
                setTimeout(() => {
                    location.reload();
                }, 1000);
                
            } catch (e) {
                console.error('Error importing save:', e);
                addToTerminal('Error importing save data. Data might be corrupt or invalid. Check console.', true, 'rank-1000000-100000000');
            }
        }

        // --- SHAPE SYSTEM FUNCTIONS ---
        function addToShapeTerminal(text) {
            const terminal = document.getElementById('shape-spawn-output');
            const line = document.createElement('div');
            line.className = 'shape-spawn-line';
            line.innerHTML = text; 
            
            if (terminal.children.length > 20) {
                terminal.removeChild(terminal.firstChild);
            }
            
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
        }

        function calculateGeometrixGain(shape) {
            let baseGain = 0;
            if (shape.name === "Circle") {
                const base = Math.pow(Math.random(), -1.5);
                baseGain = base * 250;
            } else {
                baseGain = shape.rarity / 2;
            }
            
            const gmxMultiplier = 1 + (gmxMultiLevel * 0.5);
            return baseGain * gmxMultiplier;
        }
        
        function despawnShape(shapeId, isCollected = false) {
            const shapeIndex = activeShapes.findIndex(s => s.id === shapeId);
            
            if (shapeIndex === -1) {
                return;
            }

            const shapeData = activeShapes[shapeIndex];
            
            if (shapeData.timerId) {
                clearTimeout(shapeData.timerId);
            }
            
            activeShapes.splice(shapeIndex, 1);
            
            const element = document.getElementById(`shape-${shapeId}`);
            if (element) {
                 if (isCollected) {
                    element.style.transform = 'scale(1.5)';
                    element.style.opacity = '0';
                    setTimeout(() => element.remove(), 200);
                 } else {
                    element.remove();
                 }
            }
            
            if (!isCollected) {
                addToShapeTerminal(`A **${shapeData.name}** despawned (not collected)!`);
            }
            
            saveGame();
        }

        function renderActiveShapes() {
            const shapesField = document.getElementById('shapes-field');
            shapesField.innerHTML = ''; 
            
            activeShapes = activeShapes.filter(shapeData => {
                const timeElapsed = Date.now() - shapeData.spawnTime;
                
                if (timeElapsed >= SHAPE_DESPAWN_TIME_MS) {
                    addToShapeTerminal(`A **${shapeData.name}** despawned while you were away!`);
                    return false;
                }

                const shapeElement = document.createElement('div');
                shapeElement.id = `shape-${shapeData.id}`;
                shapeElement.className = `clickable-shape shape-${shapeData.name.replace(/\s/g, '-')}`;
                shapeElement.style.backgroundColor = shapeData.color;
                shapeElement.style.left = `${shapeData.posX}px`;
                shapeElement.style.top = `${shapeData.posY}px`;
                shapeElement.textContent = shapeData.name[0];
                shapeElement.onclick = () => collectShape(shapeData.id);
                
                shapesField.appendChild(shapeElement);

                const remainingTime = SHAPE_DESPAWN_TIME_MS - timeElapsed;
                shapeData.timerId = setTimeout(() => {
                    despawnShape(shapeData.id, false); 
                }, remainingTime);

                return true;
            });
            
            saveGame();
        }

        function spawnShape() {
            if (!shapesUnlocked) return;
            
            let totalPossibleGain = 0;
            let spawnedCount = 0;
            const spawnCount = bulkShapeLevel + 1; 

            const shapesField = document.getElementById('shapes-field');
            const fieldWidth = shapesField.clientWidth;
            const fieldHeight = shapesField.clientHeight;

            for (let j = 0; j < spawnCount; j++) {
                const cumulativeChances = [];
                let cumulativeSum = 0;

                for (const shape of SHAPES) {
                    const adjustedChance = shape.chance * (1 + shapeLuckBonus);
                    cumulativeSum += adjustedChance;
                    cumulativeChances.push({ maxChance: cumulativeSum, shape: shape });
                }
                
                let rand = Math.random() * cumulativeSum; 
                let selectedShape = null;

                for (const item of cumulativeChances) {
                    if (rand < item.maxChance) { 
                        selectedShape = item.shape;
                        break;
                    }
                }
                
                if (!selectedShape) {
                    selectedShape = SHAPES[0]; 
                }

                const gain = calculateGeometrixGain(selectedShape);
                totalPossibleGain += gain;
                spawnedCount++;
                
                const shapeId = Date.now().toString() + Math.random().toString(36).substring(2, 9);
                const shapeSize = 30;
                const posX = Math.random() * (fieldWidth - shapeSize); 
                const posY = Math.random() * (fieldHeight - shapeSize); 

                const shapeElement = document.createElement('div');
                shapeElement.id = `shape-${shapeId}`;
                shapeElement.className = `clickable-shape shape-${selectedShape.name.replace(/\s/g, '-')}`;
                shapeElement.style.backgroundColor = selectedShape.color;
                shapeElement.style.left = `${posX}px`;
                shapeElement.style.top = `${posY}px`;
                shapeElement.textContent = selectedShape.name[0];

                const shapeData = {
                    id: shapeId,
                    name: selectedShape.name,
                    gain: gain,
                    color: selectedShape.color,
                    posX: posX,
                    posY: posY,
                    spawnTime: Date.now(),
                    timerId: null
                };
                
                shapeData.timerId = setTimeout(() => {
                    despawnShape(shapeId, false);
                }, SHAPE_DESPAWN_TIME_MS);

                activeShapes.push(shapeData);
                
                shapeElement.onclick = () => collectShape(shapeData.id);
                
                shapesField.appendChild(shapeElement);
            }
            
            if (spawnedCount > 0) {
                addToShapeTerminal(`Spawned ${spawnedCount} shapes. Max collection: ${formatGeometrix(totalPossibleGain)} GMX.`);
            }
        }
        
        function collectShape(shapeId) {
            const shapeIndex = activeShapes.findIndex(s => s.id === shapeId);
            
            if (shapeIndex === -1) {
                return; 
            }

            const shapeData = activeShapes[shapeIndex];
            geometrix += shapeData.gain;
            
            addToTerminal(`Collected **${shapeData.name}** (+${formatGeometrix(shapeData.gain)} GMX)!`, true, 'command');

            despawnShape(shapeId, true); 
            
            updateStats();
        }

        function startShapeInterval() {
            if (shapeInterval) clearInterval(shapeInterval);
            if (!shapesUnlocked) return;
            
            shapeInterval = setInterval(spawnShape, currentShapeCooldown);
            
            addToTerminal(`Shape spawning interval set to ${formatCooldown(currentShapeCooldown)}s.`, true, '#00FF00');
        }

        function unlockShapes() {
            if (hardcoreMode) {
                addToTerminal('Cannot unlock shapes in hardcore mode!', true);
                return;
            }
            
            if (currency >= UNLOCK_SHAPES_COST) {
                currency -= UNLOCK_SHAPES_COST;
                shapesUnlocked = true;
                addToTerminal(`**Shapes GUI unlocked!** Start collecting the clickable polygons.`, true, '#00FF00');
                updateCalculatedStats();
                startShapeInterval();
                updateStats();
                saveGame();
            } else {
                addToTerminal(`Not enough currency! Need ${formatNumber(UNLOCK_SHAPES_COST)} to unlock.`, true);
            }
        }

        // Upgrade 1
        function buyShapeLuckUpgrade() {
            if (hardcoreMode) {
                addToTerminal('Cannot buy upgrades in hardcore mode!', true);
                return;
            }
            
            if (shapeLuckLevel >= MAX_SHAPE_LUCK_LEVEL) {
                addToTerminal('Shape Luck is maxed out!', true, '#FF00FF');
                return;
            }
            if (geometrix >= shapeLuckCost) {
                geometrix -= shapeLuckCost;
                shapeLuckLevel++;
                
                addToTerminal(
                    `Shape Luck purchased! Level: ${shapeLuckLevel}/${MAX_SHAPE_LUCK_LEVEL}`,
                    true, '#00FF00'
                );
                
                shapeLuckCost *= SHAPE_LUCK_COST_MULTIPLIER;
                updateCalculatedStats();
                updateStats();
                saveGame();
            } else {
                addToTerminal(`Not enough Geometrix! Need ${formatGeometrix(shapeLuckCost)} GMX.`, true);
            }
        }
        
        // Upgrade 2
        function buyLuckMultiUpgrade() {
            if (hardcoreMode) {
                addToTerminal('Cannot buy upgrades in hardcore mode!', true);
                return;
            }
            
            if (geometrix >= luckMultiCost) {
                geometrix -= luckMultiCost;
                luckMultiLevel++;
                
                updateCalculatedStats();

                addToTerminal(
                    `Luck Multiplier purchased! Level: ${luckMultiLevel} | New Multi: x${luckMultiValue.toFixed(2)}`,
                    true, '#00FF00'
                );
                
                luckMultiCost *= LUCK_MULTI_COST_MULTIPLIER;
                updateStats();
                saveGame();
            } else {
                addToTerminal(`Not enough Geometrix! Need ${formatGeometrix(luckMultiCost)} GMX.`, true);
            }
        }

        // Upgrade 3
        function buyBulkShapeUpgrade() {
            if (hardcoreMode) {
                addToTerminal('Cannot buy upgrades in hardcore mode!', true);
                return;
            }
            
            if (bulkShapeLevel >= MAX_BULK_SHAPE_LEVEL) {
                addToTerminal('Bulk/Cooldown is maxed out!', true, '#FF00FF');
                return;
            }
            if (geometrix >= bulkShapeCost) {
                geometrix -= bulkShapeCost;
                bulkShapeLevel++;
                
                updateCalculatedStats();
                
                addToTerminal(
                    `Bulk/Cooldown purchased! Level: ${bulkShapeLevel}/${MAX_BULK_SHAPE_LEVEL} | Spawns: ${bulkShapeLevel + 1} | Cooldown: ${formatCooldown(currentShapeCooldown)}s`,
                    true, '#00FF00'
                );
                
                if (bulkShapeLevel < MAX_BULK_SHAPE_LEVEL) {
                    bulkShapeCost *= BULK_SHAPE_COST_MULTIPLIER;
                }
                
                startShapeInterval();
                updateStats();
                saveGame();
            } else {
                addToTerminal(`Not enough Geometrix! Need ${formatGeometrix(bulkShapeCost)} GMX.`, true);
            }
        }

        // --- CLICKER SYSTEM FUNCTIONS ---
        function unlockClicker() {
            if (hardcoreMode) {
                addToTerminal('Cannot unlock clicker in hardcore mode!', true);
                return;
            }
            
            if (clickerUnlocked) {
                addToTerminal('Clicker is already unlocked!', true);
                return;
            }
            if (geometrix >= UNLOCK_CLICKER_COST) {
                geometrix -= UNLOCK_CLICKER_COST;
                clickerUnlocked = true;
                addToTerminal(`**Clicker GUI unlocked!** Click the clover!`, true, '#FFD700');
                updateStats();
                saveGame();
            } else {
                addToTerminal(`Not enough Geometrix! Need ${formatGeometrix(UNLOCK_CLICKER_COST)} GMX.`, true);
            }
        }
        
        function clickClover() {
            const baseGain = Math.pow(Math.random(), -1.5);
            const finalGain = baseGain * (1 + fortuniumLuck);
            fortunium += finalGain;
            
            updateStats();
        }
        
        function buyFortuniumUpgrade(type) {
            if (!clickerUnlocked) return;
            
            if (hardcoreMode) {
                addToTerminal('Cannot buy upgrades in hardcore mode!', true);
                return;
            }
            
            if (type === 'gmx') {
                if (fortunium >= gmxMultiCost) {
                    fortunium -= gmxMultiCost;
                    gmxMultiLevel++;
                    gmxMultiCost *= 1.5;
                    addToTerminal(`GMX Multi upgrade purchased! GMX gain is now +${(gmxMultiLevel * 0.5).toFixed(1)}x`, true, '#FFD700');
                    updateStats();
                    saveGame();
                } else {
                    addToTerminal(`Not enough Fortunium! Need ${formatNumber(gmxMultiCost)} FOR.`, true);
                    return;
                }
            } 
            else if (type === 'fortuniumLuck') {
                if (fortunium >= fortuniumLuckCost) {
                    fortunium -= fortuniumLuckCost;
                    fortuniumLuckLevel++;
                    fortuniumLuck += 0.5;
                    fortuniumLuckCost *= 1.25;
                    addToTerminal(`Fortunium Luck upgrade purchased! Fortunium Luck is now +${fortuniumLuck.toFixed(1)}x`, true, '#FFD700');
                    updateStats();
                    saveGame();
                } else {
                    addToTerminal(`Not enough Fortunium! Need ${formatNumber(fortuniumLuckCost)} FOR.`, true);
                    return;
                }
            }
            else if (type === 'luck') {
                if (clickerLuckLevel >= MAX_CLICKER_LUCK_LEVEL) {
                    addToTerminal('Clicker Luck upgrade is MAXED!', true, '#FF00FF');
                    return;
                }
                if (fortunium >= clickerLuckCost) {
                    fortunium -= clickerLuckCost;
                    clickerLuckLevel++;
                    clickerLuckCost *= 50;
                    addToTerminal(`Clicker Luck upgrade purchased! Level ${clickerLuckLevel}/${MAX_CLICKER_LUCK_LEVEL}.`, true, '#FFD700');
                    updateCalculatedStats();
                    updateStats();
                    saveGame();
                } else {
                    addToTerminal(`Not enough Fortunium! Need ${formatNumber(clickerLuckCost)} FOR.`, true);
                    return;
                }
            }
        }

        // --- NEW: EUPHORIA Animation Function ---
        function initEuphoriaAnimation(elementId, baseText) {
            const element = document.getElementById(elementId);
            if (!element) return;
            
            if (activeEuphoriaIntervals[elementId]) {
                clearInterval(activeEuphoriaIntervals[elementId]);
            }
            
            const originalHtml = element.innerHTML;
            const textChars = baseText.split('');
            
            const intervalId = setInterval(() => {
                const currentElement = document.getElementById(elementId);
                if (!currentElement) {
                    clearInterval(activeEuphoriaIntervals[elementId]);
                    delete activeEuphoriaIntervals[elementId];
                    return;
                }
                
                const textIndex = currentElement.innerHTML.indexOf(baseText);
                if (textIndex === -1) {
                    currentElement.innerHTML = originalHtml;
                    return;
                }
                
                const prefix = currentElement.innerHTML.substring(0, textIndex);
                const suffix = currentElement.innerHTML.substring(textIndex + baseText.length);

                const newChars = [...textChars];
                
                let idx1 = Math.floor(Math.random() * newChars.length);
                let idx2 = Math.floor(Math.random() * newChars.length);
                while (idx1 === idx2) {
                    idx2 = Math.floor(Math.random() * newChars.length);
                }

                const sym1 = EUPHORIA_SYMBOLS[Math.floor(Math.random() * EUPHORIA_SYMBOLS.length)];
                const sym2 = EUPHORIA_SYMBOLS[Math.floor(Math.random() * EUPHORIA_SYMBOLS.length)];
                newChars[idx1] = `<span style="opacity: 0.7; display: inline-block; transform: scale(1.1);">${sym1}</span>`;
                newChars[idx2] = `<span style="opacity: 0.7; display: inline-block; transform: scale(1.1);">${sym2}</span>`;
                
                currentElement.innerHTML = prefix + newChars.join('') + suffix;

                setTimeout(() => {
                    const stillExists = document.getElementById(elementId);
                    if (stillExists && activeEuphoriaIntervals[elementId]) {
                        stillExists.innerHTML = originalHtml;
                    }
                }, 25);

            }, 100);
            
            activeEuphoriaIntervals[elementId] = intervalId;
            activeAnimationElements.add(elementId);
        }

        // --- NEW: UI Customization Functions ---
        function applyUICustomization() {
            const bgColor = document.getElementById('ui-bg-color').value;
            const buttonBg = document.getElementById('ui-button-bg').value;
            const buttonOutline = document.getElementById('ui-button-outline').value;
            const hcColor = document.getElementById('ui-hc-color').value;
            const textColor = document.getElementById('ui-text-color').value;
            
            // Apply to body
            document.body.style.backgroundColor = bgColor;
            document.body.style.color = textColor;
            
            // Apply to buttons (excluding special buttons)
            const buttons = document.querySelectorAll('button:not([style*="background-color"])');
            buttons.forEach(btn => {
                btn.style.backgroundColor = buttonBg;
                btn.style.borderColor = buttonOutline;
                btn.style.color = textColor;
            });
            
            // Apply to hardcore mode elements
            const hcElements = document.querySelectorAll('.hardcore-mode-active, .hardcore-rank');
            hcElements.forEach(el => {
                el.style.borderColor = hcColor;
            });
            
            // Save UI settings
            const uiSettings = {
                bg: bgColor,
                buttonBg: buttonBg,
                buttonOutline: buttonOutline,
                hcColor: hcColor,
                textColor: textColor
            };
            localStorage.setItem('calisRNG_UI', JSON.stringify(uiSettings));
            
            addToTerminal('UI customization applied!', true);
        }

        function resetUICustomization() {
            // Reset to defaults
            document.getElementById('ui-bg-color').value = '#4a148c';
            document.getElementById('ui-button-bg').value = '#808080';
            document.getElementById('ui-button-outline').value = '#ff69b4';
            document.getElementById('ui-hc-color').value = '#ff0000';
            document.getElementById('ui-text-color').value = '#ffffff';
            
            // Apply defaults
            applyUICustomization();
            
            addToTerminal('UI reset to defaults!', true);
        }

        function loadUICustomization() {
            const saved = localStorage.getItem('calisRNG_UI');
            if (saved) {
                try {
                    const uiSettings = JSON.parse(saved);
                    document.getElementById('ui-bg-color').value = uiSettings.bg;
                    document.getElementById('ui-button-bg').value = uiSettings.buttonBg;
                    document.getElementById('ui-button-outline').value = uiSettings.buttonOutline;
                    document.getElementById('ui-hc-color').value = uiSettings.hcColor;
                    document.getElementById('ui-text-color').value = uiSettings.textColor;
                    
                    // Apply immediately
                    setTimeout(() => applyUICustomization(), 100);
                } catch(e) {
                    console.error('Error loading UI settings:', e);
                }
            }
        }

        // --- NEW: Refresh all UI function ---
        function refreshAllUI() {
            updateStats();
            updateInventoryDisplay();
            updateIndexDisplay();
            updatePendingDisplay();
            
            // Force re-render of shapes and clicker
            if (shapesUnlocked) {
                const shapesGui = document.getElementById('shapes-gui');
                if (shapesGui) {
                    shapesGui.style.display = 'block';
                    shapesGui.offsetHeight;
                }
                renderActiveShapes();
            }
            
            if (clickerUnlocked) {
                const clickerGui = document.getElementById('clicker-gui');
                if (clickerGui) {
                    clickerGui.style.display = 'block';
                    clickerGui.offsetHeight;
                }
            }
            
            preserveAnimations();
        }

        // --- EVENT FUNCTIONS ---
        function startEvent(event) {
            if (hardcoreMode) return; // Events disabled in hardcore mode
            
            if (currentEvent) {
                clearTimeout(currentEvent.timeoutId);
                endEvent(currentEvent);
            }
            
            currentEvent = { 
                name: event.name, 
                duration: event.duration, 
                description: event.description, 
                targets: event.targets, 
                multiplier: event.multiplier, 
                eventChanceBoost: event.eventChanceBoost 
            };
            eventEndTime = Date.now() + event.duration;

            addToTerminal(`üö® EVENT STARTED: **${event.name}**! ${event.description} for ${event.duration / 1000} seconds!`, true, 'rank-1000-10000'); 

            if (event.name === "Lol") {
                eventCheckChance = event.eventChanceBoost; 
            } else {
                eventCheckChance = 1;
            }

            currentEvent.timeoutId = setTimeout(() => {
                endEvent(event);
            }, event.duration);

            updateStats();
        }

        function endEvent(event) {
            addToTerminal(`‚úÖ EVENT ENDED: **${event.name}** is over.`, true);

            if (event.name === "Lol") {
                eventCheckChance = 1;
            }

            if (currentEvent && currentEvent.name === event.name) {
                currentEvent = null;
                eventEndTime = 0;
            }

            updateStats();
        }
        
        function resumeEvent(event, remainingDuration) {
            if (hardcoreMode) return; // Events disabled in hardcore mode
            
            currentEvent = event;
            if (event.name === "Lol") {
                eventCheckChance = event.eventChanceBoost; 
            } else {
                eventCheckChance = 1;
            }
            
            currentEvent.timeoutId = setTimeout(() => {
                endEvent(event);
            }, remainingDuration);
            
            addToTerminal(`Resuming active event: **${event.name}** (${(remainingDuration / 1000).toFixed(1)}s left).`, true, 'rank-1000-10000');
        }

        function checkEvent() {
            if (hardcoreMode || currentEvent) return; 

            for (const event of EVENTS) {
                const adjustedChance = event.chance / eventCheckChance;

                if (Math.random() < adjustedChance) {
                    startEvent(event);
                    return; 
                }
            }
        }

        function startEventLoop() {
            if (eventInterval) clearInterval(eventInterval);
            eventInterval = setInterval(checkEvent, EVENT_CHECK_INTERVAL_MS);
        }

        // --- MODIFIED: saveGame to include new data ---
        function saveGame() {
            const gameState = {
                currency,
                totalUpgrades,
                upgradeCost,
                highestBaseRoll, 
                highestFinalRoll: highestFinalRoll || { 
                    value: 0, 
                    baseValue: 0, 
                    rank: 'None yet', 
                    variants: [], 
                    isSecret: false 
                },
                maxInventory,
                inventory,
                rollIndex,
                acceptedRolls: Array.from(acceptedRolls),
                discoveredRanks: Array.from(discoveredRanks),
                bulkRollLevel,
                bulkRollCost,
                
                // NEW: Pending rolls
                pendingRolls,
                maxPendingRolls,
                
                // NEW: Secrets toggle
                secretsEnabled,

                // NEW: Hardcore mode
                hardcoreMode,
                originalBulkRollLevel,
                originalLuck,
                originalVariantChance,
                originalSecretLuck,

                // NEW: Scientific notation settings
                sciNotationThreshold,
                sciNotationEnabled,

                // Cutscene State
                cutscenesEnabled,

                // Event State
                currentEvent: currentEvent ? { name: currentEvent.name, duration: currentEvent.duration, description: currentEvent.description, targets: currentEvent.targets, multiplier: currentEvent.multiplier, eventChanceBoost: currentEvent.eventChanceBoost } : null,
                eventEndTime,
                eventCheckChance,

                // Auto-Accept and Auto-Stop Settings
                autoAcceptThreshold,
                autoAcceptTrueRNGValue,
                autoAcceptSecretThresholdValue,
                autoAcceptOnNewRank,
                autoStopThreshold,
                autoStopTrueRNGValue,
                autoStopSecretThresholdValue,
                autoStopOnNewRank,

                // Shapes Save Data
                geometrix,
                shapesUnlocked,
                shapeLuckLevel,
                shapeLuckCost,
                luckMultiLevel,
                luckMultiCost,
                bulkShapeLevel,
                bulkShapeCost,
                activeShapes: activeShapes.map(shape => ({
                    id: shape.id,
                    name: shape.name,
                    gain: shape.gain,
                    color: shape.color,
                    posX: shape.posX,
                    posY: shape.posY,
                    spawnTime: shape.spawnTime
                })),
                
                // Clicker Save Data
                clickerUnlocked,
                fortunium,
                fortuniumLuck,
                gmxMultiLevel,
                gmxMultiCost,
                fortuniumLuckLevel,
                fortuniumLuckCost,
                clickerLuckLevel,
                clickerLuckCost
            };
            localStorage.setItem('calisRNGGame', JSON.stringify(gameState));
            
            // Refresh UI after save
            setTimeout(refreshAllUI, 50);
        }

        // --- MODIFIED: loadGame to include new data ---
        function loadGame() {
            const saved = localStorage.getItem('calisRNGGame');
            if (saved) {
                try {
                    const gameState = JSON.parse(saved);
                    currency = gameState.currency || 0;
                    totalUpgrades = gameState.totalUpgrades || 0;
                    upgradeCost = gameState.upgradeCost || 50;
                    
                    if (gameState.highestFinalRoll) {
                        highestFinalRoll = gameState.highestFinalRoll;
                        if (typeof highestFinalRoll.isSecret === 'undefined') {
                             highestFinalRoll.isSecret = SECRET_RANKS_CHANCES.map(r => r.name).includes(highestFinalRoll.rank) || highestFinalRoll.rank === "morts luck" || highestFinalRoll.rank === "Unobtainable";
                        }
                    } else {
                        const baseRoll = gameState.highestRoll || 0;
                        const rankInfo = getRankInfo(baseRoll);
                         highestFinalRoll = {
                            value: baseRoll,
                            baseValue: baseRoll,
                            rank: rankInfo.name,
                            variants: [],
                            isSecret: false
                        };
                    }
                    
                    highestBaseRoll = gameState.highestBaseRoll || (highestFinalRoll ? highestFinalRoll.baseValue : 0);
                    maxInventory = gameState.maxInventory || 10;
                    
                    inventory = (gameState.inventory || []).map(item => {
                        if (item.variant && !item.variants) {
                            item.variants = [item.variant];
                            delete item.variant;
                        } else if (!item.variants) {
                            item.variants = [];
                        }
                         if (typeof item.isSecret === 'undefined') {
                            item.isSecret = SECRET_RANKS_CHANCES.map(r => r.name).includes(item.rank.replace(" [HC]", "")) || item.rank === "morts luck" || item.rank === "breaktime" || item.rank.includes("Unobtainable");
                        }
                        return item;
                    });

                    rollIndex = gameState.rollIndex || 1;
                    acceptedRolls = new Set(gameState.acceptedRolls || []);
                    discoveredRanks = new Set(gameState.discoveredRanks || []);
                    bulkRollLevel = gameState.bulkRollLevel || 0;
                    bulkRollCost = gameState.bulkRollCost || 500000;
                    
                    // NEW: Load pending rolls
                    pendingRolls = gameState.pendingRolls || [];
                    maxPendingRolls = gameState.maxPendingRolls || maxInventory * 3;
                    
                    // NEW: Load secrets enabled
                    secretsEnabled = typeof gameState.secretsEnabled !== 'undefined' ? gameState.secretsEnabled : true;
                    
                    // NEW: Load hardcore mode
                    hardcoreMode = gameState.hardcoreMode || false;
                    originalBulkRollLevel = gameState.originalBulkRollLevel || 0;
                    originalLuck = gameState.originalLuck || 0;
                    originalVariantChance = gameState.originalVariantChance || 1;
                    originalSecretLuck = gameState.originalSecretLuck || 1;
                    
                    // NEW: Load scientific notation settings
                    sciNotationThreshold = gameState.sciNotationThreshold || DEFAULT_SCI_THRESHOLD;
                    sciNotationEnabled = typeof gameState.sciNotationEnabled !== 'undefined' ? gameState.sciNotationEnabled : true;
                    
                    // Load Cutscene State
                    cutscenesEnabled = typeof gameState.cutscenesEnabled === 'boolean' ? gameState.cutscenesEnabled : true;

                    // Load Event State
                    currentEvent = gameState.currentEvent || null;
                    eventEndTime = gameState.eventEndTime || 0;
                    eventCheckChance = gameState.eventCheckChance || 1;

                    // Load Auto-Accept and Auto-Stop Settings
                    autoAcceptThreshold = gameState.autoAcceptThreshold || 0;
                    autoAcceptTrueRNGValue = gameState.autoAcceptTrueRNGValue || 0;
                    autoAcceptSecretThresholdValue = gameState.autoAcceptSecretThresholdValue || 0;
                    autoAcceptOnNewRank = gameState.autoAcceptOnNewRank || false;
                    
                    autoStopThreshold = gameState.autoStopThreshold || 0;
                    autoStopTrueRNGValue = gameState.autoStopTrueRNGValue || 0;
                    autoStopSecretThresholdValue = gameState.autoStopSecretThresholdValue || 0;
                    autoStopOnNewRank = gameState.autoStopOnNewRank || false;

                    // Load Shapes Data
                    geometrix = gameState.geometrix || 0;
                    shapesUnlocked = gameState.shapesUnlocked || false;
                    shapeLuckLevel = gameState.shapeLuckLevel || 0;
                    shapeLuckCost = gameState.shapeLuckCost || 5;
                    luckMultiLevel = gameState.luckMultiLevel || 0;
                    luckMultiCost = gameState.luckMultiCost || 100;
                    bulkShapeLevel = gameState.bulkShapeLevel || 0;
                    bulkShapeCost = gameState.bulkShapeCost || 50;
                    
                    // Load Active Shapes
                    activeShapes = gameState.activeShapes || [];

                    // Load Clicker Data
                    clickerUnlocked = gameState.clickerUnlocked || false;
                    fortunium = gameState.fortunium || 0;
                    fortuniumLuck = gameState.fortuniumLuck || 0;
                    gmxMultiLevel = gameState.gmxMultiLevel || 0;
                    gmxMultiCost = gameState.gmxMultiCost || 75;
                    fortuniumLuckLevel = gameState.fortuniumLuckLevel || 0;
                    fortuniumLuckCost = gameState.fortuniumLuckCost || 125;
                    clickerLuckLevel = gameState.clickerLuckLevel || 0;
                    clickerLuckCost = gameState.clickerLuckCost || 1000;

                    // Call the calculation function
                    updateCalculatedStats();
                    
                    // Apply hardcore mode if needed
                    if (hardcoreMode) {
                        // Apply hardcore values (default x1, +0)
                        bulkRollLevel = 0;
                        currentLuck = 0;
                        variantChanceMultiplier = 1;
                        secretLuckMultiplier = 1;
                        luckMultiValue = 1;
                        
                        // Update UI
                        document.getElementById('hardcoreToggleBtn').textContent = 'Hardcore Mode: ON';
                        document.getElementById('hardcoreToggleBtn').classList.add('active');
                        document.getElementById('hardcoreStatus').textContent = 'ON';
                        document.getElementById('hardcore-warning').style.display = 'block';
                        document.body.classList.add('hardcore-mode-active');
                    }
                    
                    // Set scientific notation UI
                    document.getElementById('sciNotationThreshold').value = sciNotationThreshold;
                    document.getElementById('sciNotationStatus').textContent = sciNotationEnabled ? 'ON' : 'OFF';
                    document.getElementById('sciNotationStatus').style.color = sciNotationEnabled ? '#00ff00' : '#ff0000';
                    
                    // Set input values for Auto-Accept and Auto-Stop
                    document.getElementById('autoAcceptThreshold').value = autoAcceptThreshold;
                    document.getElementById('autoAcceptTrueRNG').value = autoAcceptTrueRNGValue;
                    document.getElementById('autoAcceptSecretThreshold').value = autoAcceptSecretThresholdValue;
                    document.getElementById('autoAcceptNewRank').checked = autoAcceptOnNewRank;
                    
                    document.getElementById('autoStopThreshold').value = autoStopThreshold;
                    document.getElementById('autoStopTrueRNG').value = autoStopTrueRNGValue;
                    document.getElementById('autoStopSecretThreshold').value = autoStopSecretThresholdValue;
                    document.getElementById('autoStopNewRank').checked = autoStopOnNewRank;
                    
                    // Refresh all UI
                    refreshAllUI();
                    
                    // Start the shape spawner if it was unlocked
                    if (shapesUnlocked) {
                        renderActiveShapes();
                        startShapeInterval();
                    }
                    
                    // Check and resume active event
                    if (currentEvent && eventEndTime > Date.now() && !hardcoreMode) {
                        const durationRemaining = eventEndTime - Date.now();
                        resumeEvent(currentEvent, durationRemaining);
                    } else if (currentEvent && eventEndTime <= Date.now()) {
                        endEvent({ name: currentEvent.name, eventChanceBoost: currentEvent.eventChanceBoost });
                    }
                    
                    addToTerminal('Game loaded!', true);
                } catch (e) {
                    console.error('Error loading game:', e);
                    updateCalculatedStats();
                    refreshAllUI();
                }
            } else {
                 // First time load
                updateCalculatedStats();
                refreshAllUI();
            }
        }

        // Initialize the game
        document.addEventListener('keydown', function(e) {
            if (e.key === 'r' && e.target.tagName !== 'INPUT') {
                e.preventDefault();
                roll();
            }
        });
        
        // Add listeners for auto-accept settings
        document.getElementById('autoAcceptThreshold').addEventListener('change', (e) => {
            autoAcceptThreshold = parseFloat(e.target.value) || 0;
        });
        document.getElementById('autoAcceptSecretThreshold').addEventListener('change', (e) => {
            autoAcceptSecretThresholdValue = parseFloat(e.target.value) || 0;
        });
        document.getElementById('autoAcceptNewRank').addEventListener('change', (e) => {
            autoAcceptOnNewRank = e.target.checked;
        });
        document.getElementById('autoAcceptTrueRNG').addEventListener('change', (e) => {
            autoAcceptTrueRNGValue = parseFloat(e.target.value) || 0;
        });
        
        // Add listeners for auto-stop settings
        document.getElementById('autoStopThreshold').addEventListener('change', (e) => {
            autoStopThreshold = parseFloat(e.target.value) || 0;
        });
        document.getElementById('autoStopSecretThreshold').addEventListener('change', (e) => {
            autoStopSecretThresholdValue = parseFloat(e.target.value) || 0;
        });
        document.getElementById('autoStopNewRank').addEventListener('change', (e) => {
            autoStopOnNewRank = e.target.checked;
        });
        document.getElementById('autoStopTrueRNG').addEventListener('change', (e) => {
            autoStopTrueRNGValue = parseFloat(e.target.value) || 0;
        });

        // Add listener for clover click
        document.getElementById('clover-clicker').addEventListener('click', () => {
            if (!clickerUnlocked) return;
            clickClover();
            
            const clover = document.getElementById('clover-clicker');
            clover.style.transform = 'scale(0.9)';
            setTimeout(() => {
                clover.style.transform = 'scale(1)';
            }, 100);
        });

        // Add listener for scientific notation threshold
        document.getElementById('sciNotationThreshold').addEventListener('change', (e) => {
            const value = parseFloat(e.target.value);
            if (!isNaN(value) && value > 0) {
                sciNotationThreshold = value;
                addToTerminal(`Scientific notation threshold set to ${formatNumber(value)}`, true);
                updateStats();
                preserveAnimations();
                saveGame();
            }
        });

        // --- UPDATED: LZString compression library for base64url encoding ---
        const LZString = {
            compressToBase64: function(input) {
                try {
                    if (!input) return '';
                    // Convert to base64url (URL-safe base64)
                    const base64 = btoa(unescape(encodeURIComponent(input)));
                    return base64
                        .replace(/\+/g, '-')
                        .replace(/\//g, '_')
                        .replace(/=+$/g, '');
                } catch (e) {
                    console.error('Compression error:', e);
                    return '';
                }
            },
            decompressFromBase64: function(input) {
                try {
                    if (!input) return '';
                    // Convert from base64url to regular base64
                    let base64 = input
                        .replace(/-/g, '+')
                        .replace(/_/g, '/');
                    // Add padding if needed
                    while (base64.length % 4) {
                        base64 += '=';
                    }
                    return decodeURIComponent(escape(atob(base64)));
                } catch (e) {
                    console.error('Decompression error:', e);
                    return '';
                }
            }
        };

        const welcomeLine = document.createElement('div');
        welcomeLine.className = 'output-line welcome-message';
        welcomeLine.textContent = 'Welcome to calis RNG game!';
        document.getElementById('terminal').appendChild(welcomeLine);
        addToTerminal('Click rolls to add them to your inventory!');
        
        // Initial load
        loadGame();
        loadUICustomization();
        refreshAllUI();
        startEventLoop();
        
        // Force initial UI refresh
        setTimeout(refreshAllUI, 500);
    </script>
    
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(error => {
                        console.log('ServiceWorker registration failed: ', error);
                    });
            });
        }
    </script>
</body>
</html>
