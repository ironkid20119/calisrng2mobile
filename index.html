<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>calis RNG game</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
    
    <meta name="theme-color" content="#2d0051">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icons/icon-192x192.png">
    <style>
        body {
            font-family: 'Courier New', monospace;
            background-color: #4a148c;
            color: #ffffff;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            color: #ffffff;
        }
        .main-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto;
            gap: 20px;
        }
        
        .main-container > div:first-child {
            grid-column: 1;
            grid-row: 1;
        }
        
        .main-container > div:nth-child(2) {
            grid-column: 2;
            grid-row: 1;
        }
        
        .main-container > div:last-child {
            grid-column: 1 / span 2;
            grid-row: 2;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        #terminal {
            background-color: #2d0051;
            border: 2px solid #ff69b4;
            border-radius: 5px;
            padding: 20px;
            min-height: 400px;
            max-height: 500px;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        .output-line {
            margin: 5px 0;
        }
        .command {
            color: #ff69b4;
        }
        .welcome-message {
            color: #ff69b4;
            font-weight: bold;
        }
        .stats {
            background-color: #2d0051;
            border: 2px solid #ff69b4;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .stat-item {
            margin: 8px 0;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            background-color: #808080;
            color: #ffffff;
            border: 2px solid #ff69b4;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
        }
        button:hover {
            background-color: #a0a0a0;
        }
        button:active {
            transform: scale(0.95);
        }
        button:disabled {
            background-color: #555;
            border-color: #888;
            color: #aaa;
            cursor: not-allowed;
        }
        button.active {
            background-color: #ff69b4;
            color: #000;
        }
        #inventory, #index, #pending-rolls {
            background-color: #2d0051;
            border: 2px solid #ff69b4;
            border-radius: 5px;
            padding: 20px;
            min-height: 400px;
            max-height: 500px;
            overflow-y: auto;
        }
        .inventory-item {
            background-color: #4a148c;
            border: 1px solid #ff69b4;
            padding: 10px;
            margin: 5px 0;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .inventory-item:hover {
            background-color: #5a1a9c;
            transform: translateX(5px);
        }
        .section-header {
            font-size: 18px;
            margin-bottom: 10px;
            color: #ff69b4;
            font-weight: bold;
        }
        .clickable-roll {
            cursor: pointer;
            display: inline-block;
            transition: all 0.2s;
        }
        .clickable-roll:hover {
            transform: scale(1.05);
            text-shadow: 0 0 10px currentColor;
        }
        .index-item {
            background-color: #4a148c;
            border: 1px solid #ff69b4;
            padding: 8px;
            margin: 5px 0;
            border-radius: 3px;
        }
        .index-item.discovered {
            border-color: #00ff00;
        }
        .index-item.locked {
            opacity: 0.5;
            border-color: #666;
        }
        
        .autoroll-settings {
            background-color: #2d0051;
            border: 2px solid #ff69b4;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .autoroll-setting-item {
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .autoroll-setting-item label {
            flex-shrink: 0;
        }
        
        .autoroll-setting-item input[type="number"] {
            background-color: #4a148c;
            color: #ffffff;
            border: 1px solid #ff69b4;
            padding: 5px 10px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            width: 150px;
        }
        
        .autoroll-setting-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        /* Scientific Notation Settings */
        .scientific-setting {
            background-color: #2d0051;
            border: 2px solid #00ffff;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .scientific-setting-item {
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .scientific-setting-item label {
            flex-shrink: 0;
            min-width: 250px;
        }
        
        .scientific-setting-item input[type="number"] {
            background-color: #4a148c;
            color: #ffffff;
            border: 1px solid #00ffff;
            padding: 5px 10px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            width: 200px;
        }
        
        /* UI Customization */
        .ui-customization {
            background-color: #2d0051;
            border: 2px solid #FFA500;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .ui-customization-item {
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .ui-customization-item label {
            flex-shrink: 0;
            min-width: 150px;
            color: #FFA500;
        }
        
        .ui-customization-item input[type="color"] {
            width: 60px;
            height: 30px;
            cursor: pointer;
            border: 2px solid #FFA500;
            border-radius: 3px;
        }
        
        /* Debug Panel Styles */
        .debug-panel {
            background-color: #2d0051;
            border: 2px solid #ff0000;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 20px;
            display: none;
        }
        
        .debug-warning {
            background-color: #4a0000;
            border: 2px solid #ff0000;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        
        .debug-warning h3 {
            color: #ff0000;
            margin-top: 0;
        }
        
        .debug-password-input {
            background-color: #4a148c;
            color: #ffffff;
            border: 1px solid #ff69b4;
            padding: 10px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            width: 100%;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .debug-buttons {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        
        .debug-button {
            background-color: #808080;
            color: #ffffff;
            border: 2px solid #ff0000;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
        }
        
        .debug-button:hover {
            background-color: #a0a0a0;
        }
        
        .debug-button.danger {
            background-color: #8b0000;
            color: #ffffff;
            border-color: #ff0000;
        }
        
        .debug-button.danger:hover {
            background-color: #a00000;
        }
        
        .debug-button.confirm {
            background-color: #006400;
            color: #ffffff;
            border-color: #00ff00;
        }
        
        .debug-button.confirm:hover {
            background-color: #008000;
        }
        
        /* Rank colors */
        .rank-1-1000 { color: #ffffff; }
        .rank-1000-10000 { color: #ffff00; }
        .rank-10000-100000 { color: #00ffff; }
        .rank-100000-1000000 { color: #0000cd; }
        .rank-1000000-100000000 { color: #ff0000; }
        .rank-100000000-1000000000 { color: #8b0000; }
        .rank-1000000000-10000000000 { color: #00ff00; }
        .rank-10000000000-100000000000 { color: #ffc0cb; } 
        .rank-100000000000-1000000000000 { color: #a9a9a9; } 
        .rank-1000000000000-100000000000000 { color: #ff69b4; }
        .rank-improbable { color: #008080; }
        .variant-roll {} 
        
        .rank-rainbow {
            background: linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: rainbow-shift 3s linear infinite;
            background-size: 200% 100%;
        }

        /* Unobtainable rank style */
        .rank-unobtainable {
    position: relative;
    display: inline-block;
    color: transparent;
    background: linear-gradient(90deg, #000000, #ffffff);
    -webkit-background-clip: text;
    background-clip: text;
    font-weight: bold;
    text-shadow: 
        -1px -1px 0 #808080,
        0 -1px 0 #808080,
        1px -1px 0 #808080,
        -1px 0 0 #808080,
        1px 0 0 #808080,
        -1px 1px 0 #808080,
        0 1px 0 #808080,
        1px 1px 0 #808080;
}
        
        .rank-unobtainable::before {
            content: 'Unobtainable';
            position: absolute;
            left: 0;
            top: 0;
            color: #808080;
            z-index: 1;
            text-shadow: 
                -1px -1px 0 #808080,
                0 -1px 0 #808080,
                1px -1px 0 #808080,
                -1px 0 0 #808080,
                1px 0 0 #808080,
                -1px 1px 0 #808080,
                0 1px 0 #808080,
                1px 1px 0 #808080;
        }
        
        /* --- POLY DODECAHEDRON STYLE --- */
        .poly-dodecahedron-wrapper {
            position: relative;
            display: inline-block;
            z-index: 0;
        }
        
        .poly-dodecahedron-wrapper::before {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            width: 2em;
            height: 2em;
            background: 
                linear-gradient(135deg, #9b59b6 0%, #3498db 25%, #e74c3c 50%, #f39c12 75%, #9b59b6 100%);
            background-size: 200% 200%;
            -webkit-clip-path: polygon(
                20% 0%, 80% 0%, 100% 20%, 100% 80%, 80% 100%, 20% 100%, 0% 80%, 0% 20%,
                40% 20%, 60% 20%, 70% 40%, 75% 60%, 70% 80%, 40% 80%, 25% 60%, 25% 40%
            );
            clip-path: polygon(
                20% 0%, 80% 0%, 100% 20%, 100% 80%, 80% 100%, 20% 100%, 0% 80%, 0% 20%,
                40% 20%, 60% 20%, 70% 40%, 75% 60%, 70% 80%, 40% 80%, 25% 60%, 25% 40%
            );
            transform: translate(-50%, -50%);
            z-index: -1;
            opacity: 0.75;
            animation: spin-dodecahedron 3s linear infinite;
            box-shadow: 0 0 20px rgba(155, 89, 182, 0.6), inset 0 0 15px rgba(52, 152, 219, 0.4);
        }
        
        @keyframes spin-dodecahedron {
            0% { transform: translate(-50%, -50%) rotateX(0deg) rotateY(0deg) rotateZ(0deg); }
            100% { transform: translate(-50%, -50%) rotateX(360deg) rotateY(360deg) rotateZ(360deg); }
        }
        
        .secret-nonavacious {
            filter: drop-shadow(0 0 5px #00BFFF); 
        }
        
        @keyframes rainbow-shift {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }

        /* --- CUTSCENE STYLES --- */
        #cutscene-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000000;
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out; 
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .cutscene-active #cutscene-overlay {
            opacity: 1;
            pointer-events: all;
        }
        
        .cutscene-flash #cutscene-overlay {
            background-color: #ffffff;
        }

        #star-element {
            position: absolute; 
            top: 50%; 
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            opacity: 0;
            transition: opacity 0.5s ease-in;
            filter: drop-shadow(0 0 15px currentColor);
            background-color: currentColor; 
        }
        
        .star-4 {
            clip-path: polygon(50% 0%, 61% 39%, 100% 50%, 61% 61%, 50% 100%, 39% 61%, 0% 50%, 39% 39%);
        }
        
        .star-6 {
            clip-path: polygon(50% 0%, 65% 20%, 100% 30%, 80% 50%, 100% 70%, 65% 80%, 50% 100%, 35% 80%, 0% 70%, 20% 50%, 0% 30%, 35% 20%);
        }
        
        .star-8 {
            clip-path: polygon(50% 0%, 58% 30%, 100% 30%, 66% 50%, 100% 70%, 58% 70%, 50% 100%, 42% 70%, 0% 70%, 34% 50%, 0% 30%, 42% 30%);
        }
        
        .star-12 {
            clip-path: polygon(50% 0%, 55% 15%, 70% 15%, 75% 0%, 80% 15%, 95% 15%, 100% 30%, 95% 45%, 100% 70%, 95% 85%, 100% 85%, 75% 100%, 70% 85%, 55% 85%, 50% 100%, 45% 85%, 30% 85%, 25% 100%, 20% 85%, 5% 85%, 0% 70%, 5% 45%, 0% 30%, 5% 15%, 20% 15%, 25% 0%, 30% 15%, 45% 15%);
        }

        /* --- END CUTSCENE STYLES --- */

        /* --- SHAPES GUI STYLES --- */
        #shapes-gui {
            background-color: #2d0051;
            border: 2px solid #00FF00;
            padding: 20px;
            border-radius: 5px;
            display: none;
        }

        .shapes-field {
            background-color: #1a0033;
            border: 1px dashed #00FF00;
            min-height: 200px;
            max-height: 300px;
            overflow: hidden; 
            position: relative;
            margin-bottom: 15px;
        }

        .clickable-shape {
            position: absolute;
            width: 30px;
            height: 30px;
            cursor: pointer;
            transition: transform 0.2s, opacity 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            font-weight: bold;
            color: #000;
            text-shadow: 0 0 3px currentColor;
            border-radius: 2px;
            animation: float 5s ease-in-out infinite alternate; 
        }

        @keyframes float {
            0% { transform: translateY(0px) rotate(0deg); }
            100% { transform: translateY(-5px) rotate(5deg); }
        }

        .shape-Triangle { clip-path: polygon(50% 0%, 0% 100%, 100% 100%); }
        .shape-Square { clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%); }
        .shape-Pentagon { clip-path: polygon(50% 0%, 100% 38%, 81% 100%, 19% 100%, 0% 38%); }
        .shape-Hexagon { clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%); }
        .shape-7-Sided-Polygon { clip-path: polygon(50% 0%, 90% 20%, 100% 60%, 75% 100%, 25% 100%, 0% 60%, 10% 20%); }
        .shape-Octagon { clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%); }
        .shape-Circle { border-radius: 50%; }

        .shape-spawn-output {
            background-color: #1a0033;
            border: 1px solid #00FF00;
            padding: 10px;
            min-height: 50px;
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 15px;
        }
        
        .shape-spawn-line {
            margin: 5px 0;
            color: #00FF00;
        }
        
        .shapes-upgrades {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        /* --- END NEW STYLES --- */

        /* --- CLICKER GUI STYLES --- */
        #clicker-gui {
            background-color: #2d0051;
            border: 2px solid #FFD700;
            padding: 20px;
            border-radius: 5px;
            display: none;
        }

        #clover-clicker:active {
            transform: scale(0.9);
        }
        /* --- END NEW STYLES --- */
        
        /* --- SATANIC SECRET STYLE --- */
        .satanic-wrapper {
            position: relative;
            display: inline-block; 
            z-index: 0;
        }
        
        .satanic-wrapper::before {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            width: 2.5em;
            height: 2.5em;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><polygon points="50,5 61,40 98,40 68,62 79,96 50,75 21,96 32,62 2,40 39,40" style="fill:red;"/></svg>');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            transform: translate(-50%, -50%); 
            z-index: -1; 
            opacity: 0.75;
            animation: rotate-pentagram 9.009s linear infinite;
        }
        
        @keyframes rotate-pentagram {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
        /* --- END NEW STYLE --- */

        /* --- CORRUPTED SECRET STYLE --- */
        .secret-corrupted {
            display: inline-block;
            animation: corrupted-shake 12.5ms linear infinite;
            filter: invert(100%);
        }
        
        @keyframes corrupted-shake {
            0%    { transform: rotate(0deg); }
            16.67% { transform: rotate(22.5deg); }
            33.33% { transform: rotate(45deg); }
            50%    { transform: rotate(0deg); }
            66.67% { transform: rotate(-22.5deg); }
            83.33% { transform: rotate(-45deg); }
            100%   { transform: rotate(0deg); }
        }
        /* --- END NEW STYLE --- */

        /* --- Complex rank animation --- */
        .rank-complex {
            background: linear-gradient(90deg, #ff0000, #00ff00, #0000ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: complex-shift 2s linear infinite;
            background-size: 300% 100%;
            font-weight: bold;
        }
        
        @keyframes complex-shift {
            0% { background-position: 0% 50%; }
            100% { background-position: 300% 50%; }
        }
        /* --- END Complex rank animation --- */

        /* --- Pending rolls styles --- */
        .pending-roll-item {
            background-color: #3a0d6e;
            border: 1px solid #ffff00;
            padding: 10px;
            margin: 5px 0;
            border-radius: 3px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .pending-roll-buttons {
            display: flex;
            gap: 5px;
        }
        
        .pending-accept-btn {
            background-color: #00ff00;
            color: #000;
            border: 1px solid #00ff00;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .pending-decline-btn {
            background-color: #ff0000;
            color: #000;
            border: 1px solid #ff0000;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }
        /* --- END Pending rolls styles --- */

        /* --- Hardcore mode styles --- */
        .hardcore-rank {
            border-left: 3px solid #ff0000;
            padding-left: 5px;
            font-style: italic;
        }
        
        .hardcore-mode-active {
            background-color: #2d0051;
            border: 2px solid #ff0000;
        }
        
        .hardcore-mode-active .stat-item {
            color: #ff6666;
        }

        /* --- Illegitimate roll style --- */
        .illegitimate-roll {
            opacity: 0.7;
            text-decoration: line-through;
            color: #ff5555 !important;
        }

        /* --- NEW: Variant Secrets Styles --- */
        .variant-secrets-section {
            margin-top: 20px;
            border-top: 1px solid #ff69b4;
            padding-top: 15px;
        }
        
        .variant-secret-item {
            background-color: #4a148c;
            border: 1px solid #00ffff;
            padding: 8px;
            margin: 5px 0;
            border-radius: 3px;
        }
        
        .variant-secret-item.discovered {
            border-color: #00ff00;
        }
        
        .variant-secret-item.locked {
            opacity: 0.5;
            border-color: #666;
        }
        
        .variant-secret-note {
            font-size: 0.8em;
            color: #00ffff !important;
            font-style: italic;
        }
        
        .variant-secret-badge {
            background-color: #0044cc;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7em;
            margin-left: 5px;
            vertical-align: middle;
        }

        /* --- 1e21-1e30 Rank Style --- */
        .rank-1e21-1e30 {
            position: relative;
            color: #000000;
            font-weight: bold;
            animation: triple-invert 0.8s ease-in-out infinite alternate;
        }
        
        @keyframes triple-invert {
            0% {
                color: #ffffff;
                text-shadow: 0 0 10px #ffffff;
            }
            50% {
                color: #000000;
                text-shadow: 0 0 10px #000000;
            }
            100% {
                color: #ffffff;
                text-shadow: 0 0 10px #ffffff;
            }
        }
        /* --- END 1e21-1e30 Rank Style --- */

        /* --- Variant text size styles --- */
        .variant-GIANT {
            font-size: 5em !important;
            display: inline-block;
            line-height: 1;
            vertical-align: middle;
        }
        
        .variant-Mega {
            font-size: 1.5em !important;
            display: inline-block;
            line-height: 1;
            vertical-align: middle;
        }
        
        .variant-Small {
            font-size: 0.75em !important;
            display: inline-block;
            line-height: 1;
            vertical-align: middle;
        }

        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto;
            }
            
            .main-container > div:first-child,
            .main-container > div:nth-child(2),
            .main-container > div:last-child {
                grid-column: 1;
                grid-row: auto;
            }
            
            .main-container > div:last-child {
                display: block;
            }
        }

        @media (max-width: 768px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body class="cutscene-inactive">
    <h1>calis RNG game</h1>
    
    <div class="stats">
        <div class="stat-item">Currency: <span id="currency">0.00</span></div>
        <div class="stat-item">Geometrix: <span id="geometrix">0.00</span></div>
        <div class="stat-item">Total Upgrades: <span id="upgrades">0</span></div>
        <div class="stat-item">Luck: +<span id="luck">0.000</span></div>
        <div class="stat-item">Luck Multiplier: <span id="luckMulti">1.00</span>x</div>
        <div class="stat-item">Secret Luck: <span id="secretLuck">1.00</span>x</div>
        <div class="stat-item">Variant Chance: <span id="variantChance">1.00</span>x</div>
        <div class="stat-item">Next Upgrade Cost: <span id="upgradeCost">50.00</span></div>
        <div class="stat-item">Bulk Roll (Lvl <span id="bulkRollLevel">0</span>): <span id="bulkRollAmount">1</span> roll/click</div>
        <div class="stat-item">Next Bulk Roll Cost: <span id="bulkRollCost">500,000.00</span></div>
        <div class="stat-item">Inventory: <span id="inventoryCount">0</span>/<span id="inventoryMax">10</span></div>
        <div class="stat-item">Pending Rolls: <span id="pendingCount">0</span>/<span id="pendingMax">30</span></div>
        <div class="stat-item">Rarest Roll: <span id="rarest">None yet</span></div>
        <div class="stat-item">Ranks Discovered: <span id="ranksDiscovered">0</span>/<span id="totalRanks">60</span></div>
        <div class="stat-item">Secrets Enabled: <span id="secretsEnabled">Yes</span></div>
        <div class="stat-item">Hardcore Mode: <span id="hardcoreStatus">OFF</span></div>
        <div class="stat-item">Scientific Notation: <span id="sciNotationStat">ON (‚â•1e18)</span></div>
        <div class="stat-item">Variant Secrets: <span id="variantSecretsDiscovered">0</span>/<span id="totalVariantSecrets">10</span></div>
    </div>

    <div class="scientific-setting">
        <div class="section-header">Scientific Notation Settings</div>
        <div class="scientific-setting-item">
            <label>Scientific notation threshold (‚â•):</label>
            <input type="number" id="sciNotationThreshold" value="1000000000000000000" min="1" step="0.000001">
        </div>
        <div class="scientific-setting-item">
            <button onclick="toggleScientificNotation()">Toggle Scientific Notation: <span id="sciNotationStatus">ON</span></button>
        </div>
        <div class="scientific-setting-item" style="color: #00ffff; font-size: 12px;">
            Note: Numbers ‚â• threshold will display in scientific notation (e.g., 1.23e18)
        </div>
    </div>

    <div class="ui-customization">
        <div class="section-header" style="color: #FFA500;">UI Customization</div>
        <div class="ui-customization-item">
            <label>Background Color:</label>
            <input type="color" id="ui-bg-color" value="#4a148c">
        </div>
        <div class="ui-customization-item">
            <label>Button Background:</label>
            <input type="color" id="ui-button-bg" value="#808080">
        </div>
        <div class="ui-customization-item">
            <label>Button Outline:</label>
            <input type="color" id="ui-button-outline" value="#ff69b4">
        </div>
        <div class="ui-customization-item">
            <label>HC Mode UI Color:</label>
            <input type="color" id="ui-hc-color" value="#ff0000">
        </div>
        <div class="ui-customization-item">
            <label>Text Color:</label>
            <input type="color" id="ui-text-color" value="#ffffff">
        </div>
        <div class="ui-customization-item">
            <button onclick="applyUICustomization()" style="background-color: #FFA500; border-color: #FFA500; color: #000;">Apply UI Changes</button>
            <button onclick="resetUICustomization()" style="background-color: #808080; border-color: #ff69b4; color: #fff;">Reset to Default</button>
        </div>
    </div>

    <div class="debug-panel" id="debug-panel">
        <div class="debug-warning">
            <h3>‚ö†Ô∏è DEBUG PANEL WARNING ‚ö†Ô∏è</h3>
            <p>Are you SURE you wanna open this? If so, type the secret password into the text box below and confirm. Type 'no' to close this. BE AWARE PLAYING AROUND WITH THIS CAN MESS UP YOUR SAVE</p>
            <input type="password" id="debug-password-input" class="debug-password-input" placeholder="Enter debug password">
            <div style="display: flex; gap: 10px; margin-top: 10px;">
                <button onclick="checkDebugPassword()" class="debug-button confirm">Confirm Password</button>
                <button onclick="closeDebugPanel()" class="debug-button">Type 'no' to close</button>
            </div>
        </div>
        
        <div id="debug-commands" style="display: none;">
            <div class="section-header" style="color: #ff0000;">Debug Commands</div>
            <div class="debug-buttons">
                <button onclick="resetEventsDebug()" class="debug-button">Event Resetter (fixes bugged events)</button>
                <button onclick="resetSaveDebug()" class="debug-button danger">Save Resetter (5 confirmations)</button>
                <button onclick="toggleForceRollUI()" class="debug-button">Force Roll (Custom)</button>
                <!-- NEW BUTTONS -->
                <button onclick="nukeShopData()" class="debug-button danger">Nuke Shop Data</button>
                <button onclick="fixSaveFile()" class="debug-button">Fix Save File</button>
                <button onclick="inspectSaveFile()" class="debug-button">Inspect Save File</button>
                <button onclick="closeDebugPanel()" class="debug-button">Close Debug Panel</button>
            </div>
            <div id="force-roll-ui" style="display: none; margin-top: 15px; padding: 15px; background-color: #3a0d6e; border: 1px solid #ff0000; border-radius: 5px;">
                <div style="color: #FFD700; font-weight: bold; margin-bottom: 10px;">Custom Force Roll</div>
                <div style="margin-bottom: 10px;">
                    <label style="color: #ffffff;">Luck:</label>
                    <input type="number" id="forceRollLuck" value="0" style="width: 100%; padding: 5px; background-color: #4a148c; color: #ffffff; border: 1px solid #FFD700;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="color: #ffffff;">Variant Luck:</label>
                    <input type="number" id="forceRollVariantLuck" value="0" style="width: 100%; padding: 5px; background-color: #4a148c; color: #ffffff; border: 1px solid #FFD700;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="color: #ffffff;">Secret Luck:</label>
                    <input type="number" id="forceRollSecretLuck" value="0" style="width: 100%; padding: 5px; background-color: #4a148c; color: #ffffff; border: 1px solid #FFD700;">
                </div>
                <div style="display: flex; gap: 10px;">
                    <button onclick="executeCustomForceRoll()" class="debug-button" style="flex: 1;">Roll</button>
                    <button onclick="toggleForceRollUI()" class="debug-button" style="flex: 1; background-color: #555;">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <div class="autoroll-settings" style="padding-bottom: 5px;">
        <div class="section-header">Auto Accept Settings</div>
        <div class="autoroll-setting-item">
            <label>Accept on value ‚â•:</label>
            <input type="number" id="autoAcceptThreshold" value="0" step="0.000001" placeholder="Enter minimum value">
        </div>
        <div class="autoroll-setting-item">
            <label>Accept on base rank ‚â•:</label>
            <input type="number" id="autoAcceptTrueRNG" value="0" step="0.000001" placeholder="Enter minimum base value">
        </div>
        <div class="autoroll-setting-item">
            <label>Accept on secret rarity ‚â•:</label>
            <input type="number" id="autoAcceptSecretThreshold" value="0" step="0.000001" placeholder="Enter minimum rarity">
        </div>
        <div class="autoroll-setting-item">
            <input type="checkbox" id="autoAcceptNewRank">
            <label for="autoAcceptNewRank">Accept on new rank discovery</label>
        </div>
        
        <div class="section-header" style="margin-top: 15px;">Auto Stop Settings</div>
        <div class="autoroll-setting-item">
            <label>Stop on value ‚â•:</label>
            <input type="number" id="autoStopThreshold" value="0" step="0.000001" placeholder="Enter minimum value">
        </div>
        <div class="autoroll-setting-item">
            <label>Stop on base rank ‚â•:</label>
            <input type="number" id="autoStopTrueRNG" value="0" step="0.000001" placeholder="Enter minimum base value">
        </div>
        <div class="autoroll-setting-item">
            <label>Stop on secret rarity ‚â•:</label>
            <input type="number" id="autoStopSecretThreshold" value="0" step="0.000001" placeholder="Enter minimum rarity">
        </div>
        <div class="autoroll-setting-item">
            <input type="checkbox" id="autoStopNewRank">
            <label for="autoStopNewRank">Stop on new rank discovery</label>
        </div>
        
        <div class="section-header" style="margin-top: 15px;">Import / Export Save</div>
        <textarea id="saveDataTextarea" style="width: 95%; min-height: 80px; background-color: #4a148c; color: #ffffff; border: 1px solid #ff69b4; font-family: 'Courier New', monospace; margin-bottom: 15px; padding: 5px; resize: vertical;" placeholder="Paste save data here and click 'Import Save'"></textarea>
        <div class="controls" style="grid-template-columns: 1fr 1fr; margin-bottom: 10px;">
            <button onclick="exportSave()">Export Save</button>
            <button onclick="importSave()">Import Save</button>
            <button onclick="openDebugPanel()" style="background-color: #8b0000; border-color: #ff0000;">Debug Panel</button>
        </div>
        <div id="hardcore-warning" style="color: #ff0000; display: none; margin-top: 10px; padding: 10px; background-color: #3a0d6e; border: 1px solid #ff0000;">
            <strong>‚ö†Ô∏è Hardcore Mode Active:</strong> Bulk=1, Luck=1, Variant=1, Secret=1, Events disabled
        </div>
    </div>

    <div class="controls">
        <button onclick="roll()">Roll (r)</button>
        <button id="autoRollBtn" onclick="toggleAutoRoll()">Auto Roll</button>
        <button onclick="buyUpgrade()">Buy Upgrade</button>
        <button id="buyBulkRollBtn" onclick="buyBulkRoll()">Buy Bulk Roll</button>
        <button onclick="showRarest()">Show Rarest</button>
        <button onclick="clearTerminal()">Clear Terminal</button>
        <button onclick="saveGame()">Save Game</button>
        <button id="cutsceneToggleBtn" onclick="toggleCutscenes()">Cutscenes: ON</button>
        <button id="secretToggleBtn" onclick="toggleSecrets()">Secrets: ON</button>
        <button id="hardcoreToggleBtn" onclick="toggleHardcoreMode()">Hardcore Mode: OFF</button>
        <button onclick="openBoosterShop()">Shop</button>
    </div>
    
    <div id="shop-panel" style="display: none; background-color: #2d0051; border: 2px solid #FFD700; padding: 20px; border-radius: 5px; margin-top: 10px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <div class="section-header" style="color: #FFD700; margin: 0;">Booster Shop</div>
            <button onclick="closeBoosterShop()" style="background-color: #8b0000; border-color: #ff0000; padding: 5px 10px; cursor: pointer;">Close</button>
        </div>
        <div id="shop-content" style="min-height: 100px; background-color: #4a148c; border: 1px solid #FFD700; padding: 10px; border-radius: 3px; text-align: center;"></div>
        <div style="margin-top: 15px; color: #FFD700; font-size: 12px; text-align: center;">Click shapes to buy ‚Ä¢ Your Boosters:</div>
        <div id="booster-list" style="min-height: 50px; max-height: 150px; overflow-y: auto; background-color: #4a148c; border: 1px solid #FFD700; padding: 10px; border-radius: 3px; margin-top: 10px;">
            <div id="boosterContent">No boosters owned</div>
        </div>
    </div>
    
    <div class="main-container">
        <div>
            <div id="terminal"></div>
        </div>
        <div>
            <div id="inventory">
                <div class="section-header">Inventory</div>
                <div class="controls" style="grid-template-columns: 1fr 1fr; margin-bottom: 10px;">
                    <button onclick="sortInventory('leastRarest')">Least Rarest</button>
                    <button onclick="sortInventory('mostRarest')">Most Rarest</button>
                </div>
                <div id="inventoryContent">Empty</div>
            </div>
        </div>
        <div>
            <div class="right-column">
                <div id="index">
                    <div class="section-header">Index (Ranks Discovered)</div>
                    <div id="indexContent">Roll to discover ranks!</div>
                </div>
                
                <div id="pending-rolls">
                    <div class="section-header">Pending Rolls</div>
                    <div id="pendingContent">Empty</div>
                </div>
                
                <div class="controls" id="shapes-unlock-controls">
                    <button id="unlockShapesBtn" onclick="unlockShapes()">Unlock Shapes GUI (5,000,000.00 Currency)</button>
                </div>
                
                <div id="shapes-gui">
                    <div class="section-header" style="color: #00FF00;">Shapes GUI</div>
                    
                    <div id="shapes-field" class="shapes-field"></div>

                    <div class="stat-item">Current Shape Luck: +<span id="shapeLuckBonus">0.0</span>x</div>
                    <div class="stat-item">Shapes/Spawn: <span id="bulkShapeAmount">1</span> (Lvl <span id="bulkShapeLevel">0</span>)</div>
                    <div class="stat-item">Spawn Cooldown: <span id="shapeCooldown">2.0000</span>s</div>
                    
                    <div class="shape-spawn-output" id="shape-spawn-output" style="height: 50px;">Waiting for first spawn...</div>

                    <div class="shapes-upgrades">
                        <button id="buyShapeLuckBtn" onclick="buyShapeLuckUpgrade()">Shape Luck (+0.1x) - Cost: <span id="shapeLuckCost">5.00</span> GMX</button>
                        <button id="buyLuckMultiBtn" onclick="buyLuckMultiUpgrade()">Luck Multiplier (x2.00) - Cost: <span id="luckMultiCost">100.00</span> GMX</button>
                        <button id="buyBulkShapeBtn" onclick="buyBulkShapeUpgrade()">Bulk/Cooldown Lvl <span id="bulkShapeLevelBtn">1</span> - Cost: <span id="bulkShapeCost">50.00</span> GMX</button>
                        <button id="buyClickerUnlockBtn" onclick="unlockClicker()">Unlock Clicker - Cost: 1,000,000.00 GMX</button>
                    </div>
                </div>
                
                <div id="clicker-gui">
                    <div class="section-header" style="color: #FFD700;">Clicker</div>
                    
                    <div class="stats" style="background-color: #2d0051; border-color: #FFD700; padding: 10px; margin-bottom: 10px;">
                        <div class="stat-item">Fortunium: <span id="fortunium">0.00</span></div>
                        <div class="stat-item">Fortunium Luck: +<span id="fortuniumLuck">0.00</span>x</div>
                    </div>

                    <div id="clover-field" style="text-align: center; margin-bottom: 15px;">
                         <span id="clover-clicker" style="font-size: 80px; cursor: pointer; display: inline-block; transition: transform 0.1s; user-select: none;">üçÄ</span>
                    </div>

                    <div class="clicker-upgrades" style="display: flex; flex-wrap: wrap; gap: 10px;">
                        <button id="buyGmxMultiBtn" onclick="buyFortuniumUpgrade('gmx')">GMX Multi (+0.5x) - Cost: <span id="gmxMultiCost">75.00</span> FOR</button>
                        <button id="buyFortuniumLuckBtn" onclick="buyFortuniumUpgrade('fortuniumLuck')">Fortunium Luck (+0.5x) - Cost: <span id="fortuniumLuckCost">125.00</span> FOR</button>
                        <button id="buyClickerLuckBtn" onclick="buyFortuniumUpgrade('luck')">Luck Multi (+0.5x) - Cost: <span id="clickerLuckCost">1000.00</span> FOR</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="cutscene-overlay">
        <div id="star-element" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);"></div>
    </div>

    <script>
        // --- GLOBAL RUIN VARIABLE ---
        window.calisrng2 = {
            ruin: false,
            ruinInterval: null,
            ruinOriginalColors: new Map(),
            ruinOriginalTexts: new Map()
        };

        function startRuin() {
            if (calisrng2.ruinInterval) clearInterval(calisrng2.ruinInterval);
            
            // Store original colors and texts
            document.querySelectorAll('*').forEach(el => {
                if (el.style) {
                    calisrng2.ruinOriginalColors.set(el, {
                        color: el.style.color,
                        backgroundColor: el.style.backgroundColor
                    });
                }
                if (el.textContent && el.children.length === 0) {
                    calisrng2.ruinOriginalTexts.set(el, el.textContent);
                }
            });
            
            calisrng2.ruinInterval = setInterval(() => {
                // Randomize all colors
                document.querySelectorAll('*').forEach(el => {
                    if (el.style) {
                        el.style.color = '#' + Math.floor(Math.random() * 16777215).toString(16);
                        el.style.backgroundColor = '#' + Math.floor(Math.random() * 16777215).toString(16);
                    }
                });
                
                // Change all text to "Lol"
                document.querySelectorAll('*').forEach(el => {
                    if (el.children.length === 0 && el.textContent) {
                        el.textContent = "Lol";
                        if (el.innerHTML) el.innerHTML = "Lol";
                    }
                });
                
                // Make everything shake
                document.querySelectorAll('*').forEach(el => {
                    el.style.transform = `translate(${Math.random() * 20 - 10}px, ${Math.random() * 20 - 10}px)`;
                });
                
                // Randomize font sizes
                document.querySelectorAll('*').forEach(el => {
                    el.style.fontSize = `${Math.random() * 3 + 0.5}em`;
                });
            }, 50);
            
            addToTerminal("‚ö†Ô∏è RUIN MODE ACTIVATED! Everything is broken!", true, 'rank-1000000-100000000');
        }

        function stopRuin() {
            if (calisrng2.ruinInterval) {
                clearInterval(calisrng2.ruinInterval);
                calisrng2.ruinInterval = null;
                
                // Restore original colors
                calisrng2.ruinOriginalColors.forEach((colors, el) => {
                    if (el.style) {
                        el.style.color = colors.color;
                        el.style.backgroundColor = colors.backgroundColor;
                    }
                });
                
                // Restore original texts
                calisrng2.ruinOriginalTexts.forEach((text, el) => {
                    if (el.textContent) {
                        el.textContent = text;
                        if (el.innerHTML) el.innerHTML = text;
                    }
                });
                
                // Reset transforms and font sizes
                document.querySelectorAll('*').forEach(el => {
                    el.style.transform = '';
                    el.style.fontSize = '';
                });
                
                addToTerminal("Ruin mode deactivated. Game restored.", true);
            }
        }

        Object.defineProperty(window.calisrng2, 'ruin', {
            set: function(value) {
                this._ruin = value;
                if (value) {
                    startRuin();
                } else {
                    stopRuin();
                }
            },
            get: function() {
                return this._ruin;
            }
        });

        // --- CONSTANTS ---
        const POWER_EXPONENT = -2.4;
        const AUTO_ROLL_DELAY_MS = 5;
        const UPGRADE_COST_MULTIPLIER = 1.15;
        const LUCK_PER_UPGRADE = 2.5;
        const INVENTORY_PER_UPGRADE = 10;
        const VARIANT_CHANCE_PER_UPGRADE = 0.05;
        const MAX_VARIANT_CHANCE_MULTIPLIER = 12.5;
        const SECRET_LUCK_PER_UPGRADE = 0.25;
        const MAX_SECRET_LUCK = 7.5;
        const BULK_ROLL_COST_MULTIPLIER = 2.5;
        const MAX_BULK_ROLL_LEVEL = 9;
        const MAX_VARIANTS_PER_ROLL = 5; 
        
        const CUTSCENE_DURATION_MS = 7000;
        const STAR_FADE_IN_MS = 2000;
        const SPIN_ACCEL_MS = 5000;
        const SIZE_UPDATE_INTERVAL_MS = 10; 
        const SIZE_MULTIPLIER_PER_UPDATE = 1.02;
        const WHITE_FLASH_DURATION_MS = 1000; 

        const EVENT_CHECK_INTERVAL_MS = 500; 

        const EVENTS = [
            { 
                name: "Error", 
                chance: 1/40.4, 
                duration: 15000,
                description: "makes nil, Title Label Missing and unknown's rarity be easier by x4 (this event sucks bro whyd i add it)",
                targets: ["nil", "Title Label Missing", "?!? unknown ?!?"],
                multiplier: 4 
            },
            { 
                name: "Lol", 
                chance: 1/69, 
                duration: 20000,
                description: "makes every meme related secret easier by 6.94x and boosts future event chances",
                targets: ["r", "fish", "cheese", "c", "cheese : cheddar", "LEGACY In im table ?!?!?", "QHAR ?!?", "7 GRAND DAD"],
                multiplier: 6.94,
                eventChanceBoost: 69 
            },
            { 
                name: "UNDEFINED", 
                chance: 1/300, 
                duration: 30000,
                description: "makes ranks 'unknown,' 'title label missing' and 'absolute zero' be x5 times easier",
                targets: ["?!? unknown ?!?", "Title Label Missing", ":[{(absolute zero)}]:"],
                multiplier: 5
            },
            { 
                name: "Modified", 
                chance: 1/750, 
                duration: 7500,
                description: "makes every variant x2.5 times easier",
                targets: [],
                multiplier: 2.5
            },
            { 
                name: "Self Insert", 
                chance: 1/777, 
                duration: 77777,
                description: "makes cali^2 easier by x777,777.777",
                targets: ["cali^2"],
                multiplier: 777777.777
            },
            { 
                name: "Hellish", 
                chance: 1/66.66, 
                duration: 66666,
                description: "makes ‚õßSatanic‚õß, Seize and Insanity x6.66 easier",
                targets: ["‚õßSatanic‚õß", "Seize", "Insanity"],
                multiplier: 6.66 
            },
            {
                name: "ULTRA",
                chance: 1/10000,
                duration: 3333,
                description: "EVERY SECRET IS x100 EASIER FOR A FEW SECONDS.",
                targets: ["ALL_SECRETS"],
                multiplier: 100
            },
            {
            name: "Exclusivity",
            chance: 1/725,
            duration: 30000,
            description: "EVERY dev exclusive is rollable for 30s",
            targets: ["ALL_SECRETS"],
            multiplier: 1
            },
            {
    name: "Impossibility",
    chance: 1/500,
    duration: 60000,
    description: "SUPER HARD secrets are super easier.",
    targets: ["cali^2", "Guardian", "one", "Obscure", "SUPERNOVA", "Omnipotence", "LEGACY In im table ?!?!?", "chezburger", "( N A M E L E S S )" ],
    multiplier: 10000
},
            { 
                name: "Hidden", 
                chance: 1/1000, 
                duration: 15000,
                description: "makes EVERY secret X7.77 easier",
                targets: ["ALL_SECRETS"],
                multiplier: 7.77
            }
        ];

        const VARIANTS = [
            { name: "Shiny", chance: 1/100, multiplier: 25, color: "#FFD700" },
            { name: "Gilded", chance: 1/125, multiplier: 125, color: "#FFA500" },
            { name: "Crystalized", chance: 1/500, multiplier: 250, color: "#e642f5" },
            { name: "Spectral", chance: 1/625, multiplier: 625, color: "#9400D3" },
            { name: "Extraordinary", chance: 1/1250, multiplier: 1250, color: "#FF1493" },
            { name: "Myriad", chance: 1/2500, multiplier: 2500, color: "#00FFFF" },
            { name: "Charred", chance: 1/4000, multiplier: 4000, color: "#FF4500" },
            { name: "Expert", chance: 1/7500, multiplier: 7500, color: "#00BFFF" },
            { name: "Wind", chance: 1/12500, multiplier: 12500, color: "#ADD8E6" }, 
            { name: "Mega", chance: 1/25000, multiplier: 25000, color: "#FF00FF" }, 
            { name: "Small", chance: 1/35000, multiplier: 35000, color: "#BEBEBE" }, 
            { name: "Monument", chance: 1/55555, multiplier: 55555, color: "#8B4513" }, 
            { name: "ETERNAL DAWN", chance: 1/77777, multiplier: 77777, color: "#FFFFFF" },
            { name: ">Finale<", chance: 1/100000, multiplier: 100000, color: "#D2691E" },
            { name: "Solar", chance: 1/250000, multiplier: 250000, color: "#FFA500" },
            { name: "Atomic", chance: 1/494500, multiplier: 494500, color: "#32CD32" },
            { name: "Luminous", chance: 1/625000, multiplier: 625000, color: "#90ccdb" },
            { name: "Charged", chance: 1/750000, multiplier: 750000, color: "#90db90" },
            { name: "Ultimate", chance: 1/1e6, multiplier: 1e6, color: "#1e4259" },
            { name: "Ionized", chance: 1/2.5e6, multiplier: 2.5e6, color: "#c29bdb" },
            { name: "monochrome", chance: 1/1.6666e4, multiplier: 1.6666e4, color: "#5c5c5c" },
            { name: "GIANT", chance: 1/5e6, multiplier: 5e6, color: "#7dbd6a" },
            { 
                name: "Negative", 
                chance: 1/5625, 
                multiplier: -1, 
                color: "#000000", 
                bypassCap: true,
                isNegative: true 
            },
            { 
                name: "Dull", 
                chance: 1/147382, 
                power: -1, 
                color: "#666666", 
                bypassCap: true,
                isDull: true
            }
        ];

        const RANK_TIERS = [
            { min: 1, max: 1.01, name: "TRASH"},
            { min: 1.01, max: 5, name: "Common" },
            { min: 5, max: 25, name: "Natural" },
            { min: 25, max: 50, name: "Uncommon" },
            { min: 50, max: 100, name: "Normal" },
            { min: 100, max: 100.1, name: "weird" },
            { min: 100.1, max: 500, name: "Divine" },
            { min: 500, max: 1000, name: "Grandiose" },
            { min: 1000, max: 2500, name: "Decent" },
            { min: 2500, max: 7500, name: "Unreal" },
            { min: 7500, max: 25000, name: "Cosmic" },
            { min: 25000, max: 100000, name: "Eternal" },
            { min: 100000, max: 500000, name: "Iridescent" },
            { min: 500000, max: 777777.77, name: "Exceptional" },
            { min: 777777.77, max: 788888.78, name: "Unordinary" },
            { min: 788888.78, max: 1e6, name: "Radioactive" },
            { min: 1e6, max: 5e6, name: "Heavenly" },
            { min: 5e6, max: 1e7, name: "Fantasy" },
            { min: 1e7, max: 5e7, name: "Unattainable" },
            { min: 5e7, max: 1e8, name: "Gigantic" },
            { min: 1e8, max: 2.5e8, name: "Epsilon" },
            { min: 2.5e8, max: 5e8, name: "Terafined" },
            { min: 5e8, max: 1e9, name: "Eclipse" },
            { min: 1e9, max: 5e9, name: "Infinitude" },
            { min: 5e9, max: 1e10, name: "Theoretical" },
            { min: 1e10, max: 1e11, name: "Unseeable" }, 
            { min: 1e11, max: 1e12, name: "Impassive" }, 
            { min: 1e12, max: 1e13, name: "Unrollable" },
            { min: 1e13, max: 1e14, name: "MACROSCOPIC" },
            { min: 1e14, max: 1e15, name: "Null" },
            { min: 1e15, max: 1e18, name: "Imaginary" },
            { min: 1e18, max: 1e21, name: "Impossible" },
            { min: 1e21, max: 1e24, name: "Astronomical" },
            { min: 1e24, max: 1e30, name: "Colossal" }, 
            { min: 1e30, max: Infinity, name: "Improbable" }
        ];

        const SECRET_RANKS_CHANCES = [
            { name: "nil", chance: 1/17500, rarity: 17500 }, 
            { name: "Title Label Missing", chance: 1/4040.404, rarity: 4040.404 },
            { name: "?!? unknown ?!?", chance: 1/6666.666, rarity: 6666.666 },
            { name: "r", chance: 1/6942, rarity: 6942 },
            { name: "?!? bewilderment ?!?", chance: 1/450285, rarity: 450285 },
            { name: "Interminable", chance: 1/7777, rarity: 7777 },
            { name: "fish", chance: 1/7979, rarity: 7979 },
            { name: "cheese", chance: 1/9995, rarity: 9995 },
            { name: "üíØ", chance: 1/10000, rarity: 10000 },
            { name: "Minimal", chance: 1/15000, rarity: 15000 },
            { name: "c", chance: 1/33333, rarity: 33333 },
            { name: "Seize", chance: 1/97525, rarity: 97525 }, 
            { name: "Florescent", chance: 1/264839, rarity: 264839 },
            { name: "œÄ", chance: 1/314159, rarity: 314159 },
            { name: "breaktime", chance: 1/705372, rarity: 705372, timeBased: true },
            { name: "~Nonavacious~", chance: 1/575630, rarity: 575630 }, 
            { name: "Insanity", chance: 1/666666, rarity: 666666 }, 
            { name: "Grand", chance: 1/1e6, rarity: 1e6 },
            { name: "SUPERNOVA", chance: 1/7.271338e8, rarity: 7.271338e8 },
            { name: "pure", chance: 1/400000, rarity: 400000 },
            { name: "Omnipotence", chance: 1/1e18, rarity: 1e18 },
            { name: "7 GRAND DAD", chance: 1/777.777, rarity: 777.777, requiresGrand: true },
            { name: ":[{(absolute zero)}]:", chance: 1/1e6, rarity: 1e6 },
            { name: "alpha", chance: 1/123456, rarity: 123456 },
            { name: "beta", chance: 1/1234567, rarity: 1234567 },
            { name: "gamma", chance: 1/12345678, rarity: 12345678 },
            { name: "Defined", chance: 1/1.5e6, rarity: 1.5e6 },
            { name: "Finale.. wait, how'd this get here?", chance: 1/2.5e6, rarity: 2.5e6 },
            { name: "Pseudopseudohypoparathyroidism", chance: 1/5e6, rarity: 5e6 },
            { name: "secret^2", chance: 1/1e7, rarity: 1e7 },
            { name: "cheese: cheddar", chance: 1/1.5e7, rarity: 1.5e7 },
            { name: "QHAR ?!?", chance: 1/2.5e7, rarity: 2.5e7 },
            { name: "!! EUPHORIA !!", chance: 1/56789000, rarity: 56789000 },
            { name: "CORRUPTED", chance: 1/648236826.394, rarity: 648236826.394, eventOnly: "Hellish" },
            { name: "Chargoggagoggmanchauggauggagoggchaubunagungamaugg", chance: 1/77777777.77, rarity: 77777777.77 },
            { name: "‚õßSatanic‚õß", chance: 1/1e9, rarity: 1e9 },
            { name: "CATASTROPHIC", chance: 1/575765.565, rarity: 575765.5265, multiplier: 575765.565 },
            { name: "LEGACY In im table ?!?!?", chance: 1/11111111111111.111, rarity: 11111111111111.111, multiplier: 11111111111111.11 },
            { name: "Destroyed", chance: 0, rarity: Infinity, eventOnly: "Hidden", eventChance: 1/100000000 },
            { name: "cali^2", chance: 1/1e12, rarity: 1e12 },
            { name: "c : omega c", chance: 1/5.555e8, rarity: 5.555e8 },
            { name: "one", chance: 1/1.1111111e11, rarity: 1.1111111111e11 },
            { name: "NEXUS", chance: 1/1.0001e9, rarity: 1e9 },
            { name: "SUPREMITY", chance: 1/6.1862863e13, rarity: 6.1862863e13 },
            { name: "Mythical", chance: 1/750000, rarity: 750000 },
            { name: "Guardian", chance: 1/1234072637263827, rarity: 1234072637263827 },
            { name: "Obscure", chance: 1/6942069420, rarity: 6942069420 },
            { name: "Possible", chance: 1/28284.2712475, rarity: 28284.2712475 },
            { name: "chezburger", chance: 1/1.5e10, rarity: 1.5e10 },
            { name: "coal osal !!!", chance: 1/5551112, rarity: 5551112 },
            { name: "Obscam", chance: 1/888.8888888e6, rarity: 888.8888888e6 },
            { name: "probable", chance: 1/7.5e7, rarity: 7.5e7 },
            { name: "( N A M E L E S S )", chance: 1/9.99999999e9, rarity: 9.99999999e9 },
            { name: "Bootleg cali^2", chance: 1/1.01e6, rarity: 1e6 },
            { name: "!!! S E R O T O N I N !!!", chance: 1/94.34e9, rarity: 94.34e9 },
            { name: "Lol", chance: 0, rarity: 1e30, eventOnly: "ULTRA", eventChance: 1/1e6 },
            { name: "cali^0.5 (DEV EXCLUSIVE)", chance: 0, rarity: 69420, eventOnly: "Exclusivity", eventChance: 1/69420 },
            { name: "??? (DEV EXCLUSIVE)", chance: 0, rarity: 4.25e7, eventOnly: "Exclusivity", eventChance: 1/4.25e7 },
            { name: "Poly", chance: 1/175257625, rarity: 175257625 },
            { name: "Delusion", chance: 1/98900000, rarity: 98900000 },
            { name: "Maniac", chance: 1/7e7, rarity: 7e7 },
            { name: "Perlica", chance: 1/2e10, rarity: 2e10 },
            { name: "err.404notfound (DEV EXCLUSIVE)", chance: 0, rarity: 4.04e8, eventOnly: "Exclusivity", eventChance: 1/4.04e8 },
            { name: "WHAT THE FUCK", chance: 1/1e50, rarity: 1e50, multiplier: 1e50 }
        ];

        // NEW: Variant Secrets (Only Sound remains)
        const VARIANT_SECRETS = [
            {
                name: "Sound",
                needsRank: "Uncommon",
                needsVariant: "Gilded",
                chance: 1/299,
                multipliesRNG: 855000,
                rarity: 299 * 125
            }
            // All other variant secrets have been removed as requested
        ];

        SECRET_RANKS_CHANCES.sort((a, b) => a.chance - b.chance); 

        const EUPHORIA_SYMBOLS = ['%', '@', '#', '^', '$', '*', '&', '>', '<', '?'];
        const TOTAL_RANKS = 102;
        const TOTAL_VARIANT_SECRETS = 1; // Changed to 1 since only Sound remains
        
        const UNLOCK_SHAPES_COST = 5000000;
        const SHAPE_SPAWN_INTERVAL_MS = 2000;
        const MAX_SHAPE_LUCK_LEVEL = 5;
        const SHAPE_LUCK_BONUS = 0.1;
        const SHAPE_LUCK_COST_MULTIPLIER = 1.75;
        const LUCK_MULTI_COST_MULTIPLIER = 1000;
        const BULK_SHAPE_COST_MULTIPLIER = 5;
        const MAX_BULK_SHAPE_LEVEL = 4;
        const SHAPE_COOLDOWN_DECREASE_MS = 333.3333;
        const SHAPE_DESPAWN_TIME_MS = 5000;
        
        const SHAPES = [
            { name: "Triangle", chance: 1/2, rarity: 2, color: "#FFFF00" },
            { name: "Square", chance: 1/5, rarity: 5, color: "#00FF00" },
            { name: "Pentagon", chance: 1/10, rarity: 10, color: "#00FFFF" },
            { name: "Hexagon", chance: 1/25, rarity: 25, color: "#FF00FF" }, 
            { name: "7 Sided Polygon", chance: 1/50, rarity: 50, color: "#FFA500" },
            { name: "Octagon", chance: 1/100, rarity: 100, color: "#800080" },
            { name: "Circle", chance: 1/500, rarity: 500, color: "#FF0000" }
        ];

        const UNLOCK_CLICKER_COST = 333333.33;
        const MAX_CLICKER_LUCK_LEVEL = 4;

        const COMPLEX_CHANCE = 1/75000;

        const HARDCORE_MODE_ENABLED = true;

        const DEFAULT_SCI_THRESHOLD = 1e12;
        
        const BOOSTER_BASE_LUCK = 15;
        const BOOSTER_LUCK_FORMULA = (rand) => Math.pow(rand, -1.2);
        const BOOSTER_COST_FORMULA = (multi) => Math.pow(multi, 1.75);

        const DEBUG_PASSWORD = "gd8!dgi0()";

        // --- GAME STATE VARIABLES ---
        let currency = 0;
        let totalUpgrades = 0;
        let upgradeCost = 50;
        let highestBaseRoll = 0; 
        let highestFinalRoll = { 
            value: 0,
            baseValue: 0,
            rank: 'None yet',
            variants: [],
            isSecret: false
        };
        let autoRollInterval = null;
        let maxInventory = 10;
        let inventory = [];
        let rollIndex = 1;
        let acceptedRolls = new Set();
        let discoveredRanks = new Set();
        
        // NEW: Pending rolls system
        let pendingRolls = [];
        let maxPendingRolls = maxInventory * 3;
        
        // NEW: Secrets toggle
        let secretsEnabled = true;
        
        // NEW: Hardcore mode
        let hardcoreMode = false;
        let originalBulkRollLevel = 0;
        let originalLuck = 0;
        let originalVariantChance = 1;
        let originalSecretLuck = 1;
        
        // NEW: Scientific notation settings
        let sciNotationThreshold = DEFAULT_SCI_THRESHOLD;
        let sciNotationEnabled = true;
        
        // Auto-Accept Variables
        let autoAcceptThreshold = 0;
        let autoAcceptSecretThresholdValue = 0;
        let autoAcceptOnNewRank = false;
        let autoAcceptTrueRNGValue = 0;
        
        // Auto-Stop Variables
        let autoStopThreshold = 0;
        let autoStopSecretThresholdValue = 0;
        let autoStopOnNewRank = false;
        let autoStopTrueRNGValue = 0;
        
        let bulkRollLevel = 0;
        let bulkRollCost = 50000;
        let isCutscenePlaying = false; 
        
        // NEW: Cutscene state variable 
        let cutscenesEnabled = true; 
        
        // --- EVENT VARIABLES ---
        let currentEvent = null; 
        let eventEndTime = 0;    
        let eventInterval = null;
        let eventCheckChance = 1; 

        // --- SHAPES VARIABLES ---
        let geometrix = 0;
        let shapesUnlocked = false;
        let shapeLuckLevel = 0;
        let shapeLuckCost = 5;
        let luckMultiLevel = 0;
        let luckMultiCost = 100;
        let bulkShapeLevel = 0;
        let bulkShapeCost = 50;
        let shapeInterval = null;
        let activeShapes = [];

        // --- CLICKER VARIABLES ---
        let clickerUnlocked = false;
        let fortunium = 0;
        let fortuniumLuck = 0;
        
        let gmxMultiLevel = 0;
        let gmxMultiCost = 75;
        
        let fortuniumLuckLevel = 0;
        let fortuniumLuckCost = 125;
        
        let clickerLuckLevel = 0;
        let clickerLuckCost = 1000;

        // --- EUPHORIA EFFECT ---
        let activeEuphoriaIntervals = {};

        // --- Bewilderment animation intervals ---
        let activeBewildermentIntervals = {};

        // --- Animation preservation tracking ---
        let activeAnimationElements = new Set();
        
        // --- BOOSTER SYSTEM ---
        let boosters = [];
        let activeBooster = null;
        let shopBoosters = [];
        let shopAutoRefreshInterval = null;

        // --- NEW: Variant Secrets ---
        let discoveredVariantSecrets = new Set();

        // --- OPTIMIZATION: CALCULATED STATS ---
        let currentLuck = 0;
        let secretLuckMultiplier = 1;
        let variantChanceMultiplier = 1;

        // --- CALCULATED STATS ---
        let luckMultiValue = 1;
        let shapeLuckBonus = 0;
        let currentShapeCooldown = SHAPE_SPAWN_INTERVAL_MS;

        // --- UTILITY FUNCTIONS ---
        function formatInteger(num) {
            return num.toLocaleString('en-US');
        }

        function formatNumber(num) {
            if (calisrng2.ruin) return "Lol";
            
            if (num < 0) {
                return "-" + formatNumber(Math.abs(num));
            }
            
            if (sciNotationEnabled && Math.abs(num) >= sciNotationThreshold) {
                return num.toExponential(2);
            }
            
            return num.toLocaleString('en-US', { 
                minimumFractionDigits: 2, 
                maximumFractionDigits: 2 
            });
        }
        
        function formatGeometrix(num) {
            if (calisrng2.ruin) return "Lol";
            
            if (sciNotationEnabled && Math.abs(num) >= sciNotationThreshold) {
                return num.toExponential(2);
            }
            return num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }
        
        function formatCooldown(ms) {
            if (calisrng2.ruin) return "Lol";
            return (ms / 1000).toFixed(4);
        }

        function escapeHTML(str) {
            if (!str) return '';
            return str.replace(/'/g, "\\'");
        }

        // --- FIXED SHOP FUNCTIONS ---
        
        function generateShapeHTML(shape, color, luck, variant) {
            const size = 60;
            const centerLuck = luck.toFixed(2);
            
            const hexToRgb = (hex) => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 255, g: 255, b: 255 };
            };
            
            const darkenColor = (hex, amount = 0.4) => {
                const rgb = hexToRgb(hex);
                const r = Math.max(0, Math.floor(rgb.r * (1 - amount)));
                const g = Math.max(0, Math.floor(rgb.g * (1 - amount)));
                const b = Math.max(0, Math.floor(rgb.b * (1 - amount)));
                return `rgb(${r},${g},${b})`;
            };
            
            const darkColor = darkenColor(color);
            const gradientId = `grad-${Math.random().toString(36).substr(2, 9)}`;
            
            let svg = '';
            if (shape === 'circle') {
                svg = `<svg width="${size}" height="${size}" viewBox="0 0 60 60">
                    <defs>
                        <linearGradient id="${gradientId}" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:${color};stop-opacity:1" />
                            <stop offset="100%" style="stop-color:${darkColor};stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <circle cx="30" cy="30" r="25" fill="url(#${gradientId})" stroke="#FFD700" stroke-width="2"/>
                    <text x="30" y="35" text-anchor="middle" fill="white" stroke="black" stroke-width="0.5" font-size="14" font-weight="bold">${centerLuck}</text>
                </svg>`;
            } else if (shape === 'triangle') {
                svg = `<svg width="${size}" height="${size}" viewBox="0 0 60 60">
                    <defs>
                        <linearGradient id="${gradientId}" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:${color};stop-opacity:1" />
                            <stop offset="100%" style="stop-color:${darkColor};stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <polygon points="30,10 50,45 10,45" fill="url(#${gradientId})" stroke="#FFD700" stroke-width="2"/>
                    <text x="30" y="37" text-anchor="middle" fill="white" stroke="black" stroke-width="0.5" font-size="14" font-weight="bold">${centerLuck}</text>
                </svg>`;
            } else if (shape === 'square') {
                svg = `<svg width="${size}" height="${size}" viewBox="0 0 60 60">
                    <defs>
                        <linearGradient id="${gradientId}" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:${color};stop-opacity:1" />
                            <stop offset="100%" style="stop-color:${darkColor};stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <rect x="12" y="12" width="36" height="36" fill="url(#${gradientId})" stroke="#FFD700" stroke-width="2"/>
                    <text x="30" y="35" text-anchor="middle" fill="white" stroke="black" stroke-width="0.5" font-size="14" font-weight="bold">${centerLuck}</text>
                </svg>`;
            } else if (shape === 'pentagon') {
                svg = `<svg width="${size}" height="${size}" viewBox="0 0 60 60">
                    <defs>
                        <linearGradient id="${gradientId}" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:${color};stop-opacity:1" />
                            <stop offset="100%" style="stop-color:${darkColor};stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <polygon points="30,8 52,22 43,44 17,44 8,22" fill="url(#${gradientId})" stroke="#FFD700" stroke-width="2"/>
                    <text x="30" y="35" text-anchor="middle" fill="white" stroke="black" stroke-width="0.5" font-size="14" font-weight="bold">${centerLuck}</text>
                </svg>`;
            } else if (shape === 'hexagon') {
                svg = `<svg width="${size}" height="${size}" viewBox="0 0 60 60">
                    <defs>
                        <linearGradient id="${gradientId}" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:${color};stop-opacity:1" />
                            <stop offset="100%" style="stop-color:${darkColor};stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <polygon points="30,8 52,18 52,40 30,50 8,40 8,18" fill="url(#${gradientId})" stroke="#FFD700" stroke-width="2"/>
                    <text x="30" y="35" text-anchor="middle" fill="white" stroke="black" stroke-width="0.5" font-size="14" font-weight="bold">${centerLuck}</text>
                </svg>`;
            } else if (shape === 'heptagon') {
                svg = `<svg width="${size}" height="${size}" viewBox="0 0 60 60">
                    <defs>
                        <linearGradient id="${gradientId}" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:${color};stop-opacity:1" />
                            <stop offset="100%" style="stop-color:${darkColor};stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <polygon points="30,6 50,14 55,34 43,50 17,50 5,34 10,14" fill="url(#${gradientId})" stroke="#FFD700" stroke-width="2"/>
                    <text x="30" y="35" text-anchor="middle" fill="white" stroke="black" stroke-width="0.5" font-size="14" font-weight="bold">${centerLuck}</text>
                </svg>`;
            }
            
            return svg + (variant ? `<div style="font-size: 11px; color: ${variant.color || '#FFD700'}; margin-top: 3px; font-weight: bold;">${variant.name}</div>` : '');
        }
        
        // --- NEW DEBUG FUNCTIONS ---
        
        function nukeShopData() {
            if (!confirm("This will reset ALL shop data, including owned boosters and shop inventory. Continue?")) return;
            
            boosters = [];
            activeBooster = null;
            shopBoosters = [];
            
            // Also reset shop refresh timing
            shopLastRefresh = 0;
            
            // Clear any existing shop auto-refresh interval
            if (shopAutoRefreshInterval) {
                clearInterval(shopAutoRefreshInterval);
                shopAutoRefreshInterval = null;
            }
            
            // Force immediate shop regeneration when opened
            shopBoosters = [];
            
            addToTerminal("üí£ Shop data COMPLETELY nuked! All boosters, shop inventory, and shop state reset.", true, 'rank-1000000-100000000');
            updateBoosterDisplay();
            
            // Force close shop if open
            const shopPanel = document.getElementById('shop-panel');
            if (shopPanel) {
                shopPanel.style.display = 'none';
            }
            
            // Save the nuked state
            saveGame();
            closeDebugPanel();
        }
        
        function fixSaveFile() {
            if (!confirm("This will attempt to fix common save file issues. Continue?")) return;
            
            try {
                const saved = localStorage.getItem('calisRNGGame');
                if (!saved) {
                    addToTerminal("No save file found to fix.", true);
                    return;
                }
                
                let gameState;
                try {
                    gameState = JSON.parse(saved);
                } catch (e) {
                    addToTerminal("Save file is corrupt. Creating new one...", true, 'rank-1000000-100000000');
                    localStorage.removeItem('calisRNGGame');
                    location.reload();
                    return;
                }
                
                const fixes = [];
                
                if (!Array.isArray(gameState.inventory)) {
                    gameState.inventory = [];
                    fixes.push("Fixed: inventory was not an array");
                }
                
                if (!Array.isArray(gameState.pendingRolls)) {
                    gameState.pendingRolls = [];
                    fixes.push("Fixed: pendingRolls was not an array");
                }
                
                if (!Array.isArray(gameState.boosters)) {
                    gameState.boosters = [];
                    fixes.push("Fixed: boosters was not an array");
                }
                
                if (!Array.isArray(gameState.shopBoosters)) {
                    gameState.shopBoosters = [];
                    fixes.push("Fixed: shopBoosters was not an array");
                }
                
                if (!Array.isArray(gameState.discoveredVariantSecrets)) {
                    gameState.discoveredVariantSecrets = [];
                    fixes.push("Fixed: discoveredVariantSecrets was not an array");
                }
                
                if (typeof gameState.currency !== 'number' || isNaN(gameState.currency)) {
                    gameState.currency = 0;
                    fixes.push("Fixed: currency was invalid");
                }
                
                if (typeof gameState.geometrix !== 'number' || isNaN(gameState.geometrix)) {
                    gameState.geometrix = 0;
                    fixes.push("Fixed: geometrix was invalid");
                }
                
                if (!Array.isArray(gameState.discoveredRanks)) {
                    gameState.discoveredRanks = [];
                    fixes.push("Fixed: discoveredRanks was not an array");
                }
                
                if (!gameState.highestFinalRoll || typeof gameState.highestFinalRoll !== 'object') {
                    gameState.highestFinalRoll = { 
                        value: 0, 
                        baseValue: 0, 
                        rank: 'None yet', 
                        variants: [], 
                        isSecret: false 
                    };
                    fixes.push("Fixed: highestFinalRoll was missing");
                }
                
                // Check all arrays for invalid items
                if (Array.isArray(gameState.inventory)) {
                    const validInventory = [];
                    for (let i = 0; i < gameState.inventory.length; i++) {
                        const item = gameState.inventory[i];
                        if (item && typeof item === 'object' && item.value !== undefined && item.rank) {
                            if (typeof item.value !== 'number' || isNaN(item.value)) {
                                fixes.push(`Fixed: inventory item ${i} had invalid value`);
                                item.value = 0;
                            }
                            if (!Array.isArray(item.variants)) {
                                item.variants = [];
                            }
                            validInventory.push(item);
                        } else {
                            fixes.push(`Removed invalid inventory item ${i}`);
                        }
                    }
                    gameState.inventory = validInventory;
                }
                
                // Check pending rolls
                if (Array.isArray(gameState.pendingRolls)) {
                    const validPending = [];
                    for (let i = 0; i < gameState.pendingRolls.length; i++) {
                        const item = gameState.pendingRolls[i];
                        if (item && typeof item === 'object' && item.value !== undefined && item.rank) {
                            if (typeof item.value !== 'number' || isNaN(item.value)) {
                                fixes.push(`Fixed: pending roll ${i} had invalid value`);
                                item.value = 0;
                            }
                            if (!Array.isArray(item.variants)) {
                                item.variants = [];
                            }
                            validPending.push(item);
                        } else {
                            fixes.push(`Removed invalid pending roll ${i}`);
                        }
                    }
                    gameState.pendingRolls = validPending;
                }
                
                // Check boosters
                if (Array.isArray(gameState.boosters)) {
                    const validBoosters = [];
                    for (let i = 0; i < gameState.boosters.length; i++) {
                        const booster = gameState.boosters[i];
                        if (booster && typeof booster === 'object' && booster.luck !== undefined) {
                            if (typeof booster.luck !== 'number' || isNaN(booster.luck)) {
                                fixes.push(`Fixed: booster ${i} had invalid luck`);
                                booster.luck = BOOSTER_BASE_LUCK;
                            }
                            validBoosters.push(booster);
                        } else {
                            fixes.push(`Removed invalid booster ${i}`);
                        }
                    }
                    gameState.boosters = validBoosters;
                }
                
                // Check shop boosters
                if (Array.isArray(gameState.shopBoosters)) {
                    const validShopBoosters = [];
                    for (let i = 0; i < gameState.shopBoosters.length; i++) {
                        const booster = gameState.shopBoosters[i];
                        if (booster && typeof booster === 'object' && booster.luck !== undefined) {
                            if (typeof booster.luck !== 'number' || isNaN(booster.luck)) {
                                fixes.push(`Fixed: shop booster ${i} had invalid luck`);
                                booster.luck = BOOSTER_BASE_LUCK;
                            }
                            validShopBoosters.push(booster);
                        } else {
                            fixes.push(`Removed invalid shop booster ${i}`);
                        }
                    }
                    gameState.shopBoosters = validShopBoosters;
                }
                
                // Check active shapes
                if (Array.isArray(gameState.activeShapes)) {
                    const validShapes = [];
                    for (let i = 0; i < gameState.activeShapes.length; i++) {
                        const shape = gameState.activeShapes[i];
                        if (shape && typeof shape === 'object' && shape.name) {
                            validShapes.push(shape);
                        } else {
                            fixes.push(`Removed invalid shape ${i}`);
                        }
                    }
                    gameState.activeShapes = validShapes;
                }
                
                // Ensure maxPendingRolls is calculated correctly
                if (!gameState.maxPendingRolls || typeof gameState.maxPendingRolls !== 'number') {
                    gameState.maxPendingRolls = (gameState.maxInventory || 10) * 3;
                    fixes.push("Fixed: maxPendingRolls was invalid");
                }
                
                localStorage.setItem('calisRNGGame', JSON.stringify(gameState));
                
                if (fixes.length > 0) {
                    addToTerminal(`‚úÖ Save file fixed! Applied ${fixes.length} fix(es):`, true, 'rank-1000000-100000000');
                    fixes.forEach(fix => {
                        addToTerminal(`  ‚Ä¢ ${fix}`, true);
                    });
                    addToTerminal("Reloading game...", true);
                    setTimeout(() => location.reload(), 1000);
                } else {
                    addToTerminal("‚úÖ Save file is already healthy. No fixes needed.", true);
                }
                
            } catch (e) {
                console.error('Error fixing save:', e);
                addToTerminal("‚ùå Failed to fix save file. Error: " + e.message, true, 'rank-1000000-100000000');
            }
            
            closeDebugPanel();
        }
        
        function inspectSaveFile() {
            const saved = localStorage.getItem('calisRNGGame');
            
            if (!saved) {
                addToTerminal("No save file found!", true);
                return;
            }
            
            addToTerminal("üîç INSPECTING SAVE FILE...", true, 'rank-1000-10000');
            
            try {
                const gameState = JSON.parse(saved);
                const issues = [];
                const warnings = [];
                const info = [];
                
                const criticalProps = ['currency', 'totalUpgrades', 'inventory', 'discoveredRanks'];
                criticalProps.forEach(prop => {
                    if (!(prop in gameState)) {
                        issues.push(`Missing critical property: ${prop}`);
                    }
                });
                
                if (!Array.isArray(gameState.inventory)) {
                    issues.push("Inventory is not an array");
                }
                
                if (!Array.isArray(gameState.discoveredRanks)) {
                    issues.push("discoveredRanks is not an array");
                }
                
                if (typeof gameState.currency !== 'number') {
                    issues.push("Currency is not a number");
                }
                
                if (typeof gameState.geometrix !== 'number') {
                    issues.push("Geometrix is not a number");
                }
                
                if (isNaN(gameState.currency)) {
                    issues.push("Currency is NaN");
                }
                
                if (isNaN(gameState.geometrix)) {
                    issues.push("Geometrix is NaN");
                }
                
                if (gameState.currency < 0) {
                    warnings.push("Currency is negative");
                }
                
                if (gameState.geometrix < 0) {
                    warnings.push("Geometrix is negative");
                }
                
                // Check inventory items
                if (Array.isArray(gameState.inventory)) {
                    gameState.inventory.forEach((item, idx) => {
                        if (!item || typeof item !== 'object') {
                            issues.push(`Inventory item ${idx} is corrupted`);
                        } else {
                            if (typeof item.value !== 'number' || isNaN(item.value)) {
                                issues.push(`Inventory item ${idx} has invalid value`);
                            }
                            if (!item.rank || typeof item.rank !== 'string') {
                                issues.push(`Inventory item ${idx} has invalid rank`);
                            }
                            if (!Array.isArray(item.variants)) {
                                issues.push(`Inventory item ${idx} has invalid variants array`);
                            }
                        }
                    });
                }
                
                // Check pending rolls
                if (Array.isArray(gameState.pendingRolls)) {
                    gameState.pendingRolls.forEach((item, idx) => {
                        if (!item || typeof item !== 'object') {
                            issues.push(`Pending roll ${idx} is corrupted`);
                        } else {
                            if (typeof item.value !== 'number' || isNaN(item.value)) {
                                issues.push(`Pending roll ${idx} has invalid value`);
                            }
                            if (!item.rank || typeof item.rank !== 'string') {
                                issues.push(`Pending roll ${idx} has invalid rank`);
                            }
                        }
                    });
                }
                
                // Check boosters
                if (Array.isArray(gameState.boosters)) {
                    gameState.boosters.forEach((booster, idx) => {
                        if (!booster || typeof booster !== 'object') {
                            issues.push(`Booster ${idx} is corrupted`);
                        } else {
                            if (typeof booster.luck !== 'number' || isNaN(booster.luck)) {
                                issues.push(`Booster ${idx} has invalid luck`);
                            }
                        }
                    });
                }
                
                // Check shop boosters
                if (Array.isArray(gameState.shopBoosters)) {
                    gameState.shopBoosters.forEach((booster, idx) => {
                        if (!booster || typeof booster !== 'object') {
                            issues.push(`Shop booster ${idx} is corrupted`);
                        } else {
                            if (typeof booster.luck !== 'number' || isNaN(booster.luck)) {
                                issues.push(`Shop booster ${idx} has invalid luck`);
                            }
                        }
                    });
                }
                
                // Check active shapes
                if (Array.isArray(gameState.activeShapes)) {
                    gameState.activeShapes.forEach((shape, idx) => {
                        if (!shape || typeof shape !== 'object') {
                            issues.push(`Active shape ${idx} is corrupted`);
                        }
                    });
                }
                
                // Check discovered variant secrets
                if (!Array.isArray(gameState.discoveredVariantSecrets)) {
                    issues.push("discoveredVariantSecrets is not an array");
                }
                
                info.push(`Currency: ${gameState.currency || 0}`);
                info.push(`Geometrix: ${gameState.geometrix || 0}`);
                info.push(`Upgrades: ${gameState.totalUpgrades || 0}`);
                info.push(`Inventory size: ${gameState.inventory ? gameState.inventory.length : 0}`);
                info.push(`Discovered ranks: ${gameState.discoveredRanks ? gameState.discoveredRanks.length : 0}`);
                info.push(`Discovered variant secrets: ${gameState.discoveredVariantSecrets ? gameState.discoveredVariantSecrets.length : 0}`);
                info.push(`Boosters owned: ${gameState.boosters ? gameState.boosters.length : 0}`);
                info.push(`Shop inventory: ${gameState.shopBoosters ? gameState.shopBoosters.length : 0}`);
                info.push(`Active shapes: ${gameState.activeShapes ? gameState.activeShapes.length : 0}`);
                info.push(`Pending rolls: ${gameState.pendingRolls ? gameState.pendingRolls.length : 0}`);
                info.push(`Hardcore mode: ${gameState.hardcoreMode ? 'ON' : 'OFF'}`);
                info.push(`Secrets enabled: ${gameState.secretsEnabled !== false ? 'Yes' : 'No'}`);
                info.push(`Cutscenes enabled: ${gameState.cutscenesEnabled !== false ? 'Yes' : 'No'}`);
                
                if (issues.length > 0) {
                    addToTerminal("‚ùå ISSUES FOUND:", true, 'rank-1000000-100000000');
                    issues.forEach(issue => {
                        addToTerminal(`  ‚Ä¢ ${issue}`, true);
                    });
                } else {
                    addToTerminal("‚úÖ No critical issues found", true, 'rank-1000-10000');
                }
                
                if (warnings.length > 0) {
                    addToTerminal("‚ö†Ô∏è WARNINGS:", true, 'rank-1000-10000');
                    warnings.forEach(warning => {
                        addToTerminal(`  ‚Ä¢ ${warning}`, true);
                    });
                }
                
                addToTerminal("üìä SAVE FILE INFO:", true, 'rank-1000-10000');
                info.forEach(line => {
                    addToTerminal(`  ${line}`, true);
                });
                
                if (issues.length > 0) {
                    addToTerminal("üí° Run 'Fix Save File' to attempt to repair these issues.", true);
                }
                
            } catch (e) {
                addToTerminal(`‚ùå ERROR PARSING SAVE FILE: ${e.message}`, true, 'rank-1000000-100000000');
                addToTerminal("The save file appears to be corrupt.", true);
            }
            
            closeDebugPanel();
        }

        // --- EXISTING DEBUG FUNCTIONS ---
        
        function openDebugPanel() {
            document.getElementById('debug-panel').style.display = 'block';
            document.getElementById('debug-password-input').value = '';
            document.getElementById('debug-commands').style.display = 'none';
        }

        function closeDebugPanel() {
            document.getElementById('debug-panel').style.display = 'none';
            document.getElementById('debug-password-input').value = '';
            document.getElementById('debug-commands').style.display = 'none';
            addToTerminal('Debug panel closed.', true);
        }

        function checkDebugPassword() {
            const input = document.getElementById('debug-password-input').value;
            if (input === DEBUG_PASSWORD) {
                document.getElementById('debug-commands').style.display = 'block';
                addToTerminal('Debug panel unlocked! Use with caution!', true, 'rank-1000000-100000000');
            } else if (input.toLowerCase() === 'no') {
                closeDebugPanel();
            } else {
                alert('Incorrect password! Type "no" to close the debug panel.');
            }
        }

        function resetEventsDebug() {
            if (!confirm("This will reset all events. Are you sure?")) return;
            
            if (currentEvent && currentEvent.timeoutId) {
                clearTimeout(currentEvent.timeoutId);
            }
            
            currentEvent = null;
            eventEndTime = 0;
            eventCheckChance = 1;
            
            if (eventInterval) {
                clearInterval(eventInterval);
            }
            
            startEventLoop();
            addToTerminal('Events have been reset. Event system restarted.', true, 'rank-1000-10000');
            closeDebugPanel();
        }

        function resetSaveDebug() {
            let confirmCount = 0;
            const confirmMessages = [
                "Are you REALLY sure? This will delete ALL your progress!",
                "This is your second warning! Are you sure?",
                "Third warning! This cannot be undone!",
                "Fourth warning! You will lose everything!",
                "FINAL WARNING! Type 'I am sure' to reset your save."
            ];

            function askConfirmation() {
                if (confirmCount < 4) {
                    if (confirm(confirmMessages[confirmCount])) {
                        confirmCount++;
                        askConfirmation();
                    }
                } else {
                    const userInput = prompt(confirmMessages[4]);
                    if (userInput === 'I am sure') {
                        localStorage.removeItem('calisRNGGame');
                        localStorage.removeItem('calisRNG_UI');
                        
                        if (autoRollInterval) clearInterval(autoRollInterval);
                        if (eventInterval) clearInterval(eventInterval);
                        if (shapeInterval) clearInterval(shapeInterval);
                        if (currentEvent && currentEvent.timeoutId) clearTimeout(currentEvent.timeoutId);
                        for (const id in activeEuphoriaIntervals) {
                            clearInterval(activeEuphoriaIntervals[id]);
                        }
                        for (const id in activeBewildermentIntervals) {
                            clearInterval(activeBewildermentIntervals[id]);
                        }
                        
                        addToTerminal('Save completely reset! Reloading game...', true, 'rank-1000000000-10000000000');
                        
                        setTimeout(() => {
                            location.reload();
                        }, 1000);
                    } else {
                        alert('Save reset cancelled.');
                        closeDebugPanel();
                    }
                }
            }

            askConfirmation();
        }

        function toggleForceRollUI() {
            const ui = document.getElementById('force-roll-ui');
            if (ui) {
                ui.style.display = ui.style.display === 'none' ? 'block' : 'none';
            }
        }

        function executeCustomForceRoll() {
            const luck = parseFloat(document.getElementById('forceRollLuck').value) || 0;
            const variantLuck = parseFloat(document.getElementById('forceRollVariantLuck').value) || 0;
            const secretLuck = parseFloat(document.getElementById('forceRollSecretLuck').value) || 0;
            
            const customLuck = currentLuck + luck + variantLuck;
            const baseRoll = Math.pow(Math.random(), 3 / POWER_EXPONENT) * (1 + customLuck);
            
            const variantResult = getVariants(baseRoll);
            let displayValue = variantResult ? variantResult.modifiedValue : baseRoll;
            const variants = variantResult ? variantResult.variants : [];
            
            let secretResult = null;
            if (secretsEnabled) {
                const originalSecretMultiplier = secretLuckMultiplier;
                secretLuckMultiplier = Math.max(1, secretLuckMultiplier + secretLuck);
                secretResult = getSecretRank();
                secretLuckMultiplier = originalSecretMultiplier;
            }
            let rankInfo = getRankInfo(baseRoll);
            let displayName = secretResult ? secretResult.name : rankInfo.name;
            
            if (rankInfo.isUnobtainable) {
                displayName = hardcoreMode ? "Unobtainable [HC]" : "Unobtainable";
                displayValue = rankInfo.value;
            }
            
            if (secretResult && secretResult.rarity) {
                displayValue *= secretResult.rarity;
            }
            
            if (displayName === "CORRUPTED") {
                displayValue *= -1;
            }
            if (displayName === "Destroyed") {
                displayValue = 0;
            }
            
            const { className: rankClass, color: rollColor } = getRankClassAndColor(displayValue, variants, displayName);
            
            let variantText = '';
            if (variants.length > 0) {
                variantText = variants.map(v => {
                    let variantClass = '';
                    if (v.name === "GIANT") variantClass = 'variant-GIANT';
                    else if (v.name === "Mega") variantClass = 'variant-Mega';
                    else if (v.name === "Small") variantClass = 'variant-Small';
                    
                    return `<span class="${variantClass}" style="color: ${v.color}; font-weight: bold;">[${v.name}]</span>`;
                }).join('') + ' ';
            }
            
            const debugTag = '<span style="color: #ffaa00; font-weight: bold;">[CUSTOM]</span>';
            
            const content = `<span class="${rankClass} illegitimate-roll" style="color: ${rollColor};">${formatNumber(displayValue)} [${displayName}] ${debugTag}</span>`;
            
            addToTerminal(
                `#${formatInteger(rollIndex++)} (CUSTOM): L${luck} VL${variantLuck} SL${secretLuck} | ${variantText}${content} (No currency, no discovery)`
            );
            
            toggleForceRollUI();
        }

        // --- VARIANT SECRETS FUNCTIONS ---
        
        function getVariantSecret(rankName, variants) {
            if (variants.length === 0) return null;
            
            for (const secret of VARIANT_SECRETS) {
                if (rankName === secret.needsRank || 
                    (hardcoreMode && rankName === `${secret.needsRank} [HC]`)) {
                    
                    const hasRequiredVariant = variants.some(v => v.name === secret.needsVariant);
                    
                    if (hasRequiredVariant) {
                        if (Math.random() < secret.chance) {
                            return secret;
                        }
                    }
                }
            }
            
            return null;
        }

        // --- MODIFIED ROLL FUNCTION WITH ALL FIXES ---
        
        async function roll() {
            if (calisrng2.ruin) {
                addToTerminal('Lol Lol Lol', true);
                return;
            }
            
            if (isCutscenePlaying) {
                addToTerminal('Wait for the cutscene to finish!', true);
                return;
            }
            
            if (activeBooster) {
                const boosterLuck = activeBooster.luck;
                currentLuck += boosterLuck;
                addToTerminal(`Booster applied! +${boosterLuck.toFixed(2)} luck`, true);
                activeBooster = null;
            }
            
            const rollResults = [];
            let maxRollValueInBulk = 0;
            let isMaxRollSecret = false;
            let newRankDiscoveredInBulk = false;
            
            const bulkAmount = hardcoreMode ? 1 : (bulkRollLevel + 1);
            
            for (let i = 0; i < bulkAmount; i++) {
                const complexResult = generateComplexRank();
                
                if (complexResult) {
                    const baseValue = complexResult.realPart;
                    const variantResult = getVariants(baseValue);
                    
                    const displayValue = {
                        real: complexResult.realPart,
                        imag: complexResult.imagPart
                    };
                    
                    const variants = variantResult ? variantResult.variants : [];
                    
                    const displayName = complexResult.displayName;
                    const isSecret = false;
                    
                    rollResults.push({ 
                        baseValue: baseValue, 
                        displayValue: displayValue, 
                        complexValue: true,
                        variants, 
                        displayName, 
                        isSecret, 
                        secretRarityMultiplier: 1,
                        rankInfo: { name: displayName, rankNum: 999, isUnobtainable: false },
                        isComplex: true,
                        complexData: complexResult
                    });
                    
                    const magnitude = Math.sqrt(complexResult.realPart**2 + complexResult.imagPart**2);
                    if (magnitude > maxRollValueInBulk) {
                        maxRollValueInBulk = magnitude;
                        isMaxRollSecret = isSecret;
                    }
                    
                    continue;
                }
                
                const rollResult = generateRoll();
                let baseValue = rollResult.value;
                
                let isGrandRoll = baseValue >= 1e6 && baseValue < 1e7;
                let shouldCheck7GrandDad = isGrandRoll && Math.random() < (1/777.777);

                if (shouldCheck7GrandDad && currentEvent && currentEvent.name === "Lol") {
                    shouldCheck7GrandDad = Math.random() < (1/777.777) * currentEvent.multiplier;
                }
                
                const variantResult = getVariants(baseValue);
                let displayValue = variantResult ? variantResult.modifiedValue : baseValue;
                const variants = variantResult ? variantResult.variants : [];
                
                // CHECK FOR VARIANT SECRET HERE
                let variantSecretResult = null;
                if (variants.length > 0) {
                    const rankInfoTemp = getRankInfo(baseValue);
                    variantSecretResult = getVariantSecret(rankInfoTemp.name, variants);
                }
                
                if (shouldCheck7GrandDad) {
                    const sevenGrandDad = {
                        name: "7 GRAND DAD",
                        chance: 1/777.777,
                        rarity: 777.777,
                        multiplier: 7777777
                    };
                    
                    displayValue *= sevenGrandDad.multiplier;
                    
                    rollResults.push({ 
                        baseValue, 
                        displayValue, 
                        variants, 
                        displayName: "7 GRAND DAD", 
                        isSecret: true, 
                        secretRarityMultiplier: sevenGrandDad.multiplier,
                        rankInfo: { name: "7 GRAND DAD", rankNum: 999, isUnobtainable: false },
                        isComplex: false,
                        variantSecret: variantSecretResult
                    });
                    
                    if (displayValue > maxRollValueInBulk) {
                        maxRollValueInBulk = displayValue;
                        isMaxRollSecret = true;
                    }
                    
                    const baseRankName = "7 GRAND DAD";
                    if (!discoveredRanks.has(baseRankName)) {
                        newRankDiscoveredInBulk = true;
                    }
                    
                    continue;
                }
                
                const secretResult = getSecretRank(); 
                let rankInfo = getRankInfo(baseValue);
                let displayName = secretResult ? secretResult.name : rankInfo.name;
                const isSecret = !!secretResult;
                
                if (displayName === "CATASTROPHIC" && secretResult.multiplier) {
                    displayValue *= secretResult.multiplier;
                }
                
                if (rankInfo.isUnobtainable) {
                    displayName = hardcoreMode ? "Unobtainable [HC]" : "Unobtainable";
                    displayValue = rankInfo.value;
                }
                
                if (displayName === "LEGACY In im table ?!?!?" && secretResult.multiplier) {
                    displayValue *= secretResult.multiplier;
                }
                
                let secretRarityMultiplier = 1;
                if (isSecret) {
                    if (secretResult.rarity) {
                        secretRarityMultiplier = secretResult.rarity;
                        displayValue *= secretRarityMultiplier;
                    } else {
                        displayValue = 0; 
                    }
                }
                
                if (displayName === "CORRUPTED") {
                    displayValue *= -1;
                }
                
                if (displayName === "Destroyed") {
                    displayValue = 0;
                }
                
                // Apply variant secret multiplier if found
                if (variantSecretResult) {
                    displayValue *= variantSecretResult.multipliesRNG;
                }
                
                rollResults.push({ 
                    baseValue, 
                    displayValue, 
                    variants, 
                    displayName, 
                    isSecret, 
                    secretRarityMultiplier,
                    rankInfo,
                    isComplex: false,
                    variantSecret: variantSecretResult
                });
                
                if (displayValue > maxRollValueInBulk) {
                    maxRollValueInBulk = displayValue;
                    isMaxRollSecret = isSecret;
                }
                
                const baseRankName = displayName.replace(" [HC]", "");
                if (!discoveredRanks.has(baseRankName)) {
                    newRankDiscoveredInBulk = true;
                }
            }
            
            if (cutscenesEnabled && maxRollValueInBulk >= 1e9 && !hardcoreMode) {
                await playCutscene(maxRollValueInBulk, isMaxRollSecret);
            }
            
            for (const rollData of rollResults) {
                let { baseValue, displayValue, complexValue, variants, displayName, isSecret, secretRarityMultiplier, rankInfo, isComplex, complexData, variantSecret } = rollData;
                
                const currencyGain = (Math.pow(baseValue / 75, 0.75)) / 1.5;
                
                const { className: rankClassBase, color: rollColorBase } = getRankClassAndColor(
                    typeof displayValue === 'object' ? Math.sqrt(displayValue.real**2 + displayValue.imag**2) : displayValue, 
                    variants, 
                    displayName
                );

                let rankClass = rankClassBase;
                let rollColor = rollColorBase;

                if (displayName === "CORRUPTED") {
                    rankClass += " secret-corrupted";
                    rollColor = "#FFFFFF"; 
                }
                
                if (isComplex) {
                    rankClass = "rank-complex";
                }

                let suffix = "";
                let finalDisplayValue = displayValue;
                
                if (displayName === "100") suffix = ` * üíØ`;
                if (displayName === ":[{(absolute zero)}]:") suffix = ` * 0`;
                
                if (displayName === "‚õßSatanic‚õß") {
                    suffix = ` (Actual: ${formatNumber(displayValue)})`;
                    finalDisplayValue = -666.66;
                    rankClass = "rank-1000000-100000000";
                    rollColor = "#ff0000";
                }
                if (displayName === "Finale.. wait, how'd this get here?") {
                    suffix = ` (Actual: ${formatNumber(displayValue)})`;
                    finalDisplayValue = 1e10; 
                    rankClass = getRankClass(1e10);
                    rollColor = getRankClassAndColor(1e10).color;
                }
                
                const secretMultiplierText = (isSecret && secretRarityMultiplier > 1) ? ` (x${formatNumber(secretRarityMultiplier)})` : '';

                if (displayName === "~Nonavacious~") {
                    rankClass += " secret-nonavacious";
                }
                
                if (displayName === "Poly") {
                    rankClass = `poly-dodecahedron-wrapper ${rankClass}`;
                }
                
                const currentIndex = rollIndex++;
                
                let newRankDiscovered = false;
                const baseRankName = displayName.replace(" [HC]", "");
                if (!discoveredRanks.has(baseRankName)) {
                    discoveredRanks.add(baseRankName);
                    addToTerminal(`üéâ NEW RANK DISCOVERED: ${displayName}!`, true);
                    updateIndexDisplay();
                    newRankDiscovered = true;
                }
                
                // Handle variant secret discovery
                if (variantSecret && !discoveredVariantSecrets.has(variantSecret.name)) {
                    discoveredVariantSecrets.add(variantSecret.name);
                    addToTerminal(`üéâ NEW VARIANT SECRET DISCOVERED: ${variantSecret.name}! (${variantSecret.needsRank} + ${variantSecret.needsVariant})`, true, 'rank-10000-100000');
                    updateIndexDisplay();
                    updateStats();
                }
                
                currency += currencyGain;
                
                if (baseValue > highestBaseRoll) {
                    highestBaseRoll = baseValue;
                }

                if ((displayName !== "CORRUPTED" && displayValue > highestFinalRoll.value) || 
                    (displayName === "CORRUPTED" && (highestFinalRoll.rank !== "CORRUPTED" || displayValue < highestFinalRoll.value))) {
                    highestFinalRoll = {
                        value: displayValue,
                        baseValue: baseValue,
                        rank: displayName,
                        variants: variants,
                        isSecret: isSecret,
                        variantSecret: variantSecret
                    };
                }
                
                // AUTO-ACCEPT LOGIC
                const shouldAcceptOnValue = autoAcceptThreshold > 0 && displayValue >= autoAcceptThreshold;
                const shouldAcceptOnSecret = autoAcceptSecretThresholdValue > 0 && isSecret && secretRarityMultiplier >= autoAcceptSecretThresholdValue;
                const shouldAcceptOnNew = autoAcceptOnNewRank && newRankDiscovered;
                const shouldAcceptOnTrueRNG = autoAcceptTrueRNGValue > 0 && baseValue >= autoAcceptTrueRNGValue;
                const shouldAcceptCorrupted = displayName === "CORRUPTED" && (autoAcceptSecretThresholdValue > 0 || autoAcceptThreshold > 0);
                
                // AUTO-STOP LOGIC
                const shouldStopOnValue = autoStopThreshold > 0 && displayValue >= autoStopThreshold;
                const shouldStopOnSecret = autoStopSecretThresholdValue > 0 && isSecret && secretRarityMultiplier >= autoStopSecretThresholdValue;
                const shouldStopOnNew = autoStopOnNewRank && newRankDiscovered;
                const shouldStopOnTrueRNG = autoStopTrueRNGValue > 0 && baseValue >= autoStopTrueRNGValue;
                const shouldStopCorrupted = displayName === "CORRUPTED" && (autoStopSecretThresholdValue > 0 || autoStopThreshold > 0);
                
                let variantText = '';
                if (variants.length > 0) {
                    variantText = variants.map(v => {
                        let variantClass = '';
                        if (v.name === "GIANT") variantClass = 'variant-GIANT';
                        else if (v.name === "Mega") variantClass = 'variant-Mega';
                        else if (v.name === "Small") variantClass = 'variant-Small';
                        
                        return `<span class="${variantClass}" style="color: ${v.color}; font-weight: bold;">[${v.name}]</span>`;
                    }).join('') + ' ';
                }
                
                const variantDataAttr = variants.length > 0 ? `data-variants='${JSON.stringify(variants)}'` : '';
                const baseValueAttr = `data-basevalue='${baseValue}'`;
                const dataTextAttr = `data-text='${escapeHTML(displayName)}'`;
                
                let content = '';
                
                if (isComplex) {
                    const realFormatted = formatNumber(complexData.realPart);
                    const imagFormatted = formatNumber(complexData.imagPart);
                    content = `<span class="clickable-roll ${rankClass}" style="color: ${rollColor};" onclick="tryAddToInventory(${displayValue}, '${escapeHTML(displayName)}', ${currentIndex}, this)" id="roll-${currentIndex}" ${variantDataAttr} ${baseValueAttr} ${dataTextAttr}>${realFormatted} + ${imagFormatted}i [${displayName}]${secretMultiplierText}${suffix}</span>`;
                } else {
                    let variantSecretBadge = '';
                    if (variantSecret) {
                        variantSecretBadge = ` <span class="variant-secret-badge" title="${variantSecret.needsRank} + ${variantSecret.needsVariant}">${variantSecret.name}</span>`;
                    }
                    
                    content = `<span class="clickable-roll ${rankClass}" style="color: ${rollColor};" onclick="tryAddToInventory(${displayValue}, '${escapeHTML(displayName)}', ${currentIndex}, this)" id="roll-${currentIndex}" ${variantDataAttr} ${baseValueAttr} ${dataTextAttr}>${formatNumber(finalDisplayValue)} [${displayName}]${secretMultiplierText}${suffix}${variantSecretBadge}</span>`;
                }
                
                if (displayName === "‚õßSatanic‚õß") {
                    content = `<span class="satanic-wrapper">${content}</span>`;
                }

                addToTerminal(
                    `#${formatInteger(currentIndex)}: ${variantText}${content} (+${currencyGain.toFixed(2)} currency)`
                );

                if (displayName === "?!? bewilderment ?!?") {
                    setTimeout(() => initBewildermentAnimation(`roll-${currentIndex}`), 100);
                }
                
                if (displayName === "!! EUPHORIA !!") {
                    initEuphoriaAnimation(`roll-${currentIndex}`, "!! EUPHORIA !!");
                }
                
                if (isComplex) {
                    activeAnimationElements.add(`roll-${currentIndex}`);
                }

                // AUTO-ACCEPT Logic
                if (autoRollInterval && (shouldAcceptOnValue || shouldAcceptOnSecret || shouldAcceptOnNew || shouldAcceptOnTrueRNG || shouldAcceptCorrupted)) {
                    
                    const rollElement = document.getElementById(`roll-${currentIndex}`);
                    
                    if (!acceptedRolls.has(currentIndex)) {
                        if (inventory.length >= maxInventory) {
                            if (addToPendingRolls(displayValue, displayName, currentIndex, variants, baseValue)) {
                                acceptedRolls.add(currentIndex);
                                
                                if (activeEuphoriaIntervals[currentIndex]) {
                                    clearInterval(activeEuphoriaIntervals[currentIndex]);
                                    delete activeEuphoriaIntervals[currentIndex];
                                }
                                
                                if (activeBewildermentIntervals[`roll-${currentIndex}`]) {
                                    clearInterval(activeBewildermentIntervals[`roll-${currentIndex}`]);
                                    delete activeBewildermentIntervals[`roll-${currentIndex}`];
                                }
                                
                                let acceptSuffix = "";
                                if (displayName === "‚õßSatanic‚õß") acceptSuffix = ` (Actual: ${formatNumber(displayValue)})`;
                                if (displayName === "Finale.. wait, how'd this get here?") acceptSuffix = ` (Actual: ${formatNumber(displayValue)})`;
                                
                                addToTerminal(`Auto-Accepted to pending: #${formatInteger(currentIndex)} ${variantText}${formatNumber(finalDisplayValue)} [${displayName}]${acceptSuffix}`, true, 'rank-1000-10000');
                                
                                if (rollElement) {
                                    rollElement.style.opacity = '0.5';
                                    rollElement.style.cursor = 'not-allowed';
                                    rollElement.onclick = null;
                                }
                                
                                saveGame();
                            }
                        } else {
                            if (addToInventory(displayValue, displayName, currentIndex, variants, baseValue)) {
                                acceptedRolls.add(currentIndex);
                                
                                if (activeEuphoriaIntervals[currentIndex]) {
                                    clearInterval(activeEuphoriaIntervals[currentIndex]);
                                    delete activeEuphoriaIntervals[currentIndex];
                                }
                                
                                if (activeBewildermentIntervals[`roll-${currentIndex}`]) {
                                    clearInterval(activeBewildermentIntervals[`roll-${currentIndex}`]);
                                    delete activeBewildermentIntervals[`roll-${currentIndex}`];
                                }
                                
                                let acceptSuffix = "";
                                if (displayName === "‚õßSatanic‚õß") acceptSuffix = ` (Actual: ${formatNumber(displayValue)})`;
                                if (displayName === "Finale.. wait, how'd this get here?") acceptSuffix = ` (Actual: ${formatNumber(displayValue)})`;
                                
                                addToTerminal(`Auto-Accepted: #${formatInteger(currentIndex)} ${variantText}${formatNumber(finalDisplayValue)} [${displayName}]${acceptSuffix}`, true, 'rank-1000-10000');
                                
                                if (rollElement) {
                                    rollElement.style.opacity = '0.5';
                                    rollElement.style.cursor = 'not-allowed';
                                    rollElement.onclick = null;
                                }
                                
                                saveGame();
                            }
                        }
                    }
                }
                
                // AUTO-STOP Logic
                if (autoRollInterval && (shouldStopOnValue || shouldStopOnSecret || shouldStopOnNew || shouldStopOnTrueRNG || shouldStopCorrupted)) {
                    toggleAutoRoll();
                    addToTerminal(`Auto-roll STOPPED by stop condition: #${formatInteger(currentIndex)} ${variantText}${formatNumber(finalDisplayValue)} [${displayName}]`, true, 'rank-1000000-100000000');
                    break;
                }
            }
            
            updateStats();
            preserveAnimations();
            saveGame();
        }

        // --- MODIFIED INDEX DISPLAY ---
        
        function updateIndexDisplay() {
            const indexContent = document.getElementById('indexContent');
            
            const sortedNormalRanks = [...RANK_TIERS].sort((a, b) => a.min - b.min);
            const sortedSecretRanks = [...SECRET_RANKS_CHANCES].sort((a, b) => a.chance - b.chance);
            
            let html = '<div style="margin-bottom: 15px;"><strong>Normal Ranks:</strong></div>';
            
            sortedNormalRanks.forEach(tier => {
                const discovered = discoveredRanks.has(tier.name) || discoveredRanks.has(tier.name + " [HC]");
                let rankClass = getRankClass((tier.min + tier.max) / 2); 
                if (tier.name === "Improbable") {
                    rankClass = "rank-improbable";
                }
                html += `<div class="index-item ${discovered ? 'discovered' : 'locked'}">
                    ${discovered ? `<span class="${rankClass}">${tier.name}</span>` : '???'}
                </div>`;
            });
            
            const unobtainableDiscovered = discoveredRanks.has("Unobtainable") || discoveredRanks.has("Unobtainable [HC]");
            html += `<div class="index-item ${unobtainableDiscovered ? 'discovered' : 'locked'}">
                ${unobtainableDiscovered ? `<span class="rank-unobtainable">Unobtainable</span>` : '???'}
            </div>`;
            
            html += '<div style="margin: 15px 0;"><strong>Secret Ranks:</strong></div>';
            
            sortedSecretRanks.forEach(rankInfo => {
                const rankName = rankInfo.name;
                if (rankInfo.timeBased) return;
                
                const discovered = discoveredRanks.has(rankName);
                let rankStyle = `color: #ff69b4;`;
                
                if (rankName === "CORRUPTED") {
                    rankStyle = `color: #ffffff; filter: invert(100%); display: inline-block;`;
                }
                
                html += `<div class="index-item ${discovered ? 'discovered' : 'locked'}">
                    ${discovered ? `<span style="${rankStyle}">${rankName}</span>` : '???'}
                </div>`;
            });
            
            const breaktimeDiscovered = discoveredRanks.has("breaktime");
            html += `<div class="index-item ${breaktimeDiscovered ? 'discovered' : 'locked'}">
                ${breaktimeDiscovered ? `<span style="color: #ff69b4;">breaktime</span>` : '???'}
            </div>`;

            const mortsLuckDiscovered = discoveredRanks.has("morts luck");
            const mortsLuckStyle = `color: #ff0000; font-weight: bold;`;
            html += `<div class="index-item ${mortsLuckDiscovered ? 'discovered' : 'locked'}">
                ${mortsLuckDiscovered ? `<span style="${mortsLuckStyle}">morts luck</span>` : '???'}
            </div>`;
            
            // NEW: Variant Secrets Section
            html += '<div class="variant-secrets-section">';
            html += '<div style="margin: 15px 0;"><strong>Variant Secrets:</strong></div>';
            
            const sortedVariantSecrets = [...VARIANT_SECRETS].sort((a, b) => a.rarity - b.rarity);
            
            sortedVariantSecrets.forEach(secret => {
                const discovered = discoveredVariantSecrets.has(secret.name);
                html += `<div class="variant-secret-item ${discovered ? 'discovered' : 'locked'}">
                    ${discovered ? 
                        `<span style="color: #00ffff;">${secret.name}</span> (${secret.needsRank} + ${secret.needsVariant})` : 
                        '???'
                    }
                </div>`;
            });
            
            html += '</div>';
            
            indexContent.innerHTML = html;
        }

        // --- MODIFIED SAVE/LOAD FUNCTIONS ---
        
        function saveGame() {
            if (calisrng2.ruin) return;
            
            const gameState = {
                currency,
                totalUpgrades,
                upgradeCost,
                highestBaseRoll, 
                highestFinalRoll: highestFinalRoll || { 
                    value: 0, 
                    baseValue: 0, 
                    rank: 'None yet', 
                    variants: [], 
                    isSecret: false 
                },
                maxInventory,
                inventory,
                rollIndex,
                acceptedRolls: Array.from(acceptedRolls),
                discoveredRanks: Array.from(discoveredRanks),
                bulkRollLevel,
                bulkRollCost,
                
                pendingRolls,
                maxPendingRolls,
                
                secretsEnabled,

                hardcoreMode,
                originalBulkRollLevel,
                originalLuck,
                originalVariantChance,
                originalSecretLuck,

                sciNotationThreshold,
                sciNotationEnabled,

                cutscenesEnabled,

                currentEvent: currentEvent ? { name: currentEvent.name, duration: currentEvent.duration, description: currentEvent.description, targets: currentEvent.targets, multiplier: currentEvent.multiplier, eventChanceBoost: currentEvent.eventChanceBoost } : null,
                eventEndTime,
                eventCheckChance,

                autoAcceptThreshold,
                autoAcceptTrueRNGValue,
                autoAcceptSecretThresholdValue,
                autoAcceptOnNewRank,
                autoStopThreshold,
                autoStopTrueRNGValue,
                autoStopSecretThresholdValue,
                autoStopOnNewRank,

                geometrix,
                shapesUnlocked,
                shapeLuckLevel,
                shapeLuckCost,
                luckMultiLevel,
                luckMultiCost,
                bulkShapeLevel,
                bulkShapeCost,
                activeShapes: activeShapes.map(shape => ({
                    id: shape.id,
                    name: shape.name,
                    gain: shape.gain,
                    color: shape.color,
                    posX: shape.posX,
                    posY: shape.posY,
                    spawnTime: shape.spawnTime
                })),
                
                clickerUnlocked,
                fortunium,
                fortuniumLuck,
                gmxMultiLevel,
                gmxMultiCost,
                fortuniumLuckLevel,
                fortuniumLuckCost,
                clickerLuckLevel,
                clickerLuckCost,
                
                boosters,
                activeBooster,
                
                // NEW: Shop and variant secrets data
                shopBoosters,
                shopLastRefresh: Date.now(),
                discoveredVariantSecrets: Array.from(discoveredVariantSecrets)
            };
            localStorage.setItem('calisRNGGame', JSON.stringify(gameState));
            
            setTimeout(refreshAllUI, 50);
        }

        function loadGame() {
            const saved = localStorage.getItem('calisRNGGame');
            if (saved) {
                try {
                    const gameState = JSON.parse(saved);
                    currency = gameState.currency || 0;
                    totalUpgrades = gameState.totalUpgrades || 0;
                    upgradeCost = gameState.upgradeCost || 50;
                    
                    if (gameState.highestFinalRoll) {
                        highestFinalRoll = gameState.highestFinalRoll;
                        if (typeof highestFinalRoll.isSecret === 'undefined') {
                             highestFinalRoll.isSecret = SECRET_RANKS_CHANCES.map(r => r.name).includes(highestFinalRoll.rank) || highestFinalRoll.rank === "morts luck" || highestFinalRoll.rank === "Unobtainable";
                        }
                    } else {
                        const baseRoll = gameState.highestRoll || 0;
                        const rankInfo = getRankInfo(baseRoll);
                         highestFinalRoll = {
                            value: baseRoll,
                            baseValue: baseRoll,
                            rank: rankInfo.name,
                            variants: [],
                            isSecret: false
                        };
                    }
                    
                    highestBaseRoll = gameState.highestBaseRoll || (highestFinalRoll ? highestFinalRoll.baseValue : 0);
                    maxInventory = gameState.maxInventory || 10;
                    
                    inventory = (gameState.inventory || []).map(item => {
                        if (item.variant && !item.variants) {
                            item.variants = [item.variant];
                            delete item.variant;
                        } else if (!item.variants) {
                            item.variants = [];
                        }
                         if (typeof item.isSecret === 'undefined') {
                            item.isSecret = SECRET_RANKS_CHANCES.map(r => r.name).includes(item.rank.replace(" [HC]", "")) || item.rank === "morts luck" || item.rank === "breaktime" || item.rank.includes("Unobtainable");
                        }
                        return item;
                    });

                    rollIndex = gameState.rollIndex || 1;
                    acceptedRolls = new Set(gameState.acceptedRolls || []);
                    discoveredRanks = new Set(gameState.discoveredRanks || []);
                    bulkRollLevel = gameState.bulkRollLevel || 0;
                    bulkRollCost = gameState.bulkRollCost || 50000;
                    
                    pendingRolls = gameState.pendingRolls || [];
                    maxPendingRolls = gameState.maxPendingRolls || maxInventory * 3;
                    
                    secretsEnabled = typeof gameState.secretsEnabled !== 'undefined' ? gameState.secretsEnabled : true;
                    
                    hardcoreMode = gameState.hardcoreMode || false;
                    originalBulkRollLevel = gameState.originalBulkRollLevel || 0;
                    originalLuck = gameState.originalLuck || 0;
                    originalVariantChance = gameState.originalVariantChance || 1;
                    originalSecretLuck = gameState.originalSecretLuck || 1;
                    
                    sciNotationThreshold = gameState.sciNotationThreshold || DEFAULT_SCI_THRESHOLD;
                    sciNotationEnabled = typeof gameState.sciNotationEnabled !== 'undefined' ? gameState.sciNotationEnabled : true;
                    
                    cutscenesEnabled = typeof gameState.cutscenesEnabled === 'boolean' ? gameState.cutscenesEnabled : true;

                    currentEvent = gameState.currentEvent || null;
                    eventEndTime = gameState.eventEndTime || 0;
                    eventCheckChance = gameState.eventCheckChance || 1;

                    autoAcceptThreshold = gameState.autoAcceptThreshold || 0;
                    autoAcceptTrueRNGValue = gameState.autoAcceptTrueRNGValue || 0;
                    autoAcceptSecretThresholdValue = gameState.autoAcceptSecretThresholdValue || 0;
                    autoAcceptOnNewRank = gameState.autoAcceptOnNewRank || false;
                    
                    autoStopThreshold = gameState.autoStopThreshold || 0;
                    autoStopTrueRNGValue = gameState.autoStopTrueRNGValue || 0;
                    autoStopSecretThresholdValue = gameState.autoStopSecretThresholdValue || 0;
                    autoStopOnNewRank = gameState.autoStopOnNewRank || false;

                    geometrix = gameState.geometrix || 0;
                    shapesUnlocked = gameState.shapesUnlocked || false;
                    shapeLuckLevel = gameState.shapeLuckLevel || 0;
                    shapeLuckCost = gameState.shapeLuckCost || 5;
                    luckMultiLevel = gameState.luckMultiLevel || 0;
                    luckMultiCost = gameState.luckMultiCost || 100;
                    bulkShapeLevel = gameState.bulkShapeLevel || 0;
                    bulkShapeCost = gameState.bulkShapeCost || 50;
                    
                    activeShapes = gameState.activeShapes || [];

                    clickerUnlocked = gameState.clickerUnlocked || false;
                    fortunium = gameState.fortunium || 0;
                    fortuniumLuck = gameState.fortuniumLuck || 0;
                    gmxMultiLevel = gameState.gmxMultiLevel || 0;
                    gmxMultiCost = gameState.gmxMultiCost || 75;
                    fortuniumLuckLevel = gameState.fortuniumLuckLevel || 0;
                    fortuniumLuckCost = gameState.fortuniumLuckCost || 125;
                    clickerLuckLevel = gameState.clickerLuckLevel || 0;
                    clickerLuckCost = gameState.clickerLuckCost || 1000;
                    
                    boosters = gameState.boosters || [];
                    activeBooster = gameState.activeBooster || null;
                    updateBoosterDisplay();
                    
                    // NEW: Load shop data
                    shopBoosters = gameState.shopBoosters || [];
                    const shopLastRefresh = gameState.shopLastRefresh || 0;
                    if (Date.now() - shopLastRefresh > 20000) {
                        shopBoosters = [];
                    }
                    
                    // NEW: Load variant secrets
                    discoveredVariantSecrets = new Set(gameState.discoveredVariantSecrets || []);

                    updateCalculatedStats();
                    
                    if (hardcoreMode) {
                        bulkRollLevel = 0;
                        currentLuck = 0;
                        variantChanceMultiplier = 1;
                        secretLuckMultiplier = 1;
                        luckMultiValue = 1;
                        
                        document.getElementById('hardcoreToggleBtn').textContent = 'Hardcore Mode: ON';
                        document.getElementById('hardcoreToggleBtn').classList.add('active');
                        document.getElementById('hardcoreStatus').textContent = 'ON';
                        document.getElementById('hardcore-warning').style.display = 'block';
                        document.body.classList.add('hardcore-mode-active');
                    }
                    
                    document.getElementById('sciNotationThreshold').value = sciNotationThreshold;
                    document.getElementById('sciNotationStatus').textContent = sciNotationEnabled ? 'ON' : 'OFF';
                    document.getElementById('sciNotationStatus').style.color = sciNotationEnabled ? '#00ff00' : '#ff0000';
                    
                    document.getElementById('autoAcceptThreshold').value = autoAcceptThreshold;
                    document.getElementById('autoAcceptTrueRNG').value = autoAcceptTrueRNGValue;
                    document.getElementById('autoAcceptSecretThreshold').value = autoAcceptSecretThresholdValue;
                    document.getElementById('autoAcceptNewRank').checked = autoAcceptOnNewRank;
                    
                    document.getElementById('autoStopThreshold').value = autoStopThreshold;
                    document.getElementById('autoStopTrueRNG').value = autoStopTrueRNGValue;
                    document.getElementById('autoStopSecretThreshold').value = autoStopSecretThresholdValue;
                    document.getElementById('autoStopNewRank').checked = autoStopOnNewRank;
                    
                    refreshAllUI();
                    
                    if (shapesUnlocked) {
                        renderActiveShapes();
                        startShapeInterval();
                    }
                    
                    if (currentEvent && eventEndTime > Date.now() && !hardcoreMode) {
                        const durationRemaining = eventEndTime - Date.now();
                        resumeEvent(currentEvent, durationRemaining);
                    } else if (currentEvent && eventEndTime <= Date.now()) {
                        endEvent({ name: currentEvent.name, eventChanceBoost: currentEvent.eventChanceBoost });
                    }
                    
                    addToTerminal('Game loaded!', true);
                } catch (e) {
                    console.error('Error loading game:', e);
                    updateCalculatedStats();
                    refreshAllUI();
                }
            } else {
                 updateCalculatedStats();
                refreshAllUI();
            }
        }

        // --- MODIFIED EXPORT/IMPORT WITH SHOP DATA ---
        
        function exportSave() {
            try {
                saveGame();
                const saveData = localStorage.getItem('calisRNGGame');
                if (!saveData) {
                    addToTerminal('No save data found!', true);
                    return;
                }
                
                const compressedData = LZString.compressToBase64(saveData);
                document.getElementById('saveDataTextarea').value = compressedData;
                
                addToTerminal('‚úÖ Save data exported (includes shop and variant secrets)!', true);
            } catch (e) {
                console.error('Error exporting save:', e);
                addToTerminal('Error exporting save data. Check console.', true, 'rank-1000000-100000000');
            }
        }
        
        function importSave() {
            if (!confirm("Are you sure you want to import this save? This will OVERWRITE your current progress and reload the page.")) {
                return;
            }
            
            try {
                const compressedData = document.getElementById('saveDataTextarea').value;
                if (!compressedData) {
                    addToTerminal('Paste save data into the text box first!', true);
                    return;
                }
                
                let decodedData;
                try {
                    decodedData = LZString.decompressFromBase64(compressedData);
                } catch (e) {
                    decodedData = compressedData;
                }
                
                if (!decodedData) {
                    addToTerminal('Invalid save data format!', true);
                    return;
                }
                
                JSON.parse(decodedData);
                
                localStorage.setItem('calisRNGGame', decodedData);
                
                if (autoRollInterval) clearInterval(autoRollInterval);
                if (eventInterval) clearInterval(eventInterval);
                if (shapeInterval) clearInterval(shapeInterval);
                if (currentEvent && currentEvent.timeoutId) clearTimeout(currentEvent.timeoutId);
                if (shopAutoRefreshInterval) clearInterval(shopAutoRefreshInterval);
                for (const id in activeEuphoriaIntervals) {
                    clearInterval(activeEuphoriaIntervals[id]);
                }
                for (const id in activeBewildermentIntervals) {
                    clearInterval(activeBewildermentIntervals[id]);
                }
                
                addToTerminal('‚úÖ Import successful (including shop data)! Reloading game...', true, 'rank-1000000000-10000000000');
                
                setTimeout(() => {
                    location.reload();
                }, 1000);
                
            } catch (e) {
                console.error('Error importing save:', e);
                addToTerminal('Error importing save data. Data might be corrupt or invalid. Check console.', true, 'rank-1000000-100000000');
            }
        }

        // --- MODIFIED UPDATE STATS ---
        
        function updateStats() {
            document.getElementById('currency').textContent = formatNumber(currency);
            document.getElementById('geometrix').textContent = formatGeometrix(geometrix);
            document.getElementById('upgrades').textContent = totalUpgrades;
            
            document.getElementById('luck').textContent = currentLuck.toFixed(3);
            document.getElementById('luckMulti').textContent = luckMultiValue.toFixed(2);
            document.getElementById('secretLuck').textContent = secretLuckMultiplier.toFixed(2);
            document.getElementById('variantChance').textContent = variantChanceMultiplier.toFixed(2);
            
            document.getElementById('upgradeCost').textContent = formatNumber(upgradeCost);
            document.getElementById('inventoryCount').textContent = inventory.length;
            document.getElementById('inventoryMax').textContent = maxInventory;
            document.getElementById('pendingCount').textContent = pendingRolls.length;
            document.getElementById('pendingMax').textContent = maxPendingRolls;
            
            let visibleDiscoveredCount = 0;
            for (const rankName of discoveredRanks) {
                if (rankName.includes("DEV EXCLUSIVE")) {
                    continue;
                }
                visibleDiscoveredCount++;
            }
            document.getElementById('ranksDiscovered').textContent = visibleDiscoveredCount;
            document.getElementById('totalRanks').textContent = TOTAL_RANKS;
            document.getElementById('secretsEnabled').textContent = secretsEnabled ? 'Yes' : 'No';
            document.getElementById('hardcoreStatus').textContent = hardcoreMode ? 'ON' : 'OFF';
            
            // NEW: Variant secrets count
            document.getElementById('variantSecretsDiscovered').textContent = discoveredVariantSecrets.size;
            document.getElementById('totalVariantSecrets').textContent = TOTAL_VARIANT_SECRETS;
            
            document.getElementById('sciNotationStatus').textContent = sciNotationEnabled ? 'ON' : 'OFF';
            document.getElementById('sciNotationStatus').style.color = sciNotationEnabled ? '#00ff00' : '#ff0000';
            document.getElementById('sciNotationStat').textContent = `${sciNotationEnabled ? 'ON' : 'OFF'} (‚â•${formatNumber(sciNotationThreshold)})`;
            
            document.getElementById('bulkRollLevel').textContent = bulkRollLevel;
            document.getElementById('bulkRollAmount').textContent = bulkRollLevel + 1;
            
            const bulkCostEl = document.getElementById('bulkRollCost');
            const bulkBtnEl = document.getElementById('buyBulkRollBtn');
            
            if (bulkRollLevel >= MAX_BULK_ROLL_LEVEL) {
                bulkCostEl.textContent = "MAXED";
                if (bulkBtnEl) {
                    bulkBtnEl.disabled = true;
                    bulkBtnEl.textContent = "Bulk Roll (MAXED)";
                }
            } else {
                bulkCostEl.textContent = formatNumber(bulkRollCost);
                if (bulkBtnEl) {
                    bulkBtnEl.disabled = currency < bulkRollCost;
                    bulkBtnEl.textContent = "Buy Bulk Roll";
                }
            }
            
            const statsContainer = document.querySelector('.stats');
            let eventStat = document.getElementById('eventStat');
            if (!eventStat) {
                eventStat = document.createElement('div');
                eventStat.className = 'stat-item';
                eventStat.id = 'eventStat';
                statsContainer.appendChild(eventStat);
            }
            const eventName = currentEvent ? currentEvent.name : "None";
            const timeLeft = currentEvent ? Math.max(0, eventEndTime - Date.now()) : 0;
            const timeLeftFormatted = (timeLeft / 1000).toFixed(1);
            eventStat.innerHTML = `Active Event: <span style="color: ${currentEvent ? '#00FFFF' : '#ffffff'};">${eventName}</span> (${timeLeftFormatted}s)`;
            
            if (highestFinalRoll.value > 0 || highestFinalRoll.rank === "CORRUPTED") {
                const { className, color } = getRankClassAndColor(highestFinalRoll.value, highestFinalRoll.variants, highestFinalRoll.rank);
                let rankClass = className;
                let rollColor = color;
                let displayName = highestFinalRoll.rank;
                let displayValue = highestFinalRoll.value;
                let suffix = "";

                if (displayName === "~Nonavacious~") {
                    rankClass += " secret-nonavacious";
                }
                
                if (displayName === "CORRUPTED") {
                    rankClass += " secret-corrupted";
                    rollColor = "#FFFFFF";
                }
                
                if (displayName === "‚õßSatanic‚õß") {
                    suffix = ` (Actual: ${formatNumber(highestFinalRoll.value)})`;
                    displayValue = -666.66;
                }
                if (displayName === "Finale.. wait, how'd this get here?") {
                    suffix = ` (Actual: ${formatNumber(highestFinalRoll.value)})`;
                    displayValue = 1e10;
                }
                
                document.getElementById('rarest').innerHTML = 
                    `<span class="satanic-wrapper"><span class="${rankClass}" style="color: ${rollColor};">${formatNumber(displayValue)} [${displayName}]${suffix}</span></span>`;
            }

            const cutsceneBtn = document.getElementById('cutsceneToggleBtn');
            if (cutsceneBtn) {
                cutsceneBtn.textContent = `Cutscenes: ${cutscenesEnabled ? 'ON' : 'OFF'}`;
            }

            const secretBtn = document.getElementById('secretToggleBtn');
            if (secretBtn) {
                secretBtn.textContent = `Secrets: ${secretsEnabled ? 'ON' : 'OFF'}`;
            }

            const hardcoreBtn = document.getElementById('hardcoreToggleBtn');
            if (hardcoreBtn) {
                hardcoreBtn.textContent = `Hardcore Mode: ${hardcoreMode ? 'ON' : 'OFF'}`;
                if (hardcoreMode) {
                    hardcoreBtn.classList.add('active');
                } else {
                    hardcoreBtn.classList.remove('active');
                }
            }

            const shapesGui = document.getElementById('shapes-gui');
            if (shapesGui) {
                shapesGui.style.display = shapesUnlocked ? 'block' : 'none';
                shapesGui.offsetHeight;
            }
            
            const shapesUnlockControls = document.getElementById('shapes-unlock-controls');
            if (shapesUnlockControls) {
                shapesUnlockControls.style.display = shapesUnlocked ? 'none' : 'grid';
            }
            
            document.getElementById('unlockShapesBtn').disabled = currency < UNLOCK_SHAPES_COST;

            if (shapesUnlocked) {
                document.getElementById('shapeLuckBonus').textContent = shapeLuckBonus.toFixed(1);
                document.getElementById('bulkShapeAmount').textContent = bulkShapeLevel + 1;
                document.getElementById('bulkShapeLevel').textContent = bulkShapeLevel;
                document.getElementById('shapeCooldown').textContent = formatCooldown(currentShapeCooldown);
                
                const shapeLuckBtn = document.getElementById('buyShapeLuckBtn');
                document.getElementById('shapeLuckCost').textContent = formatGeometrix(shapeLuckCost);
                if (shapeLuckLevel >= MAX_SHAPE_LUCK_LEVEL) {
                    shapeLuckBtn.disabled = true;
                    shapeLuckBtn.innerHTML = `Shape Luck (MAXED)`;
                } else {
                    shapeLuckBtn.disabled = geometrix < shapeLuckCost;
                    shapeLuckBtn.innerHTML = `Shape Luck (+0.1x) - Cost: <span id="shapeLuckCost">${formatGeometrix(shapeLuckCost)}</span> GMX`;
                }
                
                const luckMultiBtn = document.getElementById('buyLuckMultiBtn');
                document.getElementById('luckMultiCost').textContent = formatGeometrix(luckMultiCost);
                luckMultiBtn.disabled = geometrix < luckMultiCost;

                const bulkShapeBtn = document.getElementById('buyBulkShapeBtn');
                document.getElementById('bulkShapeCost').textContent = formatGeometrix(bulkShapeCost);
                if (bulkShapeLevel >= MAX_BULK_SHAPE_LEVEL) {
                    bulkShapeBtn.disabled = true;
                    bulkShapeBtn.innerHTML = `Bulk/Cooldown (MAXED)`;
                } else {
                    bulkShapeBtn.disabled = geometrix < bulkShapeCost;
                    bulkShapeBtn.innerHTML = `Bulk/Cooldown Lvl <span id="bulkShapeLevelBtn">${bulkShapeLevel + 1}</span> - Cost: <span id="bulkShapeCost">${formatGeometrix(bulkShapeCost)}</span> GMX`;
                }

                const clickerUnlockBtn = document.getElementById('buyClickerUnlockBtn');
                if (clickerUnlockBtn) {
                     if (clickerUnlocked) {
                        clickerUnlockBtn.disabled = true;
                        clickerUnlockBtn.textContent = "Clicker Unlocked";
                    } else {
                        clickerUnlockBtn.disabled = geometrix < UNLOCK_CLICKER_COST;
                        clickerUnlockBtn.textContent = `Unlock Clicker - Cost: ${formatGeometrix(UNLOCK_CLICKER_COST)} GMX`;
                    }
                }
            }

            const clickerGui = document.getElementById('clicker-gui');
            if (clickerGui) {
                clickerGui.style.display = clickerUnlocked ? 'block' : 'none';
                clickerGui.offsetHeight;
            }
            
            if (clickerUnlocked) {
                document.getElementById('fortunium').textContent = formatNumber(fortunium);
                document.getElementById('fortuniumLuck').textContent = fortuniumLuck.toFixed(2);
                
                const gmxMultiBtn = document.getElementById('buyGmxMultiBtn');
                document.getElementById('gmxMultiCost').textContent = formatNumber(gmxMultiCost);
                gmxMultiBtn.disabled = fortunium < gmxMultiCost;
                gmxMultiBtn.innerHTML = `GMX Multi (+0.5x) - Cost: <span id="gmxMultiCost">${formatNumber(gmxMultiCost)}</span> FOR`;

                const fortuniumLuckBtn = document.getElementById('buyFortuniumLuckBtn');
                document.getElementById('fortuniumLuckCost').textContent = formatNumber(fortuniumLuckCost);
                fortuniumLuckBtn.disabled = fortunium < fortuniumLuckCost;

                const clickerLuckBtn = document.getElementById('buyClickerLuckBtn');
                document.getElementById('clickerLuckCost').textContent = formatNumber(clickerLuckCost);
                if (clickerLuckLevel >= MAX_CLICKER_LUCK_LEVEL) {
                    clickerLuckBtn.disabled = true;
                    clickerLuckBtn.innerHTML = `Luck Multi (MAXED)`;
                } else {
                    clickerLuckBtn.disabled = fortunium < clickerLuckCost;
                    clickerLuckBtn.innerHTML = `Luck Multi (+0.5x) - Cost: <span id="clickerLuckCost">${formatNumber(clickerLuckCost)}</span> FOR`;
                }
            }
            
            preserveAnimations();
        }

        // --- THE REST OF THE ORIGINAL FUNCTIONS (truncated for brevity) ---
        // Note: These functions remain largely unchanged from the original
        // but are included here for completeness in the full file

        function toggleScientificNotation() {
            sciNotationEnabled = !sciNotationEnabled;
            const statusEl = document.getElementById('sciNotationStatus');
            statusEl.textContent = sciNotationEnabled ? 'ON' : 'OFF';
            statusEl.style.color = sciNotationEnabled ? '#00ff00' : '#ff0000';
            
            updateStats();
            preserveAnimations();
            saveGame();
            
            addToTerminal(`Scientific notation ${sciNotationEnabled ? 'enabled' : 'disabled'} for numbers ‚â• ${formatNumber(sciNotationThreshold)}`, true);
        }

        function toggleHardcoreMode() {
            if (!HARDCORE_MODE_ENABLED) {
                addToTerminal('Hardcore mode is not available in this version.', true);
                return;
            }
            
            hardcoreMode = !hardcoreMode;
            
            if (hardcoreMode) {
                originalBulkRollLevel = bulkRollLevel;
                originalLuck = currentLuck;
                originalVariantChance = variantChanceMultiplier;
                originalSecretLuck = secretLuckMultiplier;
                
                bulkRollLevel = 0;
                updateCalculatedStats();
                currentLuck = 0;
                variantChanceMultiplier = 1;
                secretLuckMultiplier = 1;
                luckMultiValue = 1;
                
                addToTerminal('‚ö†Ô∏è HARDCORE MODE ACTIVATED! Bulk=1, Luck=0, Variant=1, Secret=1, Events disabled', true, 'rank-1000000-100000000');
                
                document.getElementById('hardcoreToggleBtn').textContent = 'Hardcore Mode: ON';
                document.getElementById('hardcoreToggleBtn').classList.add('active');
                document.getElementById('hardcoreStatus').textContent = 'ON';
                document.getElementById('hardcore-warning').style.display = 'block';
                document.body.classList.add('hardcore-mode-active');
            } else {
                bulkRollLevel = originalBulkRollLevel;
                updateCalculatedStats();
                currentLuck = originalLuck;
                variantChanceMultiplier = originalVariantChance;
                secretLuckMultiplier = originalSecretLuck;
                
                addToTerminal('Hardcore mode deactivated. Stats restored.', true);
                
                document.getElementById('hardcoreToggleBtn').textContent = 'Hardcore Mode: OFF';
                document.getElementById('hardcoreToggleBtn').classList.remove('active');
                document.getElementById('hardcoreStatus').textContent = 'OFF';
                document.getElementById('hardcore-warning').style.display = 'none';
                document.body.classList.remove('hardcore-mode-active');
            }
            
            updateStats();
            saveGame();
        }

        function getEventMultiplier(target) {
            if (hardcoreMode || !currentEvent) return 1;
            
            if (currentEvent.targets.includes("ALL_SECRETS")) {
                return currentEvent.multiplier;
            }
            
            if (currentEvent.targets.includes(target)) {
                return currentEvent.multiplier;
            }
            
            return 1;
        }

        function preserveAnimations() {
            inventory.forEach((item, idx) => {
                const elementId = `inv-item-${idx}`;
                const element = document.getElementById(elementId);
                if (element && (item.rank === "!! EUPHORIA !!" || item.rank === "?!? bewilderment ?!?" || item.rank.includes("Complex"))) {
                    if (!activeAnimationElements.has(elementId)) {
                        activeAnimationElements.add(elementId);
                        if (item.rank === "!! EUPHORIA !!") {
                            setTimeout(() => initEuphoriaAnimation(elementId, "!! EUPHORIA !!"), 10);
                        }
                        if (item.rank === "?!? bewilderment ?!?") {
                            setTimeout(() => initBewildermentAnimation(elementId), 10);
                        }
                    }
                }
            });
            
            document.querySelectorAll('.clickable-roll').forEach(el => {
                if (el.id && (el.textContent.includes("!! EUPHORIA !!") || el.textContent.includes("?!? bewilderment ?!?"))) {
                    if (!activeAnimationElements.has(el.id)) {
                        activeAnimationElements.add(el.id);
                    }
                }
            });
        }

        function calculateTotalRarity(item) {
            let totalRarity = 0;
            
            const rankName = item.rank.replace(" [HC]", "");
            
            const secretRank = SECRET_RANKS_CHANCES.find(r => r.name === rankName);
            if (secretRank) {
                totalRarity += secretRank.rarity || 1;
            } else {
                totalRarity += item.baseValue || item.value;
            }
            
            if (item.variants && item.variants.length > 0) {
                item.variants.forEach(variant => {
                    const variantData = VARIANTS.find(v => v.name === variant.name);
                    if (variantData) {
                        totalRarity += 1 / variantData.chance;
                    }
                });
            }
            
            return totalRarity;
        }

        function sortInventory(type) {
            if (type === 'leastRarest') {
                inventory.sort((a, b) => calculateTotalRarity(a) - calculateTotalRarity(b));
            } else if (type === 'mostRarest') {
                inventory.sort((a, b) => calculateTotalRarity(b) - calculateTotalRarity(a));
            }
            updateInventoryDisplay();
            preserveAnimations();
            addToTerminal(`Inventory sorted by ${type === 'mostRarest' ? 'most rarest (Total Rarity)' : 'least rarest (Total Rarity)'}.`, true);
            saveGame();
        }

        function updateCalculatedStats() {
            currentLuck = hardcoreMode ? 0 : totalUpgrades * LUCK_PER_UPGRADE;
            
            shapeLuckBonus = shapeLuckLevel * SHAPE_LUCK_BONUS;
            
            const clickerLuckBonus = clickerLuckLevel * 0.5;
            
            luckMultiValue = hardcoreMode ? 1 : (Math.pow(2, luckMultiLevel) + clickerLuckBonus);
            
            secretLuckMultiplier = hardcoreMode ? 1 : Math.min(1 + (totalUpgrades * SECRET_LUCK_PER_UPGRADE), MAX_SECRET_LUCK) * luckMultiValue;
            variantChanceMultiplier = hardcoreMode ? 1 : Math.min(1 + (totalUpgrades * VARIANT_CHANCE_PER_UPGRADE), MAX_VARIANT_CHANCE_MULTIPLIER) * luckMultiValue;
            
            currentShapeCooldown = Math.max(
                SHAPE_SPAWN_INTERVAL_MS - (bulkShapeLevel * SHAPE_COOLDOWN_DECREASE_MS), 
                SHAPE_SPAWN_INTERVAL_MS - (MAX_BULK_SHAPE_LEVEL * SHAPE_COOLDOWN_DECREASE_MS)
            );
            
            maxPendingRolls = maxInventory * 3;
        }

        function getVariants(baseValue) {
            let selectedVariants = [];
            let totalMultiplier = 1;
            let hasNegative = false;
            let hasDull = false;

            let eventVariantMultiplier = hardcoreMode ? 1 : (currentEvent && currentEvent.name === "Modified" ? currentEvent.multiplier : 1);
            
            for (let i = VARIANTS.length - 1; i >= 0; i--) {
                const variant = VARIANTS[i];
                
                if (!variant.bypassCap) continue;
                
                const adjustedChance = variant.chance * variantChanceMultiplier * eventVariantMultiplier;
                
                if (Math.random() < adjustedChance) {
                    selectedVariants.push(variant);
                    
                    if (variant.isNegative) {
                        hasNegative = true;
                        totalMultiplier *= -1;
                    }
                    
                    if (variant.isDull) {
                        hasDull = true;
                    }
                }
            }
            
            for (let i = VARIANTS.length - 1; i >= 0; i--) {
                const variant = VARIANTS[i];
                if (variant.bypassCap) continue;
                
                const adjustedChance = variant.chance * variantChanceMultiplier * eventVariantMultiplier;
                
                while (selectedVariants.length < MAX_VARIANTS_PER_ROLL && Math.random() < adjustedChance) {
                    selectedVariants.push(variant);
                    totalMultiplier *= variant.multiplier;
                }
            }
            
            let modifiedValue = baseValue * totalMultiplier;
            
            if (hasDull) {
                if (modifiedValue !== 0) {
                    modifiedValue = Math.pow(modifiedValue, -1);
                }
            }
            
            if (selectedVariants.length > 0) {
                selectedVariants.sort((a, b) => {
                    if (a.bypassCap && !b.bypassCap) return -1;
                    if (!a.bypassCap && b.bypassCap) return 1;
                    return (b.multiplier || 0) - (a.multiplier || 0);
                });
                return { 
                    variants: selectedVariants, 
                    modifiedValue: modifiedValue 
                };
            }
            return null;
        }

        function generateRoll() {
            const totalLuck = currentLuck * luckMultiValue;
            const baseRoll = Math.pow(Math.random(), 3 / POWER_EXPONENT) * (1 + totalLuck);
            return { value: baseRoll, variant: null };
        }
        
        function getSecretRank() {
            if (!secretsEnabled) return null;
            
            const rand = Math.random();
            
            let hiddenEventMultiplier = hardcoreMode ? 1 : (currentEvent && currentEvent.targets.includes("ALL_SECRETS") ? currentEvent.multiplier : 1);
            
            const availableSecrets = SECRET_RANKS_CHANCES;
            
            for (const secret of availableSecrets) {
                let chanceMultiplier = 1;
                let adjustedChance = secret.chance;

                if (secret.eventOnly) {
                    if (hardcoreMode) {
                        continue;
                    }
                    if (!currentEvent || currentEvent.name !== secret.eventOnly) {
                        continue;
                    }
                    if (secret.name === "Destroyed" && currentEvent.name === "Hidden" && secret.eventChance) {
                        adjustedChance = secret.eventChance;
                    }
                }

                if (secret.timeBased && secret.name === "breaktime") {
                    const now = new Date();
                    const utc3OffsetMs = -3 * 60 * 60 * 1000;
                    const utc3Time = new Date(now.getTime() + utc3OffsetMs);
                    const dayOfWeek = utc3Time.getUTCDay();

                    if (dayOfWeek >= 1 && dayOfWeek <= 5) {
                        adjustedChance = 0;
                    } else {
                        adjustedChance = 1 / 705372;
                    }
                }

                if (!hardcoreMode && currentEvent && currentEvent.targets.includes(secret.name)) {
                    chanceMultiplier = currentEvent.multiplier;
                }
                
                if (secret.name === "7 GRAND DAD" && secret.requiresGrand) {
                    continue;
                }
                
                if (rand < adjustedChance * secretLuckMultiplier * chanceMultiplier * hiddenEventMultiplier) {
                    if (secret.name === 'cali^2') {
                        if (Math.random() < 1/1e6) {
                            return { name: "morts luck", chance: 1/1e18, rarity: 1e18 };
                        }
                    }
                    return secret;
                }
            }
            return null;
        }

        function checkRoundingIssue(value) {
            const rounded = Math.round(value);
            const diff = Math.abs(value - rounded);
            
            if (diff < 1e-6 && diff > 0) {
                return true;
            }
            
            const strValue = value.toString();
            if (strValue.includes('9999999999') || strValue.includes('0000000001')) {
                return true;
            }
            
            return false;
        }

        function getRankInfo(value) {
            if (checkRoundingIssue(value)) {
                return { 
                    name: "Improbable", 
                    value: value, 
                    rankNum: RANK_TIERS.length,
                    isUnobtainable: false
                };
            }
            
            for (let i = 0; i < RANK_TIERS.length; i++) {
                const tier = RANK_TIERS[i];
                if (value >= tier.min && value < tier.max) {
                    let rankName = tier.name;
                    let isUnobtainable = false;
                    
                    if (tier.name === "Unattainable" && Math.random() < 1/200) {
                        rankName = "Unobtainable";
                        value *= 250000;
                        isUnobtainable = true;
                    }
                    
                    if (hardcoreMode && !rankName.includes("[HC]")) {
                        rankName = rankName + " [HC]";
                    }
                    
                    return { 
                        name: rankName, 
                        value: value, 
                        rankNum: i + 1,
                        isUnobtainable: isUnobtainable
                    };
                }
            }
            
            let finalRankName = RANK_TIERS[RANK_TIERS.length - 1].name;
            if (hardcoreMode && !finalRankName.includes("[HC]")) {
                finalRankName = finalRankName + " [HC]";
            }
            
            return { 
                name: finalRankName, 
                value: value, 
                rankNum: RANK_TIERS.length,
                isUnobtainable: false
            };
        }

        function getRankClassAndColor(value, variants = [], rankName = "") {
            let color = "#ffffff";
            let className = "rank-1-1000";
            
            if (rankName.includes("Unobtainable")) {
                className = "rank-unobtainable";
                color = "#000000";
            }
            else if (rankName && rankName.includes("Complex")) {
                className = "rank-complex";
                color = "#ffffff";
            }
            else if (value >= 1e30) { className = "rank-improbable"; color = "#008080"; }
            else if (value >= 1e21) { className = "rank-1e21-1e30"; color = "#000000"; }
            else if (value >= 1e15) { className = "rank-rainbow"; color = "#ff7f00"; }
            else if (value >= 1e12) { className = "rank-1000000000000-100000000000000"; color = "#ff69b4"; }
            else if (value >= 1e11) { className = "rank-100000000000-1000000000000"; color = "#a9a9a9"; } 
            else if (value >= 1e10) { className = "rank-10000000000-100000000000"; color = "#ffc0cb"; } 
            else if (value >= 1e9) { className = "rank-1000000000-10000000000"; color = "#00ff00"; }
            else if (value >= 1e8) { className = "rank-100000000-1000000000"; color = "#8b0000"; }
            else if (value >= 1e6) { className = "rank-1000000-100000000"; color = "#ff0000"; }
            else if (value >= 1e5) { className = "rank-100000-1000000"; color = "#0000cd"; }
            else if (value >= 10000) { className = "rank-10000-100000"; color = "#00ffff"; }
            else if (value >= 1000) { className = "rank-1000-10000"; color = "#ffff00"; }
            
            if (hardcoreMode && rankName.includes("[HC]")) {
                className += " hardcore-rank";
            }
            
            return { className, color };
        }

        function getRankClass(value, variants = []) {
            return getRankClassAndColor(value, variants).className;
        }

        function addToTerminal(text, isCommand = false, className = "") {
            if (calisrng2.ruin) text = "Lol";
            
            const terminal = document.getElementById('terminal');
            const line = document.createElement('div');
            line.className = 'output-line';
            if (isCommand) line.classList.add('command');
            if (className) line.classList.add(className);
            line.innerHTML = text;

            if (terminal.children.length > 100) {
                terminal.removeChild(terminal.firstChild);
            }

            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
            
            setTimeout(preserveAnimations, 50);
        }
        
        function toggleSecrets() {
            secretsEnabled = !secretsEnabled;
            const btn = document.getElementById('secretToggleBtn');
            const state = secretsEnabled ? 'ON' : 'OFF';
            btn.textContent = `Secrets: ${state}`;
            document.getElementById('secretsEnabled').textContent = secretsEnabled ? 'Yes' : 'No';
            addToTerminal(`Secrets turned ${state}.`, true);
            saveGame();
        }

        function toggleCutscenes() {
            cutscenesEnabled = !cutscenesEnabled;
            const btn = document.getElementById('cutsceneToggleBtn');
            const state = cutscenesEnabled ? 'ON' : 'OFF';
            btn.textContent = `Cutscenes: ${state}`;
            addToTerminal(`Cutscenes turned ${state}.`, true);
            saveGame();
        }

        function updateInventoryDisplay() {
            const inventoryContent = document.getElementById('inventoryContent');
            if (inventory.length === 0) {
                inventoryContent.innerHTML = 'Empty';
            } else {
                inventoryContent.innerHTML = inventory.map((item, idx) => {
                    const { className: rankClass, color: rollColor } = getRankClassAndColor(item.value, item.variants, item.rank);
                    let displayClass = rankClass;
                    if (item.rank === "~Nonavacious~") {
                        displayClass += " secret-nonavacious";
                    }
                    if (item.rank === "CORRUPTED") {
                        displayClass += " secret-corrupted";
                    }
                    
                    let variantText = '';
                    if (item.variants && item.variants.length > 0) {
                        variantText = item.variants.map(v => {
                            let variantClass = '';
                            if (v.name === "GIANT") variantClass = 'variant-GIANT';
                            else if (v.name === "Mega") variantClass = 'variant-Mega';
                            else if (v.name === "Small") variantClass = 'variant-Small';
                            
                            return `<span class="${variantClass}" style="color: ${v.color}; font-weight: bold;">[${v.name}]</span>`;
                        }).join('') + ' ';
                    }
                    let suffix = "";
                    let displayValue = item.value;
                    if (item.rank === "100") suffix = " * üíØ";
                    if (item.rank === ":[{(absolute zero)}]:") suffix = " * 0";
                    
                    if (item.rank === "‚õßSatanic‚õß") {
                        suffix = ` (Actual: ${formatNumber(item.value)})`;
                        displayValue = -666.66;
                    }
                    if (item.rank === "Finale.. wait, how'd this get here?") {
                        suffix = ` (Actual: ${formatNumber(item.value)})`;
                        displayValue = 1e10;
                    }
                    
                    let content = `<span class="${displayClass}" style="color: ${rollColor};" data-text="${escapeHTML(item.rank)}">${formatNumber(displayValue)} [${item.rank}]${suffix}</span>`;
                    if (item.rank === "‚õßSatanic‚õß") {
                        content = `<span class="satanic-wrapper">${content}</span>`;
                    }
                    
                    return `<div class="inventory-item" onclick="removeFromInventory(${idx})" id="inv-item-${idx}">
                        #${formatInteger(item.index)}: ${variantText}${content}
                    </div>`; 
                }).join('');
            }
            
            inventory.forEach((item, idx) => {
                const elementId = `inv-item-${idx}`;
                if (item.rank === "!! EUPHORIA !!" && !activeEuphoriaIntervals[elementId]) {
                    initEuphoriaAnimation(elementId, "!! EUPHORIA !!");
                }
                if (item.rank === "?!? bewilderment ?!?" && !activeBewildermentIntervals[elementId]) {
                    initBewildermentAnimation(elementId);
                }
            });
        }

        function updatePendingDisplay() {
            const pendingContent = document.getElementById('pendingContent');
            
            if (pendingRolls.length === 0) {
                pendingContent.innerHTML = 'Empty';
            } else {
                pendingContent.innerHTML = pendingRolls.map((item, idx) => {
                    const { className: rankClass, color: rollColor } = getRankClassAndColor(item.value, item.variants, item.rank);
                    let displayClass = rankClass;
                    
                    if (item.rank === "~Nonavacious~") displayClass += " secret-nonavacious";
                    if (item.rank === "CORRUPTED") displayClass += " secret-corrupted";
                    
                    let variantText = '';
                    if (item.variants && item.variants.length > 0) {
                        variantText = item.variants.map(v => {
                            let variantClass = '';
                            if (v.name === "GIANT") variantClass = 'variant-GIANT';
                            else if (v.name === "Mega") variantClass = 'variant-Mega';
                            else if (v.name === "Small") variantClass = 'variant-Small';
                            
                            return `<span class="${variantClass}" style="color: ${v.color}; font-weight: bold;">[${v.name}]</span>`;
                        }).join('') + ' ';
                    }
                    
                    return `<div class="pending-roll-item">
                        <div>
                            #${formatInteger(item.index)}: ${variantText}<span class="${displayClass}" style="color: ${rollColor};" data-text="${escapeHTML(item.rank)}">${formatNumber(item.value)} [${item.rank}]</span>
                        </div>
                        <div class="pending-roll-buttons">
                            <button class="pending-accept-btn" onclick="acceptPendingRoll(${idx})">Accept</button>
                            <button class="pending-decline-btn" onclick="declinePendingRoll(${idx})">Decline</button>
                        </div>
                    </div>`;
                }).join('');
            }
        }

        function acceptPendingRoll(idx) {
            const pending = pendingRolls[idx];
            if (addToInventory(pending.value, pending.rank, pending.index, pending.variants, pending.baseValue)) {
                pendingRolls.splice(idx, 1);
                updatePendingDisplay();
                addToTerminal(`Accepted pending roll #${formatInteger(pending.index)} (${pending.rank})`, true);
                updateStats();
                saveGame();
            } else {
                addToTerminal('Cannot accept: inventory full!', true);
            }
        }

        function declinePendingRoll(idx) {
            const pending = pendingRolls[idx];
            pendingRolls.splice(idx, 1);
            updatePendingDisplay();
            addToTerminal(`Declined pending roll #${formatInteger(pending.index)} (${pending.rank})`, true);
            updateStats();
            saveGame();
        }

        function addToInventory(value, rank, index, variants = [], baseValue = null) {
            if (inventory.length >= maxInventory) {
                return false;
            }
            const isSecret = SECRET_RANKS_CHANCES.map(r => r.name).includes(rank.replace(" [HC]", "")) || 
                            rank === "morts luck" || 
                            rank === "breaktime" || 
                            rank.includes("Unobtainable");
            inventory.push({ value, rank, index, variants, baseValue: baseValue || value, isSecret });
            updateInventoryDisplay();
            updateStats();
            saveGame();
            return true;
        }

        function addToPendingRolls(value, rank, index, variants = [], baseValue = null) {
            if (pendingRolls.length >= maxPendingRolls) {
                return false;
            }
            
            const isSecret = SECRET_RANKS_CHANCES.map(r => r.name).includes(rank.replace(" [HC]", "")) || 
                            rank === "morts luck" || 
                            rank === "breaktime" || 
                            rank.includes("Unobtainable");
            pendingRolls.push({ value, rank, index, variants, baseValue: baseValue || value, isSecret });
            updatePendingDisplay();
            updateStats();
            return true;
        }

        function removeFromInventory(idx) {
            const item = inventory[idx];
            
            let variantText = '';
            if (item.variants && item.variants.length > 0) {
                variantText = item.variants.map(v => {
                    let variantClass = '';
                    if (v.name === "GIANT") variantClass = 'variant-GIANT';
                    else if (v.name === "Mega") variantClass = 'variant-Mega';
                    else if (v.name === "Small") variantClass = 'variant-Small';
                    
                    return `[${v.name}]`;
                }).join('') + ' ';
            }
            
            let suffix = "";
            let displayValue = item.value;
            if (item.rank === "üíØ") suffix = " * üíØ";
            if (item.rank === ":[{(absolute zero)}]:") suffix = " * 0";
            
            if (item.rank === "‚õßSatanic‚õß") {
                suffix = ` (Actual: ${formatNumber(item.value)})`;
                displayValue = -666.66;
            }
            if (item.rank === "Finale.. wait, how'd this get here?") {
                suffix = ` (Actual: ${formatNumber(item.value)})`;
                displayValue = 1e10;
            }
            
            addToTerminal(`Removed from inventory: #${formatInteger(item.index)} ${variantText}${formatNumber(displayValue)} [${item.rank}]${suffix}`, true); 
            
            acceptedRolls.delete(item.index);
            
            const rollElement = document.getElementById(`roll-${item.index}`);
            if (rollElement) {
                rollElement.style.opacity = '1';
                rollElement.style.cursor = 'pointer';
                
                rollElement.onclick = function() { 
                    tryAddToInventory(item.value, item.rank, item.index, rollElement); 
                };

                if (item.rank === "!! EUPHORIA !!") {
                    setTimeout(() => initEuphoriaAnimation(`roll-${item.index}`, "!! EUPHORIA !!"), 10);
                }
                if (item.rank === "?!? bewilderment ?!?") {
                    setTimeout(() => initBewildermentAnimation(`roll-${item.index}`), 10);
                }
            }
            
            inventory.splice(idx, 1);
            updateInventoryDisplay();
            updateStats();
            saveGame();
        }

        function playCutscene(rollValue, isSecret = false) {
            if (!cutscenesEnabled || hardcoreMode) {
                return Promise.resolve();
            }

            return new Promise(resolve => {
                const wasAutoRolling = autoRollInterval !== null;
                if (wasAutoRolling) {
                    toggleAutoRoll();
                }
                
                isCutscenePlaying = true;
                const body = document.body;
                const overlay = document.getElementById('cutscene-overlay');
                const starElement = document.getElementById('star-element');
                
                body.classList.add('cutscene-active');
                
                const { color } = getRankClassAndColor(rollValue);
                starElement.style.color = color;
                
                let starShapeClass = 'star-4'; 
                if (rollValue >= 1e12 && isSecret) {
                    starShapeClass = 'star-12';
                } else if (rollValue >= 1e9 && isSecret) {
                    starShapeClass = 'star-6';
                } else if (rollValue >= 1e12) {
                    starShapeClass = 'star-8';
                }
                
                starElement.className = starShapeClass;
                starElement.style.transform = 'translate(-50%, -50%) rotate(0deg) scale(1)'; 
                let currentScale = 1;
                let currentRotation = 0;
                let rotationSpeed = 3; 
                let sizeInterval = null;
                
                setTimeout(() => {
                    starElement.style.opacity = 1;
                }, STAR_FADE_IN_MS);
                
                const spinUpdate = () => {
                    currentRotation += rotationSpeed;
                    starElement.style.transform = `translate(-50%, -50%) rotate(${currentRotation}deg) scale(${currentScale})`; 
                    if (isCutscenePlaying) {
                        requestAnimationFrame(spinUpdate);
                    }
                };

                requestAnimationFrame(spinUpdate);

                setTimeout(() => {
                    rotationSpeed = 15; 
                    
                    sizeInterval = setInterval(() => {
                        currentScale *= SIZE_MULTIPLIER_PER_UPDATE;
                    }, SIZE_UPDATE_INTERVAL_MS);

                }, SPIN_ACCEL_MS);
                
                setTimeout(() => {
                    starElement.style.opacity = 0;
                    body.classList.add('cutscene-flash');
                    
                    setTimeout(() => {
                        isCutscenePlaying = false;
                        clearInterval(sizeInterval);
                        
                        body.classList.remove('cutscene-flash');
                        body.classList.remove('cutscene-active');
                        
                        setTimeout(() => {
                            starElement.style.transform = 'translate(-50%, -50%) rotate(0deg) scale(1)';
                            starElement.style.color = '';
                            starElement.className = '';
                            if (wasAutoRolling) {
                                toggleAutoRoll();
                            }
                            resolve();
                        }, 500);
                        
                    }, WHITE_FLASH_DURATION_MS);
                    
                }, CUTSCENE_DURATION_MS - WHITE_FLASH_DURATION_MS);
            });
        }

        function initBewildermentAnimation(elementId) {
            const element = document.getElementById(elementId);
            if (!element) return;
            
            const originalText = element.textContent || element.innerText;
            if (!originalText.includes("?!? bewilderment ?!?")) return;
            
            let isQuestionMark = true;
            const intervalId = setInterval(() => {
                if (!document.getElementById(elementId)) {
                    clearInterval(intervalId);
                    delete activeBewildermentIntervals[elementId];
                    return;
                }
                
                if (isQuestionMark) {
                    element.textContent = originalText.replace("?!? bewilderment ?!?", "!?! bewilderment !?!");
                    element.innerHTML = element.innerHTML.replace("?!? bewilderment ?!?", "!?! bewilderment !?!");
                } else {
                    element.textContent = originalText;
                    element.innerHTML = originalText;
                }
                isQuestionMark = !isQuestionMark;
            }, 10);
            
            activeBewildermentIntervals[elementId] = intervalId;
            activeAnimationElements.add(elementId);
        }

        function generateComplexRank() {
            if (Math.random() < COMPLEX_CHANCE) {
                const totalLuck = currentLuck * luckMultiValue;
                const realPart = Math.pow(Math.random(), 3 / POWER_EXPONENT) * (1 + totalLuck);
                const imagPart = Math.pow(Math.random(), 3 / POWER_EXPONENT) * (1 + totalLuck);
                
                const rankInfoReal = getRankInfo(realPart);
                const rankInfoImag = getRankInfo(imagPart);
                
                let displayName = `Complex: ${rankInfoReal.name.replace(" [HC]", "")} + ${rankInfoImag.name.replace(" [HC]", "")}i`;
                if (hardcoreMode) {
                    displayName += " [HC]";
                }
                
                return {
                    isComplex: true,
                    realPart: realPart,
                    imagPart: imagPart,
                    realRankName: rankInfoReal.name,
                    imagRankName: rankInfoImag.name,
                    displayName: displayName
                };
            }
            return null;
        }

        const BOOSTER_SHAPES = ['circle', 'triangle', 'square', 'pentagon', 'hexagon', 'heptagon'];
        const BOOSTER_COLORS = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F'];
        
        function generateBooster() {
            const rand = Math.random();
            const luck = BOOSTER_BASE_LUCK * BOOSTER_LUCK_FORMULA(rand);
            let cost = BOOSTER_COST_FORMULA(luck);
            const shape = BOOSTER_SHAPES[Math.floor(Math.random() * BOOSTER_SHAPES.length)];
            let color = '#FFFFFF';
            
            let variant = null;
            for (const v of VARIANTS) {
                const variantChance = (2.5 * v.chance);
                if (Math.random() < variantChance) {
                    variant = { name: v.name, multiplier: v.multiplier, color: v.color };
                    color = v.color;
                    cost *= Math.pow(v.multiplier, 1.25);
                    break;
                }
            }
            
            return { luck, cost, shape, color, variant };
        }
        
        function refreshBoosterShop() {
            try {
                const count = Math.floor(Math.random() * (15 - 5 + 1)) + 5;
                shopBoosters = [];
                for (let i = 0; i < count; i++) {
                    try {
                        shopBoosters.push(generateBooster());
                    } catch (err) {
                        console.error('Error generating booster:', err);
                    }
                }
                updateShopDisplay();
                saveGame();
            } catch (e) {
                console.error('Shop refresh error:', e);
                addToTerminal('Error refreshing shop: ' + e.message, true);
            }
        }
        
        function openBoosterShop() {
            try {
                if (shopAutoRefreshInterval) {
                    clearInterval(shopAutoRefreshInterval);
                }
                
                refreshBoosterShop();
                const shopPanel = document.getElementById('shop-panel');
                if (shopPanel) {
                    shopPanel.style.display = 'block';
                    addToTerminal('Shop opened! Boosters refresh every 20 seconds.', true);
                    
                    shopAutoRefreshInterval = setInterval(() => {
                        refreshBoosterShop();
                        addToTerminal('Shop refreshed with new boosters!', true);
                    }, 20000);
                } else {
                    addToTerminal('Error: Shop panel not found', true);
                }
            } catch (e) {
                addToTerminal('Error opening shop: ' + e.message, true);
                console.error('Shop error:', e);
            }
        }
        
        function closeBoosterShop() {
            try {
                if (shopAutoRefreshInterval) {
                    clearInterval(shopAutoRefreshInterval);
                    shopAutoRefreshInterval = null;
                }
                const shopPanel = document.getElementById('shop-panel');
                if (shopPanel) {
                    shopPanel.style.display = 'none';
                    addToTerminal('Shop closed.', true);
                }
            } catch (e) {
                console.error('Error closing shop:', e);
            }
        }
        
        function updateShopDisplay() {
            try {
                const shopContent = document.getElementById('shop-content');
                if (!shopContent) {
                    console.error('Shop content element not found');
                    return;
                }
                
                if (shopBoosters.length === 0) {
                    shopContent.innerHTML = '<div style="color: #FFD700; padding: 10px;">Generating boosters...</div>';
                    return;
                }
                
                shopContent.innerHTML = shopBoosters.map((b, idx) => `
                    <div style="display: inline-block; text-align: center; margin: 10px; cursor: pointer; padding: 8px; border: 1px solid #FFD700; border-radius: 5px; background-color: #3a0d6e; transition: all 0.2s;" onclick="buyBoosterFromShop(${idx})" onmouseover="this.style.boxShadow='0 0 10px #FFD700';" onmouseout="this.style.boxShadow='none';">
                        <div style="margin-bottom: 5px; font-size: 12px; color: #FFD700;">Cost: ${formatNumber(b.cost.toFixed(0))}</div>
                        ${generateShapeHTML(b.shape, b.color, b.luck, b.variant)}
                    </div>
                `).join('');
            } catch (e) {
                console.error('Error updating shop display:', e);
                const shopContent = document.getElementById('shop-content');
                if (shopContent) {
                    shopContent.innerHTML = '<div style="color: #ff0000;">Error loading shop</div>';
                }
            }
        }
        
        function buyBoosterFromShop(idx) {
            const booster = shopBoosters[idx];
            if (currency < booster.cost) {
                addToTerminal(`Cannot afford booster (cost: ${formatNumber(booster.cost)})`, true);
                return;
            }
            currency -= booster.cost;
            boosters.push(booster);
            shopBoosters.splice(idx, 1);
            addToTerminal(`Booster purchased! x${booster.luck.toFixed(2)} luck${booster.variant ? ` + ${booster.variant.name}` : ''}`, true);
            updateBoosterDisplay();
            updateShopDisplay();
            updateStats();
            saveGame();
        }
        
        function useBooster(idx) {
            activeBooster = boosters[idx];
            boosters.splice(idx, 1);
            addToTerminal(`Booster activated! Next roll gets x${activeBooster.luck.toFixed(2)} luck`, true);
            updateBoosterDisplay();
            updateStats();
        }
        
        function updateBoosterDisplay() {
            const boosterContent = document.getElementById('boosterContent');
            if (boosters.length === 0) {
                boosterContent.innerHTML = '<div style="color: #888; padding: 10px;">No boosters owned</div>';
            } else {
                boosterContent.innerHTML = boosters.map((b, idx) => `
                    <div style="display: inline-block; text-align: center; margin: 8px; padding: 8px; cursor: pointer; border: 1px solid #FFD700; border-radius: 5px; background-color: #3a0d6e; transition: all 0.2s;" onclick="useBooster(${idx})" onmouseover="this.style.boxShadow='0 0 10px #FFD700';" onmouseout="this.style.boxShadow='none';">
                        ${generateShapeHTML(b.shape, b.color, b.luck, b.variant)}
                        <div style="font-size: 10px; color: #FFD700; margin-top: 5px;">Click to use</div>
                    </div>
                `).join('');
            }
        }
        
        function tryAddToInventory(value, rank, index, element) {
            if (acceptedRolls.has(index)) {
                addToTerminal(`Roll #${formatInteger(index)} has already been accepted!`, true);
                return;
            }
            
            let variants = [];
            let baseValue = value;
            
            if (element && element.dataset) {
                if (element.dataset.variants) {
                    try {
                        variants = JSON.parse(element.dataset.variants);
                    } catch (e) {
                        console.error('Error parsing variants:', e);
                    }
                }
                if (element.dataset.basevalue) {
                    baseValue = parseFloat(element.dataset.basevalue);
                }
            }
            
            if (inventory.length >= maxInventory) {
                if (addToPendingRolls(value, rank, index, variants, baseValue)) {
                    acceptedRolls.add(index);

                    if (activeEuphoriaIntervals[index]) {
                        clearInterval(activeEuphoriaIntervals[index]);
                        delete activeEuphoriaIntervals[index];
                    }
                    
                    if (activeBewildermentIntervals[`roll-${index}`]) {
                        clearInterval(activeBewildermentIntervals[`roll-${index}`]);
                        delete activeBewildermentIntervals[`roll-${index}`];
                    }
                    
                    const variantText = variants.map(v => `[${v.name}]`).join('') + ' ';
                    
                    let suffix = "";
                    let displayValue = value;
                    if (rank === "100") suffix = " * üíØ";
                    if (rank === ":[{(absolute zero)}]:") suffix = " * 0";
                    
                    if (rank === "‚õßSatanic‚õß") {
                        suffix = ` (Actual: ${formatNumber(value)})`;
                        displayValue = -666.66;
                    }
                    if (rank === "Finale.. wait, how'd this get here?") {
                        suffix = ` (Actual: ${formatNumber(value)})`;
                        displayValue = 1e10;
                    }
                    
                    addToTerminal(`Added to pending rolls: #${formatInteger(index)} ${variantText}${formatNumber(displayValue)} [${rank}]${suffix}`, true); 
                    
                    const rollElement = document.getElementById(`roll-${index}`);
                    if (rollElement) {
                        rollElement.style.opacity = '0.5';
                        rollElement.style.cursor = 'not-allowed';
                        rollElement.onclick = null;
                    }
                    
                    saveGame();
                } else {
                    addToTerminal(`Cannot add to inventory or pending rolls: both are full!`, true);
                }
            } else {
                if (addToInventory(value, rank, index, variants, baseValue)) {
                    acceptedRolls.add(index);

                    if (activeEuphoriaIntervals[index]) {
                        clearInterval(activeEuphoriaIntervals[index]);
                        delete activeEuphoriaIntervals[index];
                    }
                    
                    if (activeBewildermentIntervals[`roll-${index}`]) {
                        clearInterval(activeBewildermentIntervals[`roll-${index}`]);
                        delete activeBewildermentIntervals[`roll-${index}`];
                    }
                    
                    const variantText = variants.map(v => `[${v.name}]`).join('') + ' ';
                    
                    let suffix = "";
                    let displayValue = value;
                    if (rank === "100") suffix = " * üíØ";
                    if (rank === ":[{(absolute zero)}]:") suffix = " * 0";
                    
                    if (rank === "‚õßSatanic‚õß") {
                        suffix = ` (Actual: ${formatNumber(value)})`;
                        displayValue = -666.66;
                    }
                    if (rank === "Finale.. wait, how'd this get here?") {
                        suffix = ` (Actual: ${formatNumber(value)})`;
                        displayValue = 1e10;
                    }
                    
                    addToTerminal(`Added to inventory: #${formatInteger(index)} ${variantText}${formatNumber(displayValue)} [${rank}]${suffix}`, true); 
                    
                    const rollElement = document.getElementById(`roll-${index}`);
                    if (rollElement) {
                        rollElement.style.opacity = '0.5';
                        rollElement.style.cursor = 'not-allowed';
                        rollElement.onclick = null;
                    }
                    
                    saveGame();
                }
            }
        }

        function toggleAutoRoll() {
            if (isCutscenePlaying) {
                addToTerminal('Cannot toggle auto-roll during a cutscene!', true);
                return;
            }
            
            const btn = document.getElementById('autoRollBtn');
            if (autoRollInterval) {
                clearInterval(autoRollInterval);
                autoRollInterval = null;
                btn.textContent = 'Auto Roll';
                btn.classList.remove('active');
                addToTerminal('Auto-rolling stopped.', true);
            } else {
                autoAcceptThreshold = parseFloat(document.getElementById('autoAcceptThreshold').value) || 0;
                autoAcceptTrueRNGValue = parseFloat(document.getElementById('autoAcceptTrueRNG').value) || 0;
                autoAcceptSecretThresholdValue = parseFloat(document.getElementById('autoAcceptSecretThreshold').value) || 0;
                autoAcceptOnNewRank = document.getElementById('autoAcceptNewRank').checked;
                
                autoStopThreshold = parseFloat(document.getElementById('autoStopThreshold').value) || 0;
                autoStopTrueRNGValue = parseFloat(document.getElementById('autoStopTrueRNG').value) || 0;
                autoStopSecretThresholdValue = parseFloat(document.getElementById('autoStopSecretThreshold').value) || 0;
                autoStopOnNewRank = document.getElementById('autoStopNewRank').checked;
                
                autoRollInterval = setInterval(roll, AUTO_ROLL_DELAY_MS);
                btn.textContent = 'Stop Auto Roll';
                btn.classList.add('active');
                
                let message = 'Auto-rolling started...';
                const acceptConditions = [];
                const stopConditions = [];
                
                if (autoAcceptThreshold > 0) acceptConditions.push(`value ‚â• ${autoAcceptThreshold}`);
                if (autoAcceptTrueRNGValue > 0) acceptConditions.push(`base ‚â• ${autoAcceptTrueRNGValue}`);
                if (autoAcceptSecretThresholdValue > 0) acceptConditions.push(`secret ‚â• ${autoAcceptSecretThresholdValue}`);
                if (autoAcceptOnNewRank) acceptConditions.push('new rank');
                
                if (autoStopThreshold > 0) stopConditions.push(`value ‚â• ${autoStopThreshold}`);
                if (autoStopTrueRNGValue > 0) stopConditions.push(`base ‚â• ${autoStopTrueRNGValue}`);
                if (autoStopSecretThresholdValue > 0) stopConditions.push(`secret ‚â• ${autoStopSecretThresholdValue}`);
                if (autoStopOnNewRank) stopConditions.push('new rank');
                
                if (acceptConditions.length > 0) {
                    message += ` (Auto-Accept: ${acceptConditions.join(', ')})`;
                }
                
                if (stopConditions.length > 0) {
                    message += ` (Auto-Stop: ${stopConditions.join(', ')})`;
                }
                
                addToTerminal(message, true);
            }
        }

        function buyUpgrade() {
            if (currency >= upgradeCost) {
                currency -= upgradeCost;
                totalUpgrades++;
                maxInventory += INVENTORY_PER_UPGRADE;
                
                updateCalculatedStats();
                
                addToTerminal(
                    `Upgrade purchased! Total upgrades: ${totalUpgrades} | Luck: +${currentLuck.toFixed(3)} | Secret Luck: ${secretLuckMultiplier.toFixed(2)}x | Inventory space: ${maxInventory} | Currency: ${currency.toFixed(2)}`,
                    true
                );
                
                upgradeCost *= UPGRADE_COST_MULTIPLIER;
                addToTerminal(`Next upgrade cost: ${upgradeCost.toFixed(2)}`);
                
                updateStats();
                saveGame();
            } else {
                addToTerminal(
                    `Not enough currency! You have ${currency.toFixed(2)} but need ${upgradeCost.toFixed(2)}`,
                    true
                );
            }
        }

        function buyBulkRoll() {
            if (hardcoreMode) {
                addToTerminal('Cannot buy bulk roll in hardcore mode!', true);
                return;
            }
            
            if (bulkRollLevel >= MAX_BULK_ROLL_LEVEL) {
                addToTerminal('Bulk Roll is already maxed out!', true);
                return;
            }
            
            if (currency >= bulkRollCost) {
                currency -= bulkRollCost;
                bulkRollLevel++;
                
                addToTerminal(
                    `Bulk Roll purchased! Level: ${bulkRollLevel} | Rolls per click: ${bulkRollLevel + 1} | Currency: ${currency.toFixed(2)}`,
                    true
                );
                
                if (bulkRollLevel < MAX_BULK_ROLL_LEVEL) {
                    bulkRollCost *= BULK_ROLL_COST_MULTIPLIER;
                    addToTerminal(`Next Bulk Roll cost: ${bulkRollCost.toFixed(2)}`);
                } else {
                    addToTerminal('Bulk Roll is now MAXED!');
                }
                
                updateStats();
                saveGame();
            } else {
                addToTerminal(
                    `Not enough currency! You have ${currency.toFixed(2)} but need ${bulkRollCost.toFixed(2)}`,
                    true
                );
            }
        }

        function showRarest() {
            if (highestFinalRoll.value === 0 && highestFinalRoll.rank !== "CORRUPTED") {
                addToTerminal('No rolls yet!', true);
            } else {
                const { className, color } = getRankClassAndColor(highestFinalRoll.value, highestFinalRoll.variants, highestFinalRoll.rank);
                let rankClass = className;
                let rollColor = color;
                const displayName = highestFinalRoll.rank;
                let displayValue = highestFinalRoll.value;
                let suffix = "";

                if (displayName === "~Nonavacious~") {
                    rankClass += " secret-nonavacious";
                }
                
                if (displayName === "CORRUPTED") {
                    rankClass += " secret-corrupted";
                    rollColor = "#FFFFFF";
                }
                
                if (displayName === "‚õßSatanic‚õß") {
                    suffix = ` (Actual: ${formatNumber(highestFinalRoll.value)})`;
                    displayValue = -666.66;
                }
                if (displayName === "Finale.. wait, how'd this get here?") {
                    suffix = ` (Actual: ${formatNumber(highestFinalRoll.value)})`;
                    displayValue = 1e10;
                }

                let variantText = '';
                if (highestFinalRoll.variants && highestFinalRoll.variants.length > 0) {
                    variantText = highestFinalRoll.variants.map(v => {
                        let variantClass = '';
                        if (v.name === "GIANT") variantClass = 'variant-GIANT';
                        else if (v.name === "Mega") variantClass = 'variant-Mega';
                        else if (v.name === "Small") variantClass = 'variant-Small';
                        
                        return `[${v.name}]`;
                    }).join('') + ' ';
                }
                
                addToTerminal(
                    `Rarest roll: ${variantText}<span class="satanic-wrapper"><span class="${rankClass}" style="color: ${rollColor};" data-text="${escapeHTML(displayName)}">${formatNumber(displayValue)} [${displayName}]${suffix}</span></span>`,
                    true
                );
            }
        }

        function clearTerminal() {
            const terminal = document.getElementById('terminal');
            const welcomeMsg = terminal.querySelector('.welcome-message');
            terminal.innerHTML = '';
            if (welcomeMsg) {
                terminal.appendChild(welcomeMsg);
            }
        }

        function addToShapeTerminal(text) {
            const terminal = document.getElementById('shape-spawn-output');
            const line = document.createElement('div');
            line.className = 'shape-spawn-line';
            line.innerHTML = text; 
            
            if (terminal.children.length > 20) {
                terminal.removeChild(terminal.firstChild);
            }
            
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
        }

        function calculateGeometrixGain(shape) {
            let baseGain = 0;
            if (shape.name === "Circle") {
                const base = Math.pow(Math.random(), -1.5);
                baseGain = base * 250;
            } else {
                baseGain = shape.rarity / 2;
            }
            
            const gmxMultiplier = 1 + (gmxMultiLevel * 0.5);
            return baseGain * gmxMultiplier;
        }
        
        function despawnShape(shapeId, isCollected = false) {
            const shapeIndex = activeShapes.findIndex(s => s.id === shapeId);
            
            if (shapeIndex === -1) {
                return;
            }

            const shapeData = activeShapes[shapeIndex];
            
            if (shapeData.timerId) {
                clearTimeout(shapeData.timerId);
            }
            
            activeShapes.splice(shapeIndex, 1);
            
            const element = document.getElementById(`shape-${shapeId}`);
            if (element) {
                 if (isCollected) {
                    element.style.transform = 'scale(1.5)';
                    element.style.opacity = '0';
                    setTimeout(() => element.remove(), 200);
                 } else {
                    element.remove();
                 }
            }
            
            if (!isCollected) {
                addToShapeTerminal(`A **${shapeData.name}** despawned (not collected)!`);
            }
            
            saveGame();
        }

        function renderActiveShapes() {
            const shapesField = document.getElementById('shapes-field');
            shapesField.innerHTML = ''; 
            
            activeShapes = activeShapes.filter(shapeData => {
                const timeElapsed = Date.now() - shapeData.spawnTime;
                
                if (timeElapsed >= SHAPE_DESPAWN_TIME_MS) {
                    addToShapeTerminal(`A **${shapeData.name}** despawned while you were away!`);
                    return false;
                }

                const shapeElement = document.createElement('div');
                shapeElement.id = `shape-${shapeData.id}`;
                shapeElement.className = `clickable-shape shape-${shapeData.name.replace(/\s/g, '-')}`;
                shapeElement.style.backgroundColor = shapeData.color;
                shapeElement.style.left = `${shapeData.posX}px`;
                shapeElement.style.top = `${shapeData.posY}px`;
                shapeElement.textContent = shapeData.name[0];
                shapeElement.onclick = () => collectShape(shapeData.id);
                
                shapesField.appendChild(shapeElement);

                const remainingTime = SHAPE_DESPAWN_TIME_MS - timeElapsed;
                shapeData.timerId = setTimeout(() => {
                    despawnShape(shapeData.id, false); 
                }, remainingTime);

                return true;
            });
            
            saveGame();
        }

        function spawnShape() {
            if (!shapesUnlocked) return;
            
            let totalPossibleGain = 0;
            let spawnedCount = 0;
            const spawnCount = bulkShapeLevel + 1; 

            const shapesField = document.getElementById('shapes-field');
            const fieldWidth = shapesField.clientWidth;
            const fieldHeight = shapesField.clientHeight;

            for (let j = 0; j < spawnCount; j++) {
                const cumulativeChances = [];
                let cumulativeSum = 0;

                for (const shape of SHAPES) {
                    const adjustedChance = shape.chance * (1 + shapeLuckBonus);
                    cumulativeSum += adjustedChance;
                    cumulativeChances.push({ maxChance: cumulativeSum, shape: shape });
                }
                
                let rand = Math.random() * cumulativeSum; 
                let selectedShape = null;

                for (const item of cumulativeChances) {
                    if (rand < item.maxChance) { 
                        selectedShape = item.shape;
                        break;
                    }
                }
                
                if (!selectedShape) {
                    selectedShape = SHAPES[0]; 
                }

                const gain = calculateGeometrixGain(selectedShape);
                totalPossibleGain += gain;
                spawnedCount++;
                
                const shapeId = Date.now().toString() + Math.random().toString(36).substring(2, 9);
                const shapeSize = 30;
                const posX = Math.random() * (fieldWidth - shapeSize); 
                const posY = Math.random() * (fieldHeight - shapeSize); 

                const shapeElement = document.createElement('div');
                shapeElement.id = `shape-${shapeId}`;
                shapeElement.className = `clickable-shape shape-${selectedShape.name.replace(/\s/g, '-')}`;
                shapeElement.style.backgroundColor = selectedShape.color;
                shapeElement.style.left = `${posX}px`;
                shapeElement.style.top = `${posY}px`;
                shapeElement.textContent = selectedShape.name[0];

                const shapeData = {
                    id: shapeId,
                    name: selectedShape.name,
                    gain: gain,
                    color: selectedShape.color,
                    posX: posX,
                    posY: posY,
                    spawnTime: Date.now(),
                    timerId: null
                };
                
                shapeData.timerId = setTimeout(() => {
                    despawnShape(shapeId, false);
                }, SHAPE_DESPAWN_TIME_MS);

                activeShapes.push(shapeData);
                
                shapeElement.onclick = () => collectShape(shapeData.id);
                
                shapesField.appendChild(shapeElement);
            }
            
            if (spawnedCount > 0) {
                addToShapeTerminal(`Spawned ${spawnedCount} shapes. Max collection: ${formatGeometrix(totalPossibleGain)} GMX.`);
            }
        }
        
        function collectShape(shapeId) {
            const shapeIndex = activeShapes.findIndex(s => s.id === shapeId);
            
            if (shapeIndex === -1) {
                return; 
            }

            const shapeData = activeShapes[shapeIndex];
            geometrix += shapeData.gain;
            
            addToTerminal(`Collected **${shapeData.name}** (+${formatGeometrix(shapeData.gain)} GMX)!`, true, 'command');

            despawnShape(shapeId, true); 
            
            updateStats();
        }

        function startShapeInterval() {
            if (shapeInterval) clearInterval(shapeInterval);
            if (!shapesUnlocked) return;
            
            shapeInterval = setInterval(spawnShape, currentShapeCooldown);
            
            addToTerminal(`Shape spawning interval set to ${formatCooldown(currentShapeCooldown)}s.`, true, '#00FF00');
        }

        function unlockShapes() {
            if (hardcoreMode) {
                addToTerminal('Cannot unlock shapes in hardcore mode!', true);
                return;
            }
            
            if (currency >= UNLOCK_SHAPES_COST) {
                currency -= UNLOCK_SHAPES_COST;
                shapesUnlocked = true;
                addToTerminal(`**Shapes GUI unlocked!** Start collecting the clickable polygons.`, true, '#00FF00');
                updateCalculatedStats();
                startShapeInterval();
                updateStats();
                saveGame();
            } else {
                addToTerminal(`Not enough currency! Need ${formatNumber(UNLOCK_SHAPES_COST)} to unlock.`, true);
            }
        }

        function buyShapeLuckUpgrade() {
            if (hardcoreMode) {
                addToTerminal('Cannot buy upgrades in hardcore mode!', true);
                return;
            }
            
            if (shapeLuckLevel >= MAX_SHAPE_LUCK_LEVEL) {
                addToTerminal('Shape Luck is maxed out!', true, '#FF00FF');
                return;
            }
            if (geometrix >= shapeLuckCost) {
                geometrix -= shapeLuckCost;
                shapeLuckLevel++;
                
                addToTerminal(
                    `Shape Luck purchased! Level: ${shapeLuckLevel}/${MAX_SHAPE_LUCK_LEVEL}`,
                    true, '#00FF00'
                );
                
                shapeLuckCost *= SHAPE_LUCK_COST_MULTIPLIER;
                updateCalculatedStats();
                updateStats();
                saveGame();
            } else {
                addToTerminal(`Not enough Geometrix! Need ${formatGeometrix(shapeLuckCost)} GMX.`, true);
            }
        }
        
        function buyLuckMultiUpgrade() {
            if (hardcoreMode) {
                addToTerminal('Cannot buy upgrades in hardcore mode!', true);
                return;
            }
            
            if (geometrix >= luckMultiCost) {
                geometrix -= luckMultiCost;
                luckMultiLevel++;
                
                updateCalculatedStats();

                addToTerminal(
                    `Luck Multiplier purchased! Level: ${luckMultiLevel} | New Multi: x${luckMultiValue.toFixed(2)}`,
                    true, '#00FF00'
                );
                
                luckMultiCost *= LUCK_MULTI_COST_MULTIPLIER;
                updateStats();
                saveGame();
            } else {
                addToTerminal(`Not enough Geometrix! Need ${formatGeometrix(luckMultiCost)} GMX.`, true);
            }
        }

        function buyBulkShapeUpgrade() {
            if (hardcoreMode) {
                addToTerminal('Cannot buy upgrades in hardcore mode!', true);
                return;
            }
            
            if (bulkShapeLevel >= MAX_BULK_SHAPE_LEVEL) {
                addToTerminal('Bulk/Cooldown is maxed out!', true, '#FF00FF');
                return;
            }
            if (geometrix >= bulkShapeCost) {
                geometrix -= bulkShapeCost;
                bulkShapeLevel++;
                
                updateCalculatedStats();
                
                addToTerminal(
                    `Bulk/Cooldown purchased! Level: ${bulkShapeLevel}/${MAX_BULK_SHAPE_LEVEL} | Spawns: ${bulkShapeLevel + 1} | Cooldown: ${formatCooldown(currentShapeCooldown)}s`,
                    true, '#00FF00'
                );
                
                if (bulkShapeLevel < MAX_BULK_SHAPE_LEVEL) {
                    bulkShapeCost *= BULK_SHAPE_COST_MULTIPLIER;
                }
                
                startShapeInterval();
                updateStats();
                saveGame();
            } else {
                addToTerminal(`Not enough Geometrix! Need ${formatGeometrix(bulkShapeCost)} GMX.`, true);
            }
        }

        function unlockClicker() {
            if (hardcoreMode) {
                addToTerminal('Cannot unlock clicker in hardcore mode!', true);
                return;
            }
            
            if (clickerUnlocked) {
                addToTerminal('Clicker is already unlocked!', true);
                return;
            }
            if (geometrix >= UNLOCK_CLICKER_COST) {
                geometrix -= UNLOCK_CLICKER_COST;
                clickerUnlocked = true;
                addToTerminal(`**Clicker GUI unlocked!** Click the clover!`, true, '#FFD700');
                updateStats();
                saveGame();
            } else {
                addToTerminal(`Not enough Geometrix! Need ${formatGeometrix(UNLOCK_CLICKER_COST)} GMX.`, true);
            }
        }
        
        function clickClover() {
            const baseGain = Math.pow(Math.random(), -1.5);
            const finalGain = baseGain * (1 + fortuniumLuck);
            fortunium += finalGain;
            
            updateStats();
        }
        
        function buyFortuniumUpgrade(type) {
            if (!clickerUnlocked) return;
            
            if (hardcoreMode) {
                addToTerminal('Cannot buy upgrades in hardcore mode!', true);
                return;
            }
            
            if (type === 'gmx') {
                if (fortunium >= gmxMultiCost) {
                    fortunium -= gmxMultiCost;
                    gmxMultiLevel++;
                    gmxMultiCost *= 1.5;
                    addToTerminal(`GMX Multi upgrade purchased! GMX gain is now +${(gmxMultiLevel * 0.5).toFixed(1)}x`, true, '#FFD700');
                    updateStats();
                    saveGame();
                } else {
                    addToTerminal(`Not enough Fortunium! Need ${formatNumber(gmxMultiCost)} FOR.`, true);
                    return;
                }
            } 
            else if (type === 'fortuniumLuck') {
                if (fortunium >= fortuniumLuckCost) {
                    fortunium -= fortuniumLuckCost;
                    fortuniumLuckLevel++;
                    fortuniumLuck += 0.5;
                    fortuniumLuckCost *= 1.25;
                    addToTerminal(`Fortunium Luck upgrade purchased! Fortunium Luck is now +${fortuniumLuck.toFixed(1)}x`, true, '#FFD700');
                    updateStats();
                    saveGame();
                } else {
                    addToTerminal(`Not enough Fortunium! Need ${formatNumber(fortuniumLuckCost)} FOR.`, true);
                    return;
                }
            }
            else if (type === 'luck') {
                if (clickerLuckLevel >= MAX_CLICKER_LUCK_LEVEL) {
                    addToTerminal('Clicker Luck upgrade is MAXED!', true, '#FF00FF');
                    return;
                }
                if (fortunium >= clickerLuckCost) {
                    fortunium -= clickerLuckCost;
                    clickerLuckLevel++;
                    clickerLuckCost *= 50;
                    addToTerminal(`Clicker Luck upgrade purchased! Level ${clickerLuckLevel}/${MAX_CLICKER_LUCK_LEVEL}.`, true, '#FFD700');
                    updateCalculatedStats();
                    updateStats();
                    saveGame();
                } else {
                    addToTerminal(`Not enough Fortunium! Need ${formatNumber(clickerLuckCost)} FOR.`, true);
                    return;
                }
            }
        }

        function initEuphoriaAnimation(elementId, baseText) {
            const element = document.getElementById(elementId);
            if (!element) return;
            
            if (activeEuphoriaIntervals[elementId]) {
                clearInterval(activeEuphoriaIntervals[elementId]);
            }
            
            const originalHtml = element.innerHTML;
            const textChars = baseText.split('');
            
            const intervalId = setInterval(() => {
                const currentElement = document.getElementById(elementId);
                if (!currentElement) {
                    clearInterval(activeEuphoriaIntervals[elementId]);
                    delete activeEuphoriaIntervals[elementId];
                    return;
                }
                
                const textIndex = currentElement.innerHTML.indexOf(baseText);
                if (textIndex === -1) {
                    currentElement.innerHTML = originalHtml;
                    return;
                }
                
                const prefix = currentElement.innerHTML.substring(0, textIndex);
                const suffix = currentElement.innerHTML.substring(textIndex + baseText.length);

                const newChars = [...textChars];
                
                let idx1 = Math.floor(Math.random() * newChars.length);
                let idx2 = Math.floor(Math.random() * newChars.length);
                while (idx1 === idx2) {
                    idx2 = Math.floor(Math.random() * newChars.length);
                }

                const sym1 = EUPHORIA_SYMBOLS[Math.floor(Math.random() * EUPHORIA_SYMBOLS.length)];
                const sym2 = EUPHORIA_SYMBOLS[Math.floor(Math.random() * EUPHORIA_SYMBOLS.length)];
                newChars[idx1] = `<span style="opacity: 0.7; display: inline-block; transform: scale(1.1);">${sym1}</span>`;
                newChars[idx2] = `<span style="opacity: 0.7; display: inline-block; transform: scale(1.1);">${sym2}</span>`;
                
                currentElement.innerHTML = prefix + newChars.join('') + suffix;

                setTimeout(() => {
                    const stillExists = document.getElementById(elementId);
                    if (stillExists && activeEuphoriaIntervals[elementId]) {
                        stillExists.innerHTML = originalHtml;
                    }
                }, 25);

            }, 100);
            
            activeEuphoriaIntervals[elementId] = intervalId;
            activeAnimationElements.add(elementId);
        }

        function applyUICustomization() {
            const bgColor = document.getElementById('ui-bg-color').value;
            const buttonBg = document.getElementById('ui-button-bg').value;
            const buttonOutline = document.getElementById('ui-button-outline').value;
            const hcColor = document.getElementById('ui-hc-color').value;
            const textColor = document.getElementById('ui-text-color').value;
            
            document.body.style.backgroundColor = bgColor;
            document.body.style.color = textColor;
            
            const buttons = document.querySelectorAll('button:not([style*="background-color"])');
            buttons.forEach(btn => {
                btn.style.backgroundColor = buttonBg;
                btn.style.borderColor = buttonOutline;
                btn.style.color = textColor;
            });
            
            const hcElements = document.querySelectorAll('.hardcore-mode-active, .hardcore-rank');
            hcElements.forEach(el => {
                el.style.borderColor = hcColor;
            });
            
            const uiSettings = {
                bg: bgColor,
                buttonBg: buttonBg,
                buttonOutline: buttonOutline,
                hcColor: hcColor,
                textColor: textColor
            };
            localStorage.setItem('calisRNG_UI', JSON.stringify(uiSettings));
            
            addToTerminal('UI customization applied!', true);
        }

        function resetUICustomization() {
            document.getElementById('ui-bg-color').value = '#4a148c';
            document.getElementById('ui-button-bg').value = '#808080';
            document.getElementById('ui-button-outline').value = '#ff69b4';
            document.getElementById('ui-hc-color').value = '#ff0000';
            document.getElementById('ui-text-color').value = '#ffffff';
            
            applyUICustomization();
            
            addToTerminal('UI reset to defaults!', true);
        }

        function loadUICustomization() {
            const saved = localStorage.getItem('calisRNG_UI');
            if (saved) {
                try {
                    const uiSettings = JSON.parse(saved);
                    document.getElementById('ui-bg-color').value = uiSettings.bg;
                    document.getElementById('ui-button-bg').value = uiSettings.buttonBg;
                    document.getElementById('ui-button-outline').value = uiSettings.buttonOutline;
                    document.getElementById('ui-hc-color').value = uiSettings.hcColor;
                    document.getElementById('ui-text-color').value = uiSettings.textColor;
                    
                    setTimeout(() => applyUICustomization(), 100);
                } catch(e) {
                    console.error('Error loading UI settings:', e);
                }
            }
        }

        function refreshAllUI() {
            updateStats();
            updateInventoryDisplay();
            updateIndexDisplay();
            updatePendingDisplay();
            
            if (shapesUnlocked) {
                const shapesGui = document.getElementById('shapes-gui');
                if (shapesGui) {
                    shapesGui.style.display = 'block';
                    shapesGui.offsetHeight;
                }
                renderActiveShapes();
            }
            
            if (clickerUnlocked) {
                const clickerGui = document.getElementById('clicker-gui');
                if (clickerGui) {
                    clickerGui.style.display = 'block';
                    clickerGui.offsetHeight;
                }
            }
            
            preserveAnimations();
        }

        function startEvent(event) {
            if (hardcoreMode) return;
            
            if (currentEvent) {
                clearTimeout(currentEvent.timeoutId);
                endEvent(currentEvent);
            }
            
            currentEvent = { 
                name: event.name, 
                duration: event.duration, 
                description: event.description, 
                targets: event.targets, 
                multiplier: event.multiplier, 
                eventChanceBoost: event.eventChanceBoost 
            };
            eventEndTime = Date.now() + event.duration;

            addToTerminal(`üö® EVENT STARTED: **${event.name}**! ${event.description} for ${event.duration / 1000} seconds!`, true, 'rank-1000-10000'); 

            if (event.name === "Lol") {
                eventCheckChance = event.eventChanceBoost; 
            } else {
                eventCheckChance = 1;
            }

            currentEvent.timeoutId = setTimeout(() => {
                endEvent(event);
            }, event.duration);

            updateStats();
        }

        function endEvent(event) {
            addToTerminal(`‚úÖ EVENT ENDED: **${event.name}** is over.`, true);

            if (event.name === "Lol") {
                eventCheckChance = 1;
            }

            if (currentEvent && currentEvent.name === event.name) {
                currentEvent = null;
                eventEndTime = 0;
            }

            updateStats();
        }
        
        function resumeEvent(event, remainingDuration) {
            if (hardcoreMode) return;
            
            currentEvent = event;
            if (event.name === "Lol") {
                eventCheckChance = event.eventChanceBoost; 
            } else {
                eventCheckChance = 1;
            }
            
            currentEvent.timeoutId = setTimeout(() => {
                endEvent(event);
            }, remainingDuration);
            
            addToTerminal(`Resuming active event: **${event.name}** (${(remainingDuration / 1000).toFixed(1)}s left).`, true, 'rank-1000-10000');
        }

        function checkEvent() {
            if (hardcoreMode || currentEvent) return; 

            for (const event of EVENTS) {
                const adjustedChance = event.chance / eventCheckChance;

                if (Math.random() < adjustedChance) {
                    startEvent(event);
                    return; 
                }
            }
        }

        function startEventLoop() {
            if (eventInterval) clearInterval(eventInterval);
            eventInterval = setInterval(checkEvent, EVENT_CHECK_INTERVAL_MS);
        }

        const LZString = {
            compressToBase64: function(input) {
                try {
                    if (!input) return '';
                    const base64 = btoa(unescape(encodeURIComponent(input)));
                    return base64
                        .replace(/\+/g, '-')
                        .replace(/\//g, '_')
                        .replace(/=+$/g, '');
                } catch (e) {
                    console.error('Compression error:', e);
                    return '';
                }
            },
            decompressFromBase64: function(input) {
                try {
                    if (!input) return '';
                    let base64 = input
                        .replace(/-/g, '+')
                        .replace(/_/g, '/');
                    while (base64.length % 4) {
                        base64 += '=';
                    }
                    return decodeURIComponent(escape(atob(base64)));
                } catch (e) {
                    console.error('Decompression error:', e);
                    return '';
                }
            }
        };

        // Initialize the game
        document.addEventListener('keydown', function(e) {
            if (e.key === 'r' && e.target.tagName !== 'INPUT') {
                e.preventDefault();
                roll();
            }
        });
        
        document.getElementById('autoAcceptThreshold').addEventListener('change', (e) => {
            autoAcceptThreshold = parseFloat(e.target.value) || 0;
        });
        document.getElementById('autoAcceptSecretThreshold').addEventListener('change', (e) => {
            autoAcceptSecretThresholdValue = parseFloat(e.target.value) || 0;
        });
        document.getElementById('autoAcceptNewRank').addEventListener('change', (e) => {
            autoAcceptOnNewRank = e.target.checked;
        });
        document.getElementById('autoAcceptTrueRNG').addEventListener('change', (e) => {
            autoAcceptTrueRNGValue = parseFloat(e.target.value) || 0;
        });
        
        document.getElementById('autoStopThreshold').addEventListener('change', (e) => {
            autoStopThreshold = parseFloat(e.target.value) || 0;
        });
        document.getElementById('autoStopSecretThreshold').addEventListener('change', (e) => {
            autoStopSecretThresholdValue = parseFloat(e.target.value) || 0;
        });
        document.getElementById('autoStopNewRank').addEventListener('change', (e) => {
            autoStopOnNewRank = e.target.checked;
        });
        document.getElementById('autoStopTrueRNG').addEventListener('change', (e) => {
            autoStopTrueRNGValue = parseFloat(e.target.value) || 0;
        });

        document.getElementById('clover-clicker').addEventListener('click', () => {
            if (!clickerUnlocked) return;
            clickClover();
            
            const clover = document.getElementById('clover-clicker');
            clover.style.transform = 'scale(0.9)';
            setTimeout(() => {
                clover.style.transform = 'scale(1)';
            }, 100);
        });

        document.getElementById('sciNotationThreshold').addEventListener('change', (e) => {
            const value = parseFloat(e.target.value);
            if (!isNaN(value) && value > 0) {
                sciNotationThreshold = value;
                addToTerminal(`Scientific notation threshold set to ${formatNumber(value)}`, true);
                updateStats();
                preserveAnimations();
                saveGame();
            }
        });

        const welcomeLine = document.createElement('div');
        welcomeLine.className = 'output-line welcome-message';
        welcomeLine.textContent = 'Welcome to calis RNG game!';
        document.getElementById('terminal').appendChild(welcomeLine);
        addToTerminal('Click rolls to add them to your inventory!');
        
        loadGame();
        loadUICustomization();
        refreshAllUI();
        startEventLoop();
        
        setTimeout(refreshAllUI, 500);
    </script>
    
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(error => {
                        console.log('ServiceWorker registration failed: ', error);
                    });
            });
        }
    </script>
</body>
</html>
