<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>calis RNG game</title>
    
    <meta name="theme-color" content="#2d0051">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icons/icon-192x192.png">
    <style>
        /* CSS is unchanged, but included for completeness */
        body {
            font-family: 'Courier New', monospace;
            background-color: #4a148c;
            color: #ffffff;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            color: #ffffff;
        }
        .main-container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
        }
        #terminal {
            background-color: #2d0051;
            border: 2px solid #ff69b4;
            border-radius: 5px;
            padding: 20px;
            min-height: 400px;
            max-height: 500px;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        .output-line {
            margin: 5px 0;
        }
        .command {
            color: #ff69b4;
        }
        .welcome-message {
            color: #ff69b4;
            font-weight: bold;
        }
        .stats {
            background-color: #2d0051;
            border: 2px solid #ff69b4;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .stat-item {
            margin: 8px 0;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            background-color: #808080;
            color: #ffffff;
            border: 2px solid #ff69b4;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
        }
        button:hover {
            background-color: #a0a0a0;
        }
        button:active {
            transform: scale(0.95);
        }
        button:disabled {
            background-color: #555;
            border-color: #888;
            color: #aaa;
            cursor: not-allowed;
        }
        button.active {
            background-color: #ff69b4;
            color: #000;
        }
        #inventory, #index {
            background-color: #2d0051;
            border: 2px solid #ff69b4;
            border-radius: 5px;
            padding: 20px;
            min-height: 400px;
            max-height: 500px;
            overflow-y: auto;
        }
        .inventory-item {
            background-color: #4a148c;
            border: 1px solid #ff69b4;
            padding: 10px;
            margin: 5px 0;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .inventory-item:hover {
            background-color: #5a1a9c;
            transform: translateX(5px);
        }
        .section-header {
            font-size: 18px;
            margin-bottom: 10px;
            color: #ff69b4;
            font-weight: bold;
        }
        .clickable-roll {
            cursor: pointer;
            display: inline-block;
            transition: all 0.2s;
        }
        .clickable-roll:hover {
            transform: scale(1.05);
            text-shadow: 0 0 10px currentColor;
        }
        .index-item {
            background-color: #4a148c;
            border: 1px solid #ff69b4;
            padding: 8px;
            margin: 5px 0;
            border-radius: 3px;
        }
        .index-item.discovered {
            border-color: #00ff00;
        }
        .index-item.locked {
            opacity: 0.5;
            border-color: #666;
        }
        
        .autoroll-settings {
            background-color: #2d0051;
            border: 2px solid #ff69b4;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .autoroll-setting-item {
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .autoroll-setting-item label {
            flex-shrink: 0;
        }
        
        .autoroll-setting-item input[type="number"] {
            background-color: #4a148c;
            color: #ffffff;
            border: 1px solid #ff69b4;
            padding: 5px 10px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            width: 150px;
        }
        
        .autoroll-setting-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        /* Rank colors */
        .rank-1-1000 { color: #ffffff; }
        .rank-1000-10000 { color: #ffff00; }
        .rank-10000-100000 { color: #00ffff; }
        .rank-100000-1000000 { color: #0000cd; }
        .rank-1000000-100000000 { color: #ff0000; }
        .rank-100000000-1000000000 { color: #8b0000; }
        .rank-1000000000-10000000000 { color: #00ff00; }
        .rank-10000000000-100000000000 { color: #ffc0cb; } 
        .rank-100000000000-1000000000000 { color: #a9a9a9; } 
        .rank-1000000000000-100000000000000 { color: #ff69b4; }
        .rank-improbable { color: #008080; }
        .variant-roll {} 
        
        .rank-rainbow {
            background: linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: rainbow-shift 3s linear infinite;
            background-size: 200% 100%;
        }

        /* ADDED: Unobtainable rank style */
        .rank-unobtainable {
            background: linear-gradient(90deg, #000000, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 
                1px 1px 0 #808080,
                -1px -1px 0 #808080,
                1px -1px 0 #808080,
                -1px 1px 0 #808080,
                0 1px 0 #808080,
                1px 0 0 #808080,
                0 -1px 0 #808080,
                -1px 0 0 #808080;
            font-weight: bold;
        }

        .secret-nonavacious {
            filter: drop-shadow(0 0 5px #00BFFF); 
        }
        
        @keyframes rainbow-shift {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }

        /* --- CUTSCENE STYLES --- */
        #cutscene-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000000;
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out; 
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .cutscene-active #cutscene-overlay {
            opacity: 1;
            pointer-events: all;
        }
        
        .cutscene-flash #cutscene-overlay {
            background-color: #ffffff;
        }

        #star-element {
            position: absolute; 
            top: 50%; 
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            opacity: 0;
            transition: opacity 0.5s ease-in;
            filter: drop-shadow(0 0 15px currentColor);
            background-color: currentColor; 
        }
        
        .star-4 {
            clip-path: polygon(50% 0%, 61% 39%, 100% 50%, 61% 61%, 50% 100%, 39% 61%, 0% 50%, 39% 39%);
        }
        
        .star-6 {
            clip-path: polygon(50% 0%, 65% 20%, 100% 30%, 80% 50%, 100% 70%, 65% 80%, 50% 100%, 35% 80%, 0% 70%, 20% 50%, 0% 30%, 35% 20%);
        }
        
        .star-8 {
            clip-path: polygon(50% 0%, 58% 30%, 100% 30%, 66% 50%, 100% 70%, 58% 70%, 50% 100%, 42% 70%, 0% 70%, 34% 50%, 0% 30%, 42% 30%);
        }
        
        .star-12 {
            clip-path: polygon(50% 0%, 55% 15%, 70% 15%, 75% 0%, 80% 15%, 95% 15%, 100% 30%, 95% 45%, 100% 70%, 95% 85%, 100% 85%, 75% 100%, 70% 85%, 55% 85%, 50% 100%, 45% 85%, 30% 85%, 25% 100%, 20% 85%, 5% 85%, 0% 70%, 5% 45%, 0% 30%, 5% 15%, 20% 15%, 25% 0%, 30% 15%, 45% 15%);
        }

        /* --- END CUTSCENE STYLES --- */

        /* --- NEW: SHAPES GUI STYLES --- */
        #shapes-gui {
            background-color: #2d0051;
            border: 2px solid #00FF00; /* Green border for new UI */
            padding: 20px;
            border-radius: 5px;
            /* REMOVED: margin-top: 20px; to allow it to sit flush with its new parent grid cell */
            display: none; /* Hidden by default */
        }

        /* NEW: Container for clickable shapes */
        .shapes-field {
            background-color: #1a0033;
            border: 1px dashed #00FF00;
            min-height: 200px;
            max-height: 300px;
            overflow: hidden; 
            position: relative;
            margin-bottom: 15px;
        }

        /* NEW: Styles for the individual clickable polygon */
        .clickable-shape {
            position: absolute;
            width: 30px;
            height: 30px;
            cursor: pointer;
            transition: transform 0.2s, opacity 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            font-weight: bold;
            color: #000;
            text-shadow: 0 0 3px currentColor;
            border-radius: 2px;
            animation: float 5s ease-in-out infinite alternate; 
        }

        @keyframes float {
            0% { transform: translateY(0px) rotate(0deg); }
            100% { transform: translateY(-5px) rotate(5deg); }
        }

        /* Shape-specific clip-paths for visual polygons */
        .shape-Triangle { clip-path: polygon(50% 0%, 0% 100%, 100% 100%); }
        .shape-Square { clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%); }
        .shape-Pentagon { clip-path: polygon(50% 0%, 100% 38%, 81% 100%, 19% 100%, 0% 38%); }
        .shape-Hexagon { clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%); }
        .shape-7-Sided-Polygon { clip-path: polygon(50% 0%, 90% 20%, 100% 60%, 75% 100%, 25% 100%, 0% 60%, 10% 20%); }
        .shape-Octagon { clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%); }
        .shape-Circle { border-radius: 50%; }

        /* Retained for the smaller log */
        .shape-spawn-output {
            background-color: #1a0033;
            border: 1px solid #00FF00;
            padding: 10px;
            min-height: 50px;
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 15px;
        }
        
        .shape-spawn-line {
            margin: 5px 0;
            color: #00FF00; /* Bright green text */
        }
        
        .shapes-upgrades {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        /* --- END NEW STYLES --- */

        /* --- NEW: CLICKER GUI STYLES --- */
        #clicker-gui {
            background-color: #2d0051;
            border: 2px solid #FFD700; /* Gold border */
            padding: 20px;
            border-radius: 5px;
        }

        #clover-clicker:active {
            transform: scale(0.9);
        }
        /* --- END NEW STYLES --- */
        
        /* --- NEW: SATANIC SECRET STYLE (MODIFIED) --- */
        .satanic-wrapper {
            position: relative;
            display: inline-block; 
            z-index: 0; /* Create stacking context */
        }
        
        .satanic-wrapper::before {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            width: 2.5em; /* Scaled with text */
            height: 2.5em; /* Scaled with text */
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><polygon points="50,5 61,40 98,40 68,62 79,96 50,75 21,96 32,62 2,40 39,40" style="fill:red;"/></svg>');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            
            /* Center and set behind text */
            transform: translate(-50%, -50%); 
            z-index: -1; 
            opacity: 0.75; /* Make it a bit subtle */
            
            /* 6.66 RPM = 9.009 seconds per rotation */
            animation: rotate-pentagram 9.009s linear infinite;
        }
        
        @keyframes rotate-pentagram {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
        /* --- END NEW STYLE --- */

        /* --- NEW: CORRUPTED SECRET STYLE --- */
        .secret-corrupted {
            display: inline-block; /* Needed for transform */
            animation: corrupted-shake 30ms linear infinite;
            filter: invert(100%);
        }
        
        @keyframes corrupted-shake {
            0%    { transform: rotate(0deg); }
            16.67% { transform: rotate(22.5deg); }
            33.33% { transform: rotate(45deg); }
            50%    { transform: rotate(0deg); }
            66.67% { transform: rotate(-22.5deg); }
            83.33% { transform: rotate(-45deg); }
            100%   { transform: rotate(0deg); }
        }
        /* --- END NEW STYLE --- */


        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 768px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body class="cutscene-inactive">
    <h1>calis RNG game</h1>
    
    <div class="stats">
        <div class="stat-item">Currency: <span id="currency">0.00</span></div>
        <div class="stat-item">Geometrix: <span id="geometrix">0.00</span></div>
        <div class="stat-item">Total Upgrades: <span id="upgrades">0</span></div>
        <div class="stat-item">Luck: +<span id="luck">0.000</span></div>
        <div class="stat-item">Luck Multiplier: <span id="luckMulti">1.00</span>x</div>
        <div class="stat-item">Secret Luck: <span id="secretLuck">1.00</span>x</div>
        <div class="stat-item">Variant Chance: <span id="variantChance">1.00</span>x</div>
        <div class="stat-item">Next Upgrade Cost: <span id="upgradeCost">50.00</span></div>
        <div class="stat-item">Bulk Roll (Lvl <span id="bulkRollLevel">0</span>): <span id="bulkRollAmount">1</span> roll/click</div>
        <div class="stat-item">Next Bulk Roll Cost: <span id="bulkRollCost">500,000.00</span></div>
        <div class="stat-item">Inventory: <span id="inventoryCount">0</span>/<span id="inventoryMax">10</span></div>
        <div class="stat-item">Rarest Roll: <span id="rarest">None yet</span></div>
        <div class="stat-item">Ranks Discovered: <span id="ranksDiscovered">0</span>/<span id="totalRanks">56</span></div>
    </div>

    <div class="autoroll-settings" style="padding-bottom: 5px;">
        <div class="section-header">Auto Accept Settings</div>
        <div class="autoroll-setting-item">
            <label>Accept on value ‚â•:</label>
            <input type="number" id="autoAcceptThreshold" value="0" step="0.000001" placeholder="Enter minimum value">
        </div>
        <div class="autoroll-setting-item">
            <label>Accept on base rank ‚â•:</label>
            <input type="number" id="autoAcceptTrueRNG" value="0" step="0.000001" placeholder="Enter minimum base value">
        </div>
        <div class="autoroll-setting-item">
            <label>Accept on secret rarity ‚â•:</label>
            <input type="number" id="autoAcceptSecretThreshold" value="0" step="0.000001" placeholder="Enter minimum rarity">
        </div>
        <div class="autoroll-setting-item">
            <input type="checkbox" id="autoAcceptNewRank">
            <label for="autoAcceptNewRank">Accept on new rank discovery</label>
        </div>
        
        <!-- NEW: Auto Stop Settings -->
        <div class="section-header" style="margin-top: 15px;">Auto Stop Settings</div>
        <div class="autoroll-setting-item">
            <label>Stop on value ‚â•:</label>
            <input type="number" id="autoStopThreshold" value="0" step="0.000001" placeholder="Enter minimum value">
        </div>
        <div class="autoroll-setting-item">
            <label>Stop on base rank ‚â•:</label>
            <input type="number" id="autoStopTrueRNG" value="0" step="0.000001" placeholder="Enter minimum base value">
        </div>
        <div class="autoroll-setting-item">
            <label>Stop on secret rarity ‚â•:</label>
            <input type="number" id="autoStopSecretThreshold" value="0" step="0.000001" placeholder="Enter minimum rarity">
        </div>
        <div class="autoroll-setting-item">
            <input type="checkbox" id="autoStopNewRank">
            <label for="autoStopNewRank">Stop on new rank discovery</label>
        </div>
        
        <!-- UPDATED: Import / Export Save with no text cap -->
        <div class="section-header" style="margin-top: 15px;">Import / Export Save</div>
        <textarea id="saveDataTextarea" style="width: 95%; min-height: 80px; background-color: #4a148c; color: #ffffff; border: 1px solid #ff69b4; font-family: 'Courier New', monospace; margin-bottom: 15px; padding: 5px; resize: vertical;" placeholder="Paste save data here and click 'Import Save'"></textarea>
    </div>

    <div class="controls">
        <button onclick="roll()">Roll (r)</button>
        <button id="autoRollBtn" onclick="toggleAutoRoll()">Auto Roll</button>
        <button onclick="buyUpgrade()">Buy Upgrade</button>
        <button id="buyBulkRollBtn" onclick="buyBulkRoll()">Buy Bulk Roll</button>
        <button onclick="showRarest()">Show Rarest</button>
        <button onclick="clearTerminal()">Clear Terminal</button>
        <button onclick="saveGame()">Save Game</button>
        <button onclick="exportSave()">Export Save</button> <button onclick="importSave()">Import Save</button> <button id="cutsceneToggleBtn" onclick="toggleCutscenes()">Cutscenes: ON</button>
    </div>

    
    <div class="main-container">
        <div>
            <div id="terminal"></div>
        </div>
        <div>
            <div id="inventory">
                <div class="section-header">Inventory</div>
                <div class="controls" style="grid-template-columns: 1fr 1fr; margin-bottom: 10px;">
                    <button onclick="sortInventory('leastRarest')">Least Rarest</button>
                    <button onclick="sortInventory('mostRarest')">Most Rarest</button>
                </div>
                <div id="inventoryContent">Empty</div>
            </div>
        </div>
        <div>
            <div id="index">
                <div class="section-header">Index (Ranks Discovered)</div>
                <div id="indexContent">Roll to discover ranks!</div>
            </div>
            
            <div class="controls" id="shapes-unlock-controls" style="margin-top: 20px;">
                <button id="unlockShapesBtn" onclick="unlockShapes()">Unlock Shapes GUI (5,000,000.00 Currency)</button>
            </div>
            
            <div id="shapes-gui">
                <div class="section-header" style="color: #00FF00;">Shapes GUI</div>
                
                <div id="shapes-field" class="shapes-field"></div>

                <div class="stat-item">Current Shape Luck: +<span id="shapeLuckBonus">0.0</span>x</div>
                <div class="stat-item">Shapes/Spawn: <span id="bulkShapeAmount">1</span> (Lvl <span id="bulkShapeLevel">0</span>)</div>
                <div class="stat-item">Spawn Cooldown: <span id="shapeCooldown">2.0000</span>s</div>
                
                <div class="shape-spawn-output" id="shape-spawn-output" style="height: 50px;">Waiting for first spawn...</div>

                <div class="shapes-upgrades">
                    <button id="buyShapeLuckBtn" onclick="buyShapeLuckUpgrade()">Shape Luck (+0.1x) - Cost: <span id="shapeLuckCost">5.00</span> GMX</button>
                    <button id="buyLuckMultiBtn" onclick="buyLuckMultiUpgrade()">Luck Multiplier (x2.00) - Cost: <span id="luckMultiCost">100.00</span> GMX</button>
                    <button id="buyBulkShapeBtn" onclick="buyBulkShapeUpgrade()">Bulk/Cooldown Lvl <span id="bulkShapeLevelBtn">1</span> - Cost: <span id="bulkShapeCost">50.00</span> GMX</button>
                    <button id="buyClickerUnlockBtn" onclick="unlockClicker()">Unlock Clicker - Cost: 1,000,000.00 GMX</button>
                </div>
            </div>
            
            <div id="clicker-gui" style="display: none; margin-top: 20px;">
                <div class="section-header" style="color: #FFD700;">Clicker</div>
                
                <div class="stats" style="background-color: #2d0051; border-color: #FFD700; padding: 10px; margin-bottom: 10px;">
                    <div class="stat-item">Fortunium: <span id="fortunium">0.00</span></div>
                    <div class="stat-item">Fortunium Luck: +<span id="fortuniumLuck">0.00</span>x</div>
                </div>

                <div id="clover-field" style="text-align: center; margin-bottom: 15px;">
                     <span id="clover-clicker" style="font-size: 80px; cursor: pointer; display: inline-block; transition: transform 0.1s; user-select: none;">üçÄ</span>
                </div>

                <div class="clicker-upgrades" style="display: flex; flex-wrap: wrap; gap: 10px;">
                    <button id="buyGmxMultiBtn" onclick="buyFortuniumUpgrade('gmx')">GMX Multi (+0.5x) - Cost: <span id="gmxMultiCost">75.00</span> FOR</button>
                    <button id="buyFortuniumLuckBtn" onclick="buyFortuniumUpgrade('fortuniumLuck')">Fortunium Luck (+0.5x) - Cost: <span id="fortuniumLuckCost">125.00</span> FOR</button>
                    <button id="buyClickerLuckBtn" onclick="buyFortuniumUpgrade('luck')">Luck Multi (+0.5x) - Cost: <span id="clickerLuckCost">1000.00</span> FOR</button>
                </div>
            </div>
            </div>
    </div>

    <div id="cutscene-overlay">
        <div id="star-element" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);"></div>
        </div>
    <script>
        // --- CONSTANTS ---
        const POWER_EXPONENT = -2.5;
        const AUTO_ROLL_DELAY_MS = 12.5;
        // NERF: Upgrade cost multiplier changed from 1.25 to 1.15
        const UPGRADE_COST_MULTIPLIER = 1.15;
        // MODIFIED: Luck scaling changed from 1.777 to 2.5
        const LUCK_PER_UPGRADE = 2.5;
        // MODIFIED: Inventory space per upgrade
        const INVENTORY_PER_UPGRADE = 10;
        const VARIANT_CHANCE_PER_UPGRADE = 0.05;
        const MAX_VARIANT_CHANCE_MULTIPLIER = 12.5;
        const SECRET_LUCK_PER_UPGRADE = 0.25;
        const MAX_SECRET_LUCK = 5;
        const BULK_ROLL_COST_MULTIPLIER = 1.75;
        const MAX_BULK_ROLL_LEVEL = 4;
        const MAX_VARIANTS_PER_ROLL = 5; 
        
        // CUTSCENE CONSTANTS
        const CUTSCENE_DURATION_MS = 7000;
        const STAR_FADE_IN_MS = 2000;
        const SPIN_ACCEL_MS = 5000;
        const SIZE_UPDATE_INTERVAL_MS = 10; 
        const SIZE_MULTIPLIER_PER_UPDATE = 1.02;
        const WHITE_FLASH_DURATION_MS = 1000; 

        // --- NEW EVENT CONSTANTS ---
        // CHANGED: Event check interval from 2500ms to 500ms
        const EVENT_CHECK_INTERVAL_MS = 500; 

        const EVENTS = [
            { 
                name: "Error", 
                chance: 1/40.4, 
                duration: 40000, // 40 seconds
                description: "makes nil, Title Label Missing and unknown's rarity be easier by x4",
                targets: ["nil", "Title Label Missing", "?!? unknown ?!?"],
                multiplier: 4 
            },
            { 
                name: "Lol", 
                chance: 1/69, 
                duration: 20000, // 20 seconds
                description: "makes every meme related secret easier by 6.94x and boosts future event chances",
                targets: ["r", "fish", "cheese", "?!? bewilderment ?!?"], // UPDATED: Changed from "In im table ?!?!?" to "?!? bewilderment ?!?"
                multiplier: 6.94,
                eventChanceBoost: 69 
            },
            { 
                name: "UNDEFINED", 
                chance: 1/300, 
                duration: 30000, // 30 seconds
                description: "makes ranks 'unknown,' 'title label missing' and 'absolute zero' be x5 times easier",
                targets: ["?!? unknown ?!?", "Title Label Missing", ":[{(absolute zero)}]:"],
                multiplier: 5
            },
            // NEW: Modified event
            { 
                name: "Modified", 
                chance: 1/750, 
                duration: 15000, // 15 seconds
                description: "makes every variant x5 times easier",
                targets: [], // Not target-based
                multiplier: 2.5
            },
            // NEW: Self Insert event
            { 
                name: "Self Insert", 
                chance: 1/777, 
                duration: 77700, // 77.7 seconds
                description: "makes cali^2 easier by x777,777.777",
                targets: ["cali^2"],
                multiplier: 777777.777
            },
            // NEW: Hellish event
            { 
                name: "Hellish", 
                chance: 1/66.66, 
                duration: 25000, // 25 seconds
                description: "makes ‚õßSatanic‚õß, Seize and Insanity x6.66 easier",
                targets: ["‚õßSatanic‚õß", "Seize", "Insanity"],
                multiplier: 6.66 
            },
            // NEW: Hidden event
            { 
                name: "Hidden", 
                chance: 1/1000, 
                duration: 5000, // 5 seconds
                description: "makes EVERY secret X7.77 easier",
                targets: ["ALL_SECRETS"], // Special flag
                multiplier: 7.77
            }
        ];

        // UPDATED VARIANTS ARRAY
        const VARIANTS = [
            // MODIFIED: Shiny chance from 1/25 to 1/100 (multiplier remains 25)
            { name: "Shiny", chance: 1/100, multiplier: 25, color: "#FFD700" },
            { name: "Gilded", chance: 1/125, multiplier: 125, color: "#FFA500" },
            { name: "Spectral", chance: 1/625, multiplier: 625, color: "#9400D3" },
            { name: "Extraordinary", chance: 1/1250, multiplier: 1250, color: "#FF1493" },
            { name: "Myriad", chance: 1/2500, multiplier: 2500, color: "#00FFFF" },
            { name: "Charred", chance: 1/4000, multiplier: 4000, color: "#FF4500" },
            { name: "Expert", chance: 1/7500, multiplier: 7500, color: "#00BFFF" },
            // NEW: Wind variant
            { name: "Wind", chance: 1/12500, multiplier: 12500, color: "#ADD8E6" }, 
            // NEW: Mega variant
            { name: "Mega", chance: 1/25000, multiplier: 25000, color: "#FF00FF" }, 
            // NEW: Small variant
            { name: "Small", chance: 1/35000, multiplier: 35000, color: "#BEBEBE" }, 
            // NEW: Monument variant
            { name: "Monument", chance: 1/55555, multiplier: 55555, color: "#8B4513" }, 
            { name: "ETERNAL DAWN", chance: 1/77777, multiplier: 77777, color: "#FFFFFF" },
            { name: ">Finale<", chance: 1/100000, multiplier: 100000, color: "#D2691E" },
            // NEW: Solar variant
            { name: "Solar", chance: 1/250000, multiplier: 250000, color: "#FFA500" },
            // NEW: Atomic variant
            { name: "Atomic", chance: 1/494500, multiplier: 494500, color: "#32CD32" }
        ];

        // NEW RANK TIER: Improbable
        const RANK_TIERS = [
            { min: 1, max: 5, name: "Common" },
            { min: 5, max: 25, name: "Natural" },
            { min: 25, max: 50, name: "Uncommon" },
            { min: 50, max: 100, name: "Normal" },
            { min: 100, max: 500, name: "Divine" },
            { min: 500, max: 1000, name: "Grandiose" },
            { min: 1000, max: 2500, name: "Decent" },
            { min: 2500, max: 7500, name: "Unreal" },
            { min: 7500, max: 25000, name: "Cosmic" },
            { min: 25000, max: 100000, name: "Eternal" },
            { min: 100000, max: 1e6, name: "Iridescent" },
            { min: 1e6, max: 1e7, name: "Heavenly" },
            { min: 1e7, max: 5e7, name: "Unattainable" },
            { min: 5e7, max: 1e8, name: "Gigantic" }, // MODIFIED: max changed from 1e9 to 1e8
            // NEW RANKS START
            { min: 1e8, max: 2.5e8, name: "Epsilon" },
            { min: 2.5e8, max: 5e8, name: "Terafined" },
            { min: 5e8, max: 1e9, name: "Eclipse" },
            // NEW RANKS END
            { min: 1e9, max: 5e9, name: "Infinitude" }, // MODIFIED: max
            // NEW: Overseer
            { min: 5e9, max: 1e10, name: "Overseer" },
            { min: 1e10, max: 1e11, name: "Unseeable" }, 
            { min: 1e11, max: 1e12, name: "Impassive" }, 
            { min: 1e12, max: 1e15, name: "Unrollable" },
            { min: 1e15, max: 1e18, name: "Imaginary" },
            { min: 1e18, max: 1e21, name: "Impossible" },
            { min: 1e21, max: 1e24, name: "Astronomical" },
            { min: 1e24, max: 1e30, name: "Colossal" }, 
            { min: 1e30, max: Infinity, name: "Improbable" } 
        ];

        // UPDATED SECRET RANKS WITH NEW ADDITIONS
        const SECRET_RANKS_CHANCES = [
            { name: "nil", chance: 1/10000, rarity: 10000 }, 
            { name: "Title Label Missing", chance: 1/4040.404, rarity: 4040.404 },
            { name: "?!? unknown ?!?", chance: 1/6666.666, rarity: 6666.666 },
            { name: "r", chance: 1/6942, rarity: 6942 },
            // UPDATED: Changed from "In im table ?!?!?" to "?!? bewilderment ?!?" with new rarity
            { 
                name: "?!? bewilderment ?!?", 
                chance: 1/450285, 
                rarity: 450285
            },
            { name: "Interminable", chance: 1/7777, rarity: 7777 },
            { name: "fish", chance: 1/7979, rarity: 7979 },
            { name: "cheese", chance: 1/10000, rarity: 10000 },
            { name: "100", chance: 1/10000, rarity: 10000 },
            { name: "Minimal", chance: 1/15000, rarity: 15000 },
            { name: "Seize", chance: 1/97525, rarity: 97525 }, 
            { name: "Florescent", chance: 1/264839, rarity: 264839 },
            { name: "œÄ", chance: 1/314159, rarity: 314159 },
            // --- NEW: breaktime ---
            { name: "breaktime", chance: 1/705372, rarity: 705372, timeBased: true },
            { name: "~Nonavacious~", chance: 1/575630, rarity: 575630 }, 
            { name: "Insanity", chance: 1/666666, rarity: 666666 }, 
            { name: "Grand", chance: 1/1e6, rarity: 1e6 },
            { name: ":[{(absolute zero)}]:", chance: 1/1e6, rarity: 1e6 },
            { name: "Defined", chance: 1/1.5e6, rarity: 1.5e6 },
            { name: "Finale.. wait, how'd this get here?", chance: 1/2.5e6, rarity: 2.5e6 },
            { name: "Pseudopseudohypoparathyroidism", chance: 1/5e6, rarity: 5e6 },
            // --- NEW: !! EUPHORIA !! ---
            { name: "!! EUPHORIA !!", chance: 1/56789000, rarity: 56789000 },
            // NEW: CORRUPTED
            { 
                name: "CORRUPTED", 
                chance: 1/648236826.394, 
                rarity: 648236826.394, 
                eventOnly: "Hellish" // Special flag
            },
            { name: "Chargoggagoggmanchauggauggagoggchaubunagungamaugg", chance: 1/77777777.77, rarity: 77777777.77 },
            // MODIFIED: Name
            { name: "‚õßSatanic‚õß", chance: 1/1e9, rarity: 1e9 },
            // ADDED: New secret rank CATASTROPHIC
            { 
                name: "CATASTROPHIC", 
                chance: 1/575765.565, 
                rarity: 575765.565,
                multiplier: 575765.565 // Multiplies RNG by 575,765.565
            },
            { name: "cali^2", chance: 1/1e12, rarity: 1e12 }
        ];

        // FIX: Sort by chance ascending (rarest first) 
        SECRET_RANKS_CHANCES.sort((a, b) => a.chance - b.chance); 

        // --- NEW ---
        const EUPHORIA_SYMBOLS = ['%', '@', '#', '^', '$', '*', '&', '>', '<', '?'];
        // UPDATED: Total ranks count (added 1 for CATASTROPHIC)
        const TOTAL_RANKS = 56; // Updated from 55

        // --- NEW: SHAPES CONSTANTS ---
        const UNLOCK_SHAPES_COST = 5000000;
        const SHAPE_SPAWN_INTERVAL_MS = 2000;
        const MAX_SHAPE_LUCK_LEVEL = 5;
        const SHAPE_LUCK_BONUS = 0.1;
        const SHAPE_LUCK_COST_MULTIPLIER = 1.75;
        const LUCK_MULTI_COST_MULTIPLIER = 1000;
        const BULK_SHAPE_COST_MULTIPLIER = 5;
        const MAX_BULK_SHAPE_LEVEL = 4;
        const SHAPE_COOLDOWN_DECREASE_MS = 333.3333; // 0.3333 seconds
        // NEW: Shape Despawn Timer
        const SHAPE_DESPAWN_TIME_MS = 5000; // 5 seconds
        
        const SHAPES = [
            { name: "Triangle", chance: 1/2, rarity: 2, color: "#FFFF00" },
            { name: "Square", chance: 1/5, rarity: 5, color: "#00FF00" },
            { name: "Pentagon", chance: 1/10, rarity: 10, color: "#00FFFF" },
            // FIX: Changed proportionalChance to chance to resolve the spawning bug
            { name: "Hexagon", chance: 1/25, rarity: 25, color: "#FF00FF" }, 
            { name: "7 Sided Polygon", chance: 1/50, rarity: 50, color: "#FFA500" },
            { name: "Octagon", chance: 1/100, rarity: 100, color: "#800080" },
            { name: "Circle", chance: 1/500, rarity: 500, color: "#FF0000" }
        ];
        // --- END NEW CONSTANTS ---

        // --- NEW: CLICKER CONSTANTS ---
        // MODIFIED: Cost nerf
        const UNLOCK_CLICKER_COST = 333333.33;
        const MAX_CLICKER_LUCK_LEVEL = 4;
        // --- END NEW CONSTANTS ---


        // --- GAME STATE VARIABLES ---
        let currency = 0;
        let totalUpgrades = 0;
        let upgradeCost = 50;
        let highestBaseRoll = 0; 
        let highestFinalRoll = { 
            value: 0,
            baseValue: 0,
            rank: 'None yet',
            variants: [],
            isSecret: false
        };
        let autoRollInterval = null;
        let maxInventory = 10;
        let inventory = [];
        let rollIndex = 1;
        let acceptedRolls = new Set();
        let discoveredRanks = new Set();
        
        // Auto-Accept Variables
        let autoAcceptThreshold = 0;
        let autoAcceptSecretThresholdValue = 0;
        let autoAcceptOnNewRank = false;
        let autoAcceptTrueRNGValue = 0;
        
        // NEW: Auto-Stop Variables
        let autoStopThreshold = 0;
        let autoStopSecretThresholdValue = 0;
        let autoStopOnNewRank = false;
        let autoStopTrueRNGValue = 0;
        
        let bulkRollLevel = 0;
        let bulkRollCost = 500000;
        let isCutscenePlaying = false; 
        
        // NEW: Cutscene state variable 
        let cutscenesEnabled = true; 
        
        // --- NEW EVENT VARIABLES ---
        let currentEvent = null; 
        let eventEndTime = 0;    
        let eventInterval = null;
        let eventCheckChance = 1; 

        // --- NEW: SHAPES VARIABLES ---
        let geometrix = 0;
        let shapesUnlocked = false;
        let shapeLuckLevel = 0;
        let shapeLuckCost = 5;
        let luckMultiLevel = 0;
        let luckMultiCost = 100;
        let bulkShapeLevel = 0;
        let bulkShapeCost = 50;
        let shapeInterval = null;
        // ** NEW: Array for active, clickable shapes (will store timerId on load) **
        let activeShapes = [];
        // --- END NEW VARIABLES ---

        // --- NEW: CLICKER VARIABLES ---
        let clickerUnlocked = false;
        let fortunium = 0;
        let fortuniumLuck = 0; // This is the "+0.5x"
        
        let gmxMultiLevel = 0;
        let gmxMultiCost = 75;
        
        let fortuniumLuckLevel = 0;
        let fortuniumLuckCost = 125;
        
        let clickerLuckLevel = 0;
        let clickerLuckCost = 1000;
        // --- END NEW CLICKER VARIABLES ---

        // --- NEW: EUPHORIA EFFECT ---
        let activeEuphoriaIntervals = {};

        // --- NEW: Bewilderment animation intervals ---
        let activeBewildermentIntervals = {};


        // --- OPTIMIZATION: CALCULATED STATS (set by updateCalculatedStats) ---
        let currentLuck = 0;
        let secretLuckMultiplier = 1;
        let variantChanceMultiplier = 1;

        // --- NEW: CALCULATED STATS ---
        let luckMultiValue = 1;
        let shapeLuckBonus = 0;
        let currentShapeCooldown = SHAPE_SPAWN_INTERVAL_MS;
        // --- END NEW STATS ---


        // --- NEW EVENT FUNCTIONS ---

        function startEvent(event) {
            if (currentEvent) {
                clearTimeout(currentEvent.timeoutId);
                endEvent(currentEvent);
            }
            
            // Create a simple object for currentEvent to avoid saving the massive timeoutId on all rolls
            currentEvent = { 
                name: event.name, 
                duration: event.duration, 
                description: event.description, 
                targets: event.targets, 
                multiplier: event.multiplier, 
                eventChanceBoost: event.eventChanceBoost 
            };
            eventEndTime = Date.now() + event.duration;

            addToTerminal(`üö® EVENT STARTED: **${event.name}**! ${event.description} for ${event.duration / 1000} seconds!`, true, 'rank-1000-10000'); 

            if (event.name === "Lol") {
                eventCheckChance = event.eventChanceBoost; 
            } else {
                eventCheckChance = 1;
            }

            // Set the timeout for the actual end
            currentEvent.timeoutId = setTimeout(() => {
                endEvent(event);
            }, event.duration);

            updateStats();
        }

        function endEvent(event) {
            addToTerminal(`‚úÖ EVENT ENDED: **${event.name}** is over.`, true);

            if (event.name === "Lol") {
                eventCheckChance = 1;
            }

            if (currentEvent && currentEvent.name === event.name) {
                currentEvent = null;
                eventEndTime = 0;
            }

            updateStats();
        }
        
        // FIX: Function to resume an event after loading 
        function resumeEvent(event, remainingDuration) {
            currentEvent = event;
            // The eventEndTime is already set on load
            if (event.name === "Lol") {
                eventCheckChance = event.eventChanceBoost; 
            } else {
                eventCheckChance = 1;
            }
            
            // FIX: Set a new timeout on load to correctly end the event 
            currentEvent.timeoutId = setTimeout(() => {
                endEvent(event);
            }, remainingDuration);
            
            addToTerminal(`Resuming active event: **${event.name}** (${(remainingDuration / 1000).toFixed(1)}s left).`, true, 'rank-1000-10000');
        }

        function checkEvent() {
            if (currentEvent) return; 

            for (const event of EVENTS) {
                const adjustedChance = event.chance / eventCheckChance;

                if (Math.random() < adjustedChance) {
                    startEvent(event);
                    return; 
                }
            }
        }

        function startEventLoop() {
            if (eventInterval) clearInterval(eventInterval);
            eventInterval = setInterval(checkEvent, EVENT_CHECK_INTERVAL_MS);
        }

        // --- END NEW EVENT FUNCTIONS ---


        // --- CORE FUNCTIONS ---

        // NEW: Formatter for integers
        function formatInteger(num) {
            return num.toLocaleString('en-US');
        }

        function formatNumber(num) {
            return num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }
        
        // NEW: UTILITY FUNCTIONS 
        function formatGeometrix(num) {
            return num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }
        
        function formatCooldown(ms) {
            return (ms / 1000).toFixed(4); // 4 decimal places for cooldown
        }

        // --- NEW: Utility to escape strings for JS onclick attributes ---
        function escapeHTML(str) {
            if (!str) return '';
            // Only escape single quotes, as the onclick uses them
            return str.replace(/'/g, "\\'");
        }
        // --- END NEW UTILITY FUNCTIONS ---
        
        function sortInventory(type) {
            if (type === 'leastRarest') {
                inventory.sort((a, b) => a.value - b.value);
            } else if (type === 'mostRarest') {
                inventory.sort((a, b) => b.value - a.value);
            }
            updateInventoryDisplay();
            addToTerminal(`Inventory sorted by ${type === 'mostRarest' ? 'most rarest' : 'least rarest'} (Variants Applied).`, true);
            saveGame();
        }

        // MODIFIED: Centralized function to calculate multipliers after upgrades
        function updateCalculatedStats() {
            // Base luck from main upgrades
            currentLuck = totalUpgrades * LUCK_PER_UPGRADE;
            
            // NEW: Shape luck (Upgrade 1) - This is a separate luck stat for shapes
            shapeLuckBonus = shapeLuckLevel * SHAPE_LUCK_BONUS;
            
            // NEW: Clicker Luck (Upgrade 3)
            const clickerLuckBonus = clickerLuckLevel * 0.5;
            
            // NEW: Luck Multiplier (Upgrade 2) + Clicker Luck
            luckMultiValue = Math.pow(2, luckMultiLevel) + clickerLuckBonus; // Additive bonus
            
            // Apply Luck Multiplier to main game mechanics (but NOT polygons)
            // Base luck is modified in generateRoll()
            secretLuckMultiplier = Math.min(1 + (totalUpgrades * SECRET_LUCK_PER_UPGRADE), MAX_SECRET_LUCK) * luckMultiValue;
            variantChanceMultiplier = Math.min(1 + (totalUpgrades * VARIANT_CHANCE_PER_UPGRADE), MAX_VARIANT_CHANCE_MULTIPLIER) * luckMultiValue;
            
            // NEW: Calculate shape cooldown from Upgrade 3
            currentShapeCooldown = Math.max(
                SHAPE_SPAWN_INTERVAL_MS - (bulkShapeLevel * SHAPE_COOLDOWN_DECREASE_MS), 
                SHAPE_SPAWN_INTERVAL_MS - (MAX_BULK_SHAPE_LEVEL * SHAPE_COOLDOWN_DECREASE_MS) // Cap at Lvl 4
            );
        }

        function getVariants(baseValue) {
            let selectedVariants = [];
            let totalMultiplier = 1;

            // NEW: Check for "Modified" event
            let eventVariantMultiplier = 1;
            if (currentEvent && currentEvent.name === "Modified") {
                eventVariantMultiplier = currentEvent.multiplier;
            }
            
            for (let i = VARIANTS.length - 1; i >= 0; i--) {
                const variant = VARIANTS[i];
                // MODIFIED: Use the calculated variantChanceMultiplier AND event multiplier
                const adjustedChance = variant.chance * variantChanceMultiplier * eventVariantMultiplier;
                
                while (selectedVariants.length < MAX_VARIANTS_PER_ROLL && Math.random() < adjustedChance) {
                    selectedVariants.push(variant);
                    totalMultiplier *= variant.multiplier;
                }
            }
            
            if (selectedVariants.length > 0) {
                selectedVariants.sort((a, b) => b.multiplier - a.multiplier);
                return { 
                    variants: selectedVariants, 
                    modifiedValue: baseValue * totalMultiplier 
                };
            }
            return null;
        }

        function generateRoll() {
            // MODIFIED: Apply the luckMultiValue to the base luck
            const totalLuck = currentLuck * luckMultiValue;
            const baseRoll = Math.pow(Math.random(), 3 / POWER_EXPONENT) * (1 + totalLuck);
            return { value: baseRoll, variant: null };
        }
        
        // --- MODIFIED: To handle time-based 'breaktime', 'eventOnly', 'ALL_SECRETS' event, and new ranks ---
        function getSecretRank() {
            const rand = Math.random();
            
            // --- NEW: Check for "Hidden" event ---
            let hiddenEventMultiplier = 1;
            if (currentEvent && currentEvent.targets.includes("ALL_SECRETS")) {
                hiddenEventMultiplier = currentEvent.multiplier;
            }
            // --- END NEW ---
            
            for (const secret of SECRET_RANKS_CHANCES) {
                let chanceMultiplier = 1;
                let adjustedChance = secret.chance; // Use this for modifications

                // --- NEW: Event-Only Check ---
                if (secret.eventOnly) {
                    if (!currentEvent || currentEvent.name !== secret.eventOnly) {
                        continue; // Skip this secret if event is not active
                    }
                }
                // --- END NEW ---

                // --- NEW: Time-based logic for 'breaktime' ---
                if (secret.timeBased && secret.name === "breaktime") {
                    const now = new Date();
                    // UTC-3 offset
                    const utc3OffsetMs = -3 * 60 * 60 * 1000;
                    const utc3Time = new Date(now.getTime() + utc3OffsetMs);
                    const dayOfWeek = utc3Time.getUTCDay(); // 0=Sun, 1=Mon, ..., 6=Sat

                    if (dayOfWeek >= 1 && dayOfWeek <= 5) { // Weekday (Mon-Fri)
                        adjustedChance = 0; // Impossible
                    } else { // Weekend (Sat, Sun)
                        adjustedChance = 1 / 705372; // Use the defined chance
                    }
                }
                // --- END NEW LOGIC ---

                if (currentEvent && currentEvent.targets.includes(secret.name)) {
                    chanceMultiplier = currentEvent.multiplier;
                }
                
                // MODIFIED: Use the calculated secretLuckMultiplier, adjustedChance, and hiddenEventMultiplier
                if (rand < adjustedChance * secretLuckMultiplier * chanceMultiplier * hiddenEventMultiplier) {
                    // NEW LOGIC FOR MORTS LUCK
                    if (secret.name === 'cali^2') {
                        if (Math.random() < 1/1e6) {
                            // 1 in 1 million chance to replace cali^2
                            return { name: "morts luck", chance: 1/1e18, rarity: 1e18 };
                        }
                    }
                    // END NEW LOGIC
                    return secret;
                }
            }
            return null;
        }

        // MODIFIED: To handle Unobtainable rank (1/200 chance to replace Unattainable, multiplies RNG by 250000)
        function getRankInfo(value) {
            // First, check if the value falls in the Unattainable tier
            for (let i = 0; i < RANK_TIERS.length; i++) {
                const tier = RANK_TIERS[i];
                if (value >= tier.min && value < tier.max) {
                    let rankName = tier.name;
                    let isUnobtainable = false;
                    
                    // Check if this is Unattainable and should be replaced with Unobtainable
                    if (tier.name === "Unattainable" && Math.random() < 1/200) {
                        rankName = "Unobtainable";
                        value *= 250000; // Multiply RNG by 250000
                        isUnobtainable = true;
                    }
                    
                    return { 
                        name: rankName, 
                        value: value, 
                        rankNum: i + 1,
                        isUnobtainable: isUnobtainable
                    };
                }
            }
            // MODIFIED: Return the last rank name dynamically
            return { 
                name: RANK_TIERS[RANK_TIERS.length - 1].name, 
                value: value, 
                rankNum: RANK_TIERS.length,
                isUnobtainable: false
            };
        }

        // MODIFIED: To handle Unobtainable rank styling
        function getRankClassAndColor(value, variants = [], rankName = "") {
            let color = "#ffffff";
            let className = "rank-1-1000";
            
            // Check for Unobtainable first
            if (rankName === "Unobtainable") {
                className = "rank-unobtainable";
                color = "#000000"; // Base color for gradient
            }
            else if (value >= 1e30) { className = "rank-improbable"; color = "#008080"; }
            else if (value >= 1e15) { className = "rank-rainbow"; color = "#ff7f00"; }
            else if (value >= 1e12) { className = "rank-1000000000000-100000000000000"; color = "#ff69b4"; }
            else if (value >= 1e11) { className = "rank-100000000000-1000000000000"; color = "#a9a9a9"; } 
            else if (value >= 1e10) { className = "rank-10000000000-100000000000"; color = "#ffc0cb"; } 
            else if (value >= 1e9) { className = "rank-1000000000-10000000000"; color = "#00ff00"; }
            else if (value >= 1e8) { className = "rank-100000000-1000000000"; color = "#8b0000"; }
            else if (value >= 1e6) { className = "rank-1000000-100000000"; color = "#ff0000"; }
            else if (value >= 1e5) { className = "rank-100000-1000000"; color = "#0000cd"; }
            else if (value >= 10000) { className = "rank-10000-100000"; color = "#00ffff"; }
            else if (value >= 1000) { className = "rank-1000-10000"; color = "#ffff00"; }
            
            return { className, color };
        }

        function getRankClass(value, variants = []) {
            return getRankClassAndColor(value, variants).className;
        }

        function addToTerminal(text, isCommand = false, className = "") {
            const terminal = document.getElementById('terminal');
            const line = document.createElement('div');
            line.className = 'output-line';
            if (isCommand) line.classList.add('command');
            if (className) line.classList.add(className);
            line.innerHTML = text;

            // Optimization: Limit terminal lines
            if (terminal.children.length > 100) {
                terminal.removeChild(terminal.firstChild);
            }

            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
        }
        
        // NEW: Toggle Cutscenes Function 
        function toggleCutscenes() {
            cutscenesEnabled = !cutscenesEnabled;
            const btn = document.getElementById('cutsceneToggleBtn');
            const state = cutscenesEnabled ? 'ON' : 'OFF';
            btn.textContent = `Cutscenes: ${state}`;
            addToTerminal(`Cutscenes turned ${state}.`, true);
            saveGame();
        }

        // MODIFIED: To update all new stats
        function updateStats() {
            document.getElementById('currency').textContent = formatNumber(currency);
            document.getElementById('geometrix').textContent = formatGeometrix(geometrix); // NEW
            document.getElementById('upgrades').textContent = totalUpgrades;
            
            // Use pre-calculated global values
            document.getElementById('luck').textContent = currentLuck.toFixed(3);
            document.getElementById('luckMulti').textContent = luckMultiValue.toFixed(2); // NEW
            document.getElementById('secretLuck').textContent = secretLuckMultiplier.toFixed(2);
            document.getElementById('variantChance').textContent = variantChanceMultiplier.toFixed(2);
            
            document.getElementById('upgradeCost').textContent = formatNumber(upgradeCost);
            document.getElementById('inventoryCount').textContent = inventory.length;
            document.getElementById('inventoryMax').textContent = maxInventory;
            document.getElementById('ranksDiscovered').textContent = discoveredRanks.size;
            document.getElementById('totalRanks').textContent = TOTAL_RANKS; 
            
            document.getElementById('bulkRollLevel').textContent = bulkRollLevel;
            document.getElementById('bulkRollAmount').textContent = bulkRollLevel + 1;
            
            const bulkCostEl = document.getElementById('bulkRollCost');
            const bulkBtnEl = document.getElementById('buyBulkRollBtn');
            
            if (bulkRollLevel >= MAX_BULK_ROLL_LEVEL) {
                bulkCostEl.textContent = "MAXED";
                if (bulkBtnEl) {
                    bulkBtnEl.disabled = true;
                    bulkBtnEl.textContent = "Bulk Roll (MAXED)";
                }
            } else {
                bulkCostEl.textContent = formatNumber(bulkRollCost);
                if (bulkBtnEl) {
                    bulkBtnEl.disabled = currency < bulkRollCost; // Disable if not enough currency
                    bulkBtnEl.textContent = "Buy Bulk Roll";
                }
            }
            
            // Dynamic Event Status Display
            const statsContainer = document.querySelector('.stats');
            let eventStat = document.getElementById('eventStat');
            if (!eventStat) {
                eventStat = document.createElement('div');
                eventStat.className = 'stat-item';
                eventStat.id = 'eventStat';
                statsContainer.appendChild(eventStat);
            }
            const eventName = currentEvent ? currentEvent.name : "None";
            const timeLeft = currentEvent ? Math.max(0, eventEndTime - Date.now()) : 0;
            const timeLeftFormatted = (timeLeft / 1000).toFixed(1);
            eventStat.innerHTML = `Active Event: <span style="color: ${currentEvent ? '#00FFFF' : '#ffffff'};">${eventName}</span> (${timeLeftFormatted}s)`;
            
            // Rarest Roll
            if (highestFinalRoll.value > 0 || highestFinalRoll.rank === "CORRUPTED") { // MODIFIED: Allow corrupted
                const { className, color } = getRankClassAndColor(highestFinalRoll.value, highestFinalRoll.variants, highestFinalRoll.rank);
                let rankClass = className;
                let rollColor = color;
                let displayName = highestFinalRoll.rank;
                let displayValue = highestFinalRoll.value; // NEW
                let suffix = ""; // NEW

                if (displayName === "~Nonavacious~") {
                    rankClass += " secret-nonavacious";
                }
                
                // --- NEW: Apply CORRUPTED class ---
                if (displayName === "CORRUPTED") {
                    rankClass += " secret-corrupted";
                    rollColor = "#FFFFFF";
                }
                // --- END NEW ---
                
                // NEW: Special display for stats
                if (displayName === "‚õßSatanic‚õß") {
                    suffix = ` (Actual: ${formatNumber(highestFinalRoll.value)})`;
                    displayValue = -666.66;
                }
                if (displayName === "Finale.. wait, how'd this get here?") {
                    suffix = ` (Actual: ${formatNumber(highestFinalRoll.value)})`;
                    displayValue = 1e10;
                }
                // END NEW
                
                document.getElementById('rarest').innerHTML = 
                    // MODIFIED: Added satanic wrapper
                    `<span class="satanic-wrapper"><span class="${rankClass}" style="color: ${rollColor};">${formatNumber(displayValue)} [${displayName}]${suffix}</span></span>`;
            }

            // NEW: Update Cutscene Toggle Button 
            const cutsceneBtn = document.getElementById('cutsceneToggleBtn');
            if (cutsceneBtn) {
                cutsceneBtn.textContent = `Cutscenes: ${cutscenesEnabled ? 'ON' : 'OFF'}`;
            }

            // --- NEW: Shapes GUI Updates ---
            document.getElementById('shapes-gui').style.display = shapesUnlocked ? 'block' : 'none';
            document.getElementById('shapes-unlock-controls').style.display = shapesUnlocked ? 'none' : 'grid'; // Use grid to match other controls
            document.getElementById('unlockShapesBtn').disabled = currency < UNLOCK_SHAPES_COST;

            if (shapesUnlocked) {
                document.getElementById('shapeLuckBonus').textContent = shapeLuckBonus.toFixed(1);
                document.getElementById('bulkShapeAmount').textContent = bulkShapeLevel + 1;
                document.getElementById('bulkShapeLevel').textContent = bulkShapeLevel;
                document.getElementById('shapeCooldown').textContent = formatCooldown(currentShapeCooldown);
                
                // Shape Luck Button (Upgrade 1)
                const shapeLuckBtn = document.getElementById('buyShapeLuckBtn');
                document.getElementById('shapeLuckCost').textContent = formatGeometrix(shapeLuckCost);
                if (shapeLuckLevel >= MAX_SHAPE_LUCK_LEVEL) {
                    shapeLuckBtn.disabled = true;
                    shapeLuckBtn.innerHTML = `Shape Luck (MAXED)`;
                } else {
                    shapeLuckBtn.disabled = geometrix < shapeLuckCost;
                    shapeLuckBtn.innerHTML = `Shape Luck (+0.1x) - Cost: <span id="shapeLuckCost">${formatGeometrix(shapeLuckCost)}</span> GMX`;
                }
                
                // Luck Multi Button (Upgrade 2)
                const luckMultiBtn = document.getElementById('buyLuckMultiBtn');
                document.getElementById('luckMultiCost').textContent = formatGeometrix(luckMultiCost);
                luckMultiBtn.disabled = geometrix < luckMultiCost;

                // Bulk Shape Button (Upgrade 3)
                const bulkShapeBtn = document.getElementById('buyBulkShapeBtn');
                document.getElementById('bulkShapeCost').textContent = formatGeometrix(bulkShapeCost);
                if (bulkShapeLevel >= MAX_BULK_SHAPE_LEVEL) {
                    bulkShapeBtn.disabled = true;
                    bulkShapeBtn.innerHTML = `Bulk/Cooldown (MAXED)`;
                } else {
                    bulkShapeBtn.disabled = geometrix < bulkShapeCost;
                    bulkShapeBtn.innerHTML = `Bulk/Cooldown Lvl <span id="bulkShapeLevelBtn">${bulkShapeLevel + 1}</span> - Cost: <span id="bulkShapeCost">${formatGeometrix(bulkShapeCost)}</span> GMX`;
                }

                // Clicker Unlock Button (Upgrade 4)
                const clickerUnlockBtn = document.getElementById('buyClickerUnlockBtn');
                if (clickerUnlockBtn) {
                     if (clickerUnlocked) {
                        clickerUnlockBtn.disabled = true;
                        clickerUnlockBtn.textContent = "Clicker Unlocked";
                    } else {
                        clickerUnlockBtn.disabled = geometrix < UNLOCK_CLICKER_COST;
                        // MODIFIED: Use formatGeometrix
                        clickerUnlockBtn.textContent = `Unlock Clicker - Cost: ${formatGeometrix(UNLOCK_CLICKER_COST)} GMX`;
                    }
                }
            }
            // --- END NEW UPDATES ---

            // --- NEW: Clicker GUI Updates ---
            document.getElementById('clicker-gui').style.display = clickerUnlocked ? 'block' : 'none';
            
            if (clickerUnlocked) {
                document.getElementById('fortunium').textContent = formatNumber(fortunium);
                document.getElementById('fortuniumLuck').textContent = fortuniumLuck.toFixed(2);
                
                // GMX Multi Button
                const gmxMultiBtn = document.getElementById('buyGmxMultiBtn');
                document.getElementById('gmxMultiCost').textContent = formatNumber(gmxMultiCost);
                gmxMultiBtn.disabled = fortunium < gmxMultiCost;
                gmxMultiBtn.innerHTML = `GMX Multi (+0.5x) - Cost: <span id="gmxMultiCost">${formatNumber(gmxMultiCost)}</span> FOR`;

                // Fortunium Luck Button
                const fortuniumLuckBtn = document.getElementById('buyFortuniumLuckBtn');
                document.getElementById('fortuniumLuckCost').textContent = formatNumber(fortuniumLuckCost);
                fortuniumLuckBtn.disabled = fortunium < fortuniumLuckCost;

                // Clicker Luck Button
                const clickerLuckBtn = document.getElementById('buyClickerLuckBtn');
                document.getElementById('clickerLuckCost').textContent = formatNumber(clickerLuckCost);
                if (clickerLuckLevel >= MAX_CLICKER_LUCK_LEVEL) {
                    clickerLuckBtn.disabled = true;
                    clickerLuckBtn.innerHTML = `Luck Multi (MAXED)`;
                } else {
                    clickerLuckBtn.disabled = fortunium < clickerLuckCost;
                    clickerLuckBtn.innerHTML = `Luck Multi (+0.5x) - Cost: <span id="clickerLuckCost">${formatNumber(clickerLuckCost)}</span> FOR`;
                }
            }
            // --- END CLICKER UPDATES ---
        }

        // --- MODIFIED: To handle EUPHORIA animation persistence, Unobtainable, and new ranks ---
        function updateInventoryDisplay() {
            // --- MODIFIED: Remove interval clearing ---
            // (The self-cleanup in initEuphoriaAnimation will handle this)
            // --- END MODIFIED ---

            const inventoryContent = document.getElementById('inventoryContent');
            if (inventory.length === 0) {
                inventoryContent.innerHTML = 'Empty';
            } else {
                inventoryContent.innerHTML = inventory.map((item, idx) => {
                    const { className: rankClass, color: rollColor } = getRankClassAndColor(item.value, item.variants, item.rank);
                    let displayClass = rankClass;
                    if (item.rank === "~Nonavacious~") {
                        displayClass += " secret-nonavacious";
                    }
                    // --- NEW: Apply CORRUPTED class ---
                    if (item.rank === "CORRUPTED") {
                        displayClass += " secret-corrupted";
                    }
                    // --- END NEW ---
                    
                    let variantText = '';
                    if (item.variants && item.variants.length > 0) {
                        variantText = item.variants.map(v => `<span style="color: ${v.color}; font-weight: bold;">[${v.name}]</span>`).join('') + ' ';
                    }
                    let suffix = "";
                    let displayValue = item.value; // NEW
                    if (item.rank === "100") suffix = " * üíØ";
                    if (item.rank === ":[{(absolute zero)}]:") suffix = " * 0";
                    
                    // NEW: Special display for inventory
                    if (item.rank === "‚õßSatanic‚õß") {
                        suffix = ` (Actual: ${formatNumber(item.value)})`;
                        displayValue = -666.66;
                    }
                    if (item.rank === "Finale.. wait, how'd this get here?") {
                        suffix = ` (Actual: ${formatNumber(item.value)})`;
                        displayValue = 1e10;
                    }
                    // END NEW
                    
                    // --- FIX: Added id="inv-item-${idx}" for animation targeting ---
                    // MODIFIED: Added satanic wrapper and formatInteger
                    let content = `<span class="${displayClass}" style="color: ${rollColor};">${formatNumber(displayValue)} [${item.rank}]${suffix}</span>`;
                    // Wrap if satanic
                    if (item.rank === "‚õßSatanic‚õß") {
                        content = `<span class="satanic-wrapper">${content}</span>`;
                    }
                    
                    return `<div class="inventory-item" onclick="removeFromInventory(${idx})" id="inv-item-${idx}">
                        #${formatInteger(item.index)}: ${variantText}${content}
                    </div>`; 
                }).join('');
            }
            
            // --- MODIFIED: Start animations for inventory items that don't have one ---
            inventory.forEach((item, idx) => {
                const elementId = `inv-item-${idx}`;
                if (item.rank === "!! EUPHORIA !!" && !activeEuphoriaIntervals[elementId]) {
                    initEuphoriaAnimation(elementId, "!! EUPHORIA !!");
                }
                if (item.rank === "?!? bewilderment ?!?" && !activeBewildermentIntervals[elementId]) {
                    initBewildermentAnimation(elementId);
                }
            });
            // --- END MODIFIED ---
        }

        // --- MODIFIED: To add new secret ranks to index ---
        function updateIndexDisplay() {
            const indexContent = document.getElementById('indexContent');
            let html = '<div style="margin-bottom: 15px;"><strong>Normal Ranks:</strong></div>';
            
            RANK_TIERS.forEach(tier => {
                const discovered = discoveredRanks.has(tier.name);
                let rankClass = getRankClass((tier.min + tier.max) / 2); 
                if (tier.name === "Improbable") {
                    rankClass = "rank-improbable";
                }
                html += `<div class="index-item ${discovered ? 'discovered' : 'locked'}">
                    ${discovered ? `<span class="${rankClass}">${tier.name}</span>` : '???'}
                </div>`;
            });
            
            html += '<div style="margin: 15px 0;"><strong>Secret Ranks:</strong></div>';
            SECRET_RANKS_CHANCES.forEach(rankInfo => {
                const rankName = rankInfo.name;
                // --- NEW: Skip time-based for this view, will be added manually ---
                if (rankInfo.timeBased) return;
                
                const discovered = discoveredRanks.has(rankName);
                let rankStyle = `color: #ff69b4;`;
                
                // --- NEW: Style for CORRUPTED ---
                if (rankName === "CORRUPTED") {
                    rankStyle = `color: #ffffff; filter: invert(100%); display: inline-block;`;
                }
                // --- END NEW ---
                
                html += `<div class="index-item ${discovered ? 'discovered' : 'locked'}">
                    ${discovered ? `<span style="${rankStyle}">${rankName}</span>` : '???'}
                </div>`;
            });
            
            // --- NEW: Manually add time-based and special ranks to index ---
            const breaktimeDiscovered = discoveredRanks.has("breaktime");
            html += `<div class="index-item ${breaktimeDiscovered ? 'discovered' : 'locked'}">
                ${breaktimeDiscovered ? `<span style="color: #ff69b4;">breaktime</span>` : '???'}
            </div>`;

            const mortsLuckDiscovered = discoveredRanks.has("morts luck");
            const mortsLuckStyle = `color: #ff0000; font-weight: bold;`; // Make it special
            html += `<div class="index-item ${mortsLuckDiscovered ? 'discovered' : 'locked'}">
                ${mortsLuckDiscovered ? `<span style="${mortsLuckStyle}">morts luck</span>` : '???'}
            </div>`;
            // --- END NEW ---
            
            indexContent.innerHTML = html;
        }

        function addToInventory(value, rank, index, variants = [], baseValue = null) {
            if (inventory.length >= maxInventory) {
                addToTerminal('Inventory full! Buy upgrades to increase space.', true);
                return false;
            }
            const isSecret = SECRET_RANKS_CHANCES.map(r => r.name).includes(rank) || rank === "morts luck" || rank === "breaktime" || rank === "Unobtainable"; // MODIFIED: Added Unobtainable
            inventory.push({ value, rank, index, variants, baseValue: baseValue || value, isSecret });
            updateInventoryDisplay();
            updateStats();
            saveGame();
            return true;
        }

        // --- MODIFIED: To restart EUPHORIA animation on remove ---
        function removeFromInventory(idx) {
            const item = inventory[idx];
            
            let variantText = '';
            if (item.variants && item.variants.length > 0) {
                variantText = item.variants.map(v => `[${v.name}]`).join('') + ' ';
            }
            
            let suffix = "";
            let displayValue = item.value; // NEW
            if (item.rank === "100") suffix = " * üíØ";
            if (item.rank === ":[{(absolute zero)}]:") suffix = " * 0";
            
            // NEW: Special display for remove log
            if (item.rank === "‚õßSatanic‚õß") {
                suffix = ` (Actual: ${formatNumber(item.value)})`;
                displayValue = -666.66;
            }
            if (item.rank === "Finale.. wait, how'd this get here?") {
                suffix = ` (Actual: ${formatNumber(item.value)})`;
                displayValue = 1e10;
            }
            // END NEW
            
            // MODIFIED: use formatInteger
            addToTerminal(`Removed from inventory: #${formatInteger(item.index)} ${variantText}${formatNumber(displayValue)} [${item.rank}]${suffix}`, true); 
            
            acceptedRolls.delete(item.index);
            
            const rollElement = document.getElementById(`roll-${item.index}`);
            if (rollElement) {
                rollElement.style.opacity = '1';
                rollElement.style.cursor = 'pointer';
                
                rollElement.onclick = function() { 
                    // --- FIX: Use escaped name ---
                    tryAddToInventory(item.value, item.rank, item.index, rollElement); 
                };

                // --- NEW: Restart animation ---
                if (item.rank === "!! EUPHORIA !!") {
                    // Use a short timeout to let the DOM update
                    setTimeout(() => initEuphoriaAnimation(`roll-${item.index}`, "!! EUPHORIA !!"), 10);
                }
                if (item.rank === "?!? bewilderment ?!?") {
                    setTimeout(() => initBewildermentAnimation(`roll-${item.index}`), 10);
                }
                // --- END NEW ---
            }
            
            inventory.splice(idx, 1);
            updateInventoryDisplay();
            updateStats();
            saveGame();
        }

        function playCutscene(rollValue, isSecret = false) {
            // NEW: Check if cutscenes are enabled 
            if (!cutscenesEnabled) {
                return Promise.resolve();
            }

            return new Promise(resolve => {
                const wasAutoRolling = autoRollInterval !== null;
                if (wasAutoRolling) {
                    toggleAutoRoll();
                }
                
                isCutscenePlaying = true;
                const body = document.body;
                const overlay = document.getElementById('cutscene-overlay');
                const starElement = document.getElementById('star-element');
                
                body.classList.add('cutscene-active');
                
                const { color } = getRankClassAndColor(rollValue);
                starElement.style.color = color;
                
                let starShapeClass = 'star-4'; 
                if (rollValue >= 1e12 && isSecret) {
                    starShapeClass = 'star-12';
                } else if (rollValue >= 1e9 && isSecret) {
                    starShapeClass = 'star-6';
                } else if (rollValue >= 1e12) {
                    starShapeClass = 'star-8';
                }
                
                starElement.className = starShapeClass;
                starElement.style.transform = 'translate(-50%, -50%) rotate(0deg) scale(1)'; 
                let currentScale = 1;
                let currentRotation = 0;
                let rotationSpeed = 3; 
                let sizeInterval = null;
                
                setTimeout(() => {
                    starElement.style.opacity = 1;
                }, STAR_FADE_IN_MS);
                
                const spinUpdate = () => {
                    currentRotation += rotationSpeed;
                    starElement.style.transform = `translate(-50%, -50%) rotate(${currentRotation}deg) scale(${currentScale})`; 
                    if (isCutscenePlaying) {
                        requestAnimationFrame(spinUpdate);
                    }
                };

                requestAnimationFrame(spinUpdate);

                setTimeout(() => {
                    rotationSpeed = 15; 
                    
                    sizeInterval = setInterval(() => {
                        currentScale *= SIZE_MULTIPLIER_PER_UPDATE;
                    }, SIZE_UPDATE_INTERVAL_MS);

                }, SPIN_ACCEL_MS);
                
                setTimeout(() => {
                    starElement.style.opacity = 0;
                    body.classList.add('cutscene-flash');
                    
                    setTimeout(() => {
                        isCutscenePlaying = false;
                        clearInterval(sizeInterval);
                        
                        body.classList.remove('cutscene-flash');
                        body.classList.remove('cutscene-active');
                        
                        setTimeout(() => {
                            starElement.style.transform = 'translate(-50%, -50%) rotate(0deg) scale(1)';
                            starElement.style.color = '';
                            starElement.className = '';
                            if (wasAutoRolling) {
                                toggleAutoRoll();
                            }
                            resolve();
                        }, 500);
                        
                    }, WHITE_FLASH_DURATION_MS);
                    
                }, CUTSCENE_DURATION_MS - WHITE_FLASH_DURATION_MS);
            });
        }

        // --- NEW: Bewilderment animation function ---
        function initBewildermentAnimation(elementId) {
            const element = document.getElementById(elementId);
            if (!element) return;
            
            // Store original text
            const originalText = element.textContent || element.innerText;
            if (!originalText.includes("?!? bewilderment ?!?")) return;
            
            // Create blinking effect
            let isQuestionMark = true;
            const intervalId = setInterval(() => {
                if (!document.getElementById(elementId)) {
                    clearInterval(intervalId);
                    delete activeBewildermentIntervals[elementId];
                    return;
                }
                
                if (isQuestionMark) {
                    element.textContent = originalText.replace("?!? bewilderment ?!?", "!?! bewilderment !?!");
                    element.innerHTML = element.innerHTML.replace("?!? bewilderment ?!?", "!?! bewilderment !?!");
                } else {
                    element.textContent = originalText;
                    element.innerHTML = originalText;
                }
                isQuestionMark = !isQuestionMark;
            }, 10); // 10 milliseconds
            
            activeBewildermentIntervals[elementId] = intervalId;
        }

        // --- MODIFIED: To handle new ranks, CORRUPTED, Auto-Accept, and Auto-Stop ---
        async function roll() {
            if (isCutscenePlaying) {
                addToTerminal('Wait for the cutscene to finish!', true);
                return;
            }
            
            const rollResults = [];
            let maxRollValueInBulk = 0;
            let isMaxRollSecret = false;
            let newRankDiscoveredInBulk = false;
            
            for (let i = 0; i < (bulkRollLevel + 1); i++) {
                const rollResult = generateRoll();
                const baseValue = rollResult.value;
                const variantResult = getVariants(baseValue);
                let displayValue = variantResult ? variantResult.modifiedValue : baseValue;
                const variants = variantResult ? variantResult.variants : [];
                
                // IMPORTANT: getSecretRank is called with no arguments as it relies on Math.random() internally.
                const secretResult = getSecretRank(); 
                let rankInfo = getRankInfo(baseValue);
                let displayName = secretResult ? secretResult.name : rankInfo.name;
                const isSecret = !!secretResult;
                
                // Apply CATASTROPHIC multiplier if applicable
                if (displayName === "CATASTROPHIC" && secretResult.multiplier) {
                    displayValue *= secretResult.multiplier;
                }
                
                // Apply Unobtainable multiplier if applicable (already applied in getRankInfo)
                if (rankInfo.isUnobtainable) {
                    displayName = "Unobtainable";
                    displayValue = rankInfo.value;
                }
                
                let secretRarityMultiplier = 1;
                if (isSecret) {
                    // --- NEW: Don't apply multiplier if chance was 0 (e.g. breaktime on weekday) ---
                    if (secretResult.rarity) {
                        secretRarityMultiplier = secretResult.rarity;
                        displayValue *= secretRarityMultiplier;
                    } else {
                        // This case handles if getSecretRank returns a result but rarity is 0 or undefined
                        // e.g. breaktime on a weekday. The roll should be 0.
                        displayValue = 0; 
                    }
                }
                
                // --- NEW: CORRUPTED Logic ---
                if (displayName === "CORRUPTED") {
                    displayValue *= -1;
                }
                // --- END NEW ---
                
                rollResults.push({ 
                    baseValue, 
                    displayValue, 
                    variants, 
                    displayName, 
                    isSecret, 
                    secretRarityMultiplier,
                    rankInfo 
                });
                
                if (displayValue > maxRollValueInBulk) {
                    maxRollValueInBulk = displayValue;
                    isMaxRollSecret = isSecret;
                }
                
                // Check for new rank discovery
                if (!discoveredRanks.has(displayName)) {
                    newRankDiscoveredInBulk = true;
                }
            }
            
            if (cutscenesEnabled && maxRollValueInBulk >= 1e9) {
                await playCutscene(maxRollValueInBulk, isMaxRollSecret);
            }
            
            for (const rollData of rollResults) {
                let { baseValue, displayValue, variants, displayName, isSecret, secretRarityMultiplier, rankInfo } = rollData;
                
                const currencyGain = Math.pow(rankInfo.rankNum, 3);
                
                const { className: rankClassBase, color: rollColorBase } = getRankClassAndColor(displayValue, variants, displayName);

                let rankClass = rankClassBase;
                let rollColor = rollColorBase;

                // --- NEW: Apply CORRUPTED class ---
                if (displayName === "CORRUPTED") {
                    rankClass += " secret-corrupted";
                    rollColor = "#FFFFFF"; 
                }
                // --- END NEW ---

                let suffix = "";
                let finalDisplayValue = displayValue; // NEW: Use a new var for display
                
                if (displayName === "100") suffix = ` * üíØ`;
                if (displayName === ":[{(absolute zero)}]:") suffix = ` * 0`;
                
                // NEW: Special Display Logic
                if (displayName === "‚õßSatanic‚õß") {
                    suffix = ` (Actual: ${formatNumber(displayValue)})`;
                    finalDisplayValue = -666.66;
                    rankClass = "rank-1000000-100000000"; // Red color
                    rollColor = "#ff0000";
                }
                if (displayName === "Finale.. wait, how'd this get here?") {
                    suffix = ` (Actual: ${formatNumber(displayValue)})`;
                    finalDisplayValue = 1e10; 
                    rankClass = getRankClass(1e10); // Get correct color for 1e10
                    rollColor = getRankClassAndColor(1e10).color;
                }
                // END NEW
                
                const secretMultiplierText = (isSecret && secretRarityMultiplier > 1) ? ` (x${formatNumber(secretRarityMultiplier)})` : '';

                if (displayName === "~Nonavacious~") {
                    rankClass += " secret-nonavacious";
                }
                
                const currentIndex = rollIndex++;
                
                let newRankDiscovered = false; // Flag
                if (!discoveredRanks.has(displayName)) {
                    discoveredRanks.add(displayName);
                    addToTerminal(`üéâ NEW RANK DISCOVERED: ${displayName}!`, true);
                    updateIndexDisplay();
                    newRankDiscovered = true; // Set flag
                }
                
                currency += currencyGain;
                
                if (baseValue > highestBaseRoll) {
                    highestBaseRoll = baseValue;
                }

                if ((displayName !== "CORRUPTED" && displayValue > highestFinalRoll.value) || 
                    (displayName === "CORRUPTED" && (highestFinalRoll.rank !== "CORRUPTED" || displayValue < highestFinalRoll.value))) {
                    // ^ Special logic: CORRUPTED is "rarer" the more negative it is.
                    // This also handles the case where the current rarest is positive.
                    highestFinalRoll = {
                        value: displayValue,
                        baseValue: baseValue,
                        rank: displayName,
                        variants: variants,
                        isSecret: isSecret
                    };
                }
                
                // AUTO-ACCEPT LOGIC
                const shouldAcceptOnValue = autoAcceptThreshold > 0 && displayValue >= autoAcceptThreshold;
                const shouldAcceptOnSecret = autoAcceptSecretThresholdValue > 0 && isSecret && secretRarityMultiplier >= autoAcceptSecretThresholdValue;
                const shouldAcceptOnNew = autoAcceptOnNewRank && newRankDiscovered;
                const shouldAcceptOnTrueRNG = autoAcceptTrueRNGValue > 0 && baseValue >= autoAcceptTrueRNGValue;
                const shouldAcceptCorrupted = displayName === "CORRUPTED" && (autoAcceptSecretThresholdValue > 0 || autoAcceptThreshold > 0);
                
                // AUTO-STOP LOGIC
                const shouldStopOnValue = autoStopThreshold > 0 && displayValue >= autoStopThreshold;
                const shouldStopOnSecret = autoStopSecretThresholdValue > 0 && isSecret && secretRarityMultiplier >= autoStopSecretThresholdValue;
                const shouldStopOnNew = autoStopOnNewRank && newRankDiscovered;
                const shouldStopOnTrueRNG = autoStopTrueRNGValue > 0 && baseValue >= autoStopTrueRNGValue;
                const shouldStopCorrupted = displayName === "CORRUPTED" && (autoStopSecretThresholdValue > 0 || autoStopThreshold > 0);
                
                const variantText = variants.map(v => `<span style="color: ${v.color}; font-weight: bold;">[${v.name}]</span>`).join('') + ' ';
                
                const variantDataAttr = variants.length > 0 ? `data-variants='${JSON.stringify(variants)}'` : '';
                const baseValueAttr = `data-basevalue='${baseValue}'`;
                
                let content = `<span class="clickable-roll ${rankClass}" style="color: ${rollColor};" onclick="tryAddToInventory(${displayValue}, '${escapeHTML(displayName)}', ${currentIndex}, this)" id="roll-${currentIndex}" ${variantDataAttr} ${baseValueAttr}>${formatNumber(finalDisplayValue)} [${displayName}]${secretMultiplierText}${suffix}</span>`;
                
                if (displayName === "‚õßSatanic‚õß") {
                    content = `<span class="satanic-wrapper">${content}</span>`;
                }

                addToTerminal(
                    `#${formatInteger(currentIndex)}: ${variantText}${content} (+${currencyGain.toFixed(2)} currency)`
                );

                // Initialize bewilderment animation if applicable
                if (displayName === "?!? bewilderment ?!?") {
                    setTimeout(() => initBewildermentAnimation(`roll-${currentIndex}`), 100);
                }
                
                // Initialize EUPHORIA animation if rolled
                if (displayName === "!! EUPHORIA !!") {
                    initEuphoriaAnimation(`roll-${currentIndex}`, "!! EUPHORIA !!");
                }

                // AUTO-ACCEPT Logic
                if (autoRollInterval && (shouldAcceptOnValue || shouldAcceptOnSecret || shouldAcceptOnNew || shouldAcceptOnTrueRNG || shouldAcceptCorrupted)) {
                    
                    const rollElement = document.getElementById(`roll-${currentIndex}`);
                    
                    if (!acceptedRolls.has(currentIndex)) {
                        if (addToInventory(displayValue, displayName, currentIndex, variants, baseValue)) {
                            acceptedRolls.add(currentIndex);
                            
                            if (activeEuphoriaIntervals[currentIndex]) {
                                clearInterval(activeEuphoriaIntervals[currentIndex]);
                                delete activeEuphoriaIntervals[currentIndex];
                            }
                            
                            if (activeBewildermentIntervals[`roll-${currentIndex}`]) {
                                clearInterval(activeBewildermentIntervals[`roll-${currentIndex}`]);
                                delete activeBewildermentIntervals[`roll-${currentIndex}`];
                            }
                            
                            // Log it
                            let acceptSuffix = "";
                            if (displayName === "‚õßSatanic‚õß") acceptSuffix = ` (Actual: ${formatNumber(displayValue)})`;
                            if (displayName === "Finale.. wait, how'd this get here?") acceptSuffix = ` (Actual: ${formatNumber(displayValue)})`;
                            
                            addToTerminal(`Auto-Accepted: #${formatInteger(currentIndex)} ${variantText}${formatNumber(finalDisplayValue)} [${displayName}]${acceptSuffix}`, true, 'rank-1000-10000');
                            
                            // Update the element in the terminal
                            if (rollElement) {
                                rollElement.style.opacity = '0.5';
                                rollElement.style.cursor = 'not-allowed';
                                rollElement.onclick = null;
                            }
                            
                            saveGame();
                        } else {
                            // Inventory was full, so we must stop
                            toggleAutoRoll(); // This will stop it and log "Auto-rolling stopped."
                            addToTerminal(`Auto-roll stopped: Inventory is full!`, true, 'rank-1000000-100000000');
                            break; // Stop the loop
                        }
                    }
                    // Do NOT break; continue rolling (unless inventory was full).
                }
                
                // AUTO-STOP Logic (stops auto-roll without accepting)
                if (autoRollInterval && (shouldStopOnValue || shouldStopOnSecret || shouldStopOnNew || shouldStopOnTrueRNG || shouldStopCorrupted)) {
                    toggleAutoRoll();
                    addToTerminal(`Auto-roll STOPPED by stop condition: #${formatInteger(currentIndex)} ${variantText}${formatNumber(finalDisplayValue)} [${displayName}]`, true, 'rank-1000000-100000000');
                    break;
                }
            }
            
            updateStats();
            saveGame();
        }

        // --- MODIFIED: To stop animations on accept ---
        function tryAddToInventory(value, rank, index, element) {
            if (acceptedRolls.has(index)) {
                // MODIFIED: Use formatInteger
                addToTerminal(`Roll #${formatInteger(index)} has already been accepted!`, true);
                return;
            }
            
            let variants = [];
            let baseValue = value;
            
            if (element && element.dataset) {
                if (element.dataset.variants) {
                    try {
                        variants = JSON.parse(element.dataset.variants);
                    } catch (e) {
                        console.error('Error parsing variants:', e);
                    }
                }
                if (element.dataset.basevalue) {
                    baseValue = parseFloat(element.dataset.basevalue);
                }
            }
            
            if (addToInventory(value, rank, index, variants, baseValue)) {
                acceptedRolls.add(index);

                // --- NEW: Stop animations ---
                if (activeEuphoriaIntervals[index]) {
                    clearInterval(activeEuphoriaIntervals[index]);
                    delete activeEuphoriaIntervals[index];
                }
                
                if (activeBewildermentIntervals[`roll-${index}`]) {
                    clearInterval(activeBewildermentIntervals[`roll-${index}`]);
                    delete activeBewildermentIntervals[`roll-${index}`];
                }
                // --- END NEW ---
                
                const variantText = variants.map(v => `[${v.name}]`).join('') + ' ';
                
                let suffix = "";
                let displayValue = value; // NEW
                if (rank === "100") suffix = " * üíØ";
                if (rank === ":[{(absolute zero)}]:") suffix = " * 0";
                
                // NEW: Special display for add log
                if (rank === "‚õßSatanic‚õß") {
                    suffix = ` (Actual: ${formatNumber(value)})`;
                    displayValue = -666.66;
                }
                if (rank === "Finale.. wait, how'd this get here?") {
                    suffix = ` (Actual: ${formatNumber(value)})`;
                    displayValue = 1e10;
                }
                // END NEW
                
                // MODIFIED: use formatInteger
                addToTerminal(`Added to inventory: #${formatInteger(index)} ${variantText}${formatNumber(displayValue)} [${rank}]${suffix}`, true); 
                
                const rollElement = document.getElementById(`roll-${index}`);
                if (rollElement) {
                    rollElement.style.opacity = '0.5';
                    rollElement.style.cursor = 'not-allowed';
                    rollElement.onclick = null;
                }
                
                saveGame();
            }
        }

        // MODIFIED: For Auto-Accept and Auto-Stop
        function toggleAutoRoll() {
            if (isCutscenePlaying) {
                addToTerminal('Cannot toggle auto-roll during a cutscene!', true);
                return;
            }
            
            const btn = document.getElementById('autoRollBtn');
            if (autoRollInterval) {
                clearInterval(autoRollInterval);
                autoRollInterval = null;
                btn.textContent = 'Auto Roll';
                btn.classList.remove('active');
                addToTerminal('Auto-rolling stopped.', true);
            } else {
                // Load Auto-Accept settings
                autoAcceptThreshold = parseFloat(document.getElementById('autoAcceptThreshold').value) || 0;
                autoAcceptTrueRNGValue = parseFloat(document.getElementById('autoAcceptTrueRNG').value) || 0;
                autoAcceptSecretThresholdValue = parseFloat(document.getElementById('autoAcceptSecretThreshold').value) || 0;
                autoAcceptOnNewRank = document.getElementById('autoAcceptNewRank').checked;
                
                // Load Auto-Stop settings
                autoStopThreshold = parseFloat(document.getElementById('autoStopThreshold').value) || 0;
                autoStopTrueRNGValue = parseFloat(document.getElementById('autoStopTrueRNG').value) || 0;
                autoStopSecretThresholdValue = parseFloat(document.getElementById('autoStopSecretThreshold').value) || 0;
                autoStopOnNewRank = document.getElementById('autoStopNewRank').checked;
                
                autoRollInterval = setInterval(roll, AUTO_ROLL_DELAY_MS);
                btn.textContent = 'Stop Auto Roll';
                btn.classList.add('active');
                
                // MODIFIED: Log message for auto-accept and auto-stop
                let message = 'Auto-rolling started...';
                const acceptConditions = [];
                const stopConditions = [];
                
                if (autoAcceptThreshold > 0) acceptConditions.push(`value ‚â• ${autoAcceptThreshold}`);
                if (autoAcceptTrueRNGValue > 0) acceptConditions.push(`base ‚â• ${autoAcceptTrueRNGValue}`);
                if (autoAcceptSecretThresholdValue > 0) acceptConditions.push(`secret ‚â• ${autoAcceptSecretThresholdValue}`);
                if (autoAcceptOnNewRank) acceptConditions.push('new rank');
                
                if (autoStopThreshold > 0) stopConditions.push(`value ‚â• ${autoStopThreshold}`);
                if (autoStopTrueRNGValue > 0) stopConditions.push(`base ‚â• ${autoStopTrueRNGValue}`);
                if (autoStopSecretThresholdValue > 0) stopConditions.push(`secret ‚â• ${autoStopSecretThresholdValue}`);
                if (autoStopOnNewRank) stopConditions.push('new rank');
                
                if (acceptConditions.length > 0) {
                    message += ` (Auto-Accept: ${acceptConditions.join(', ')})`;
                }
                
                if (stopConditions.length > 0) {
                    message += ` (Auto-Stop: ${stopConditions.join(', ')})`;
                }
                
                addToTerminal(message, true);
            }
        }

        function buyUpgrade() {
            if (currency >= upgradeCost) {
                currency -= upgradeCost;
                totalUpgrades++;
                // MODIFIED: Uses new constant
                maxInventory += INVENTORY_PER_UPGRADE;
                
                updateCalculatedStats();
                
                addToTerminal(
                    `Upgrade purchased! Total upgrades: ${totalUpgrades} | Luck: +${currentLuck.toFixed(3)} | Secret Luck: ${secretLuckMultiplier.toFixed(2)}x | Inventory space: ${maxInventory} | Currency: ${currency.toFixed(2)}`,
                    true
                );
                
                upgradeCost *= UPGRADE_COST_MULTIPLIER;
                addToTerminal(`Next upgrade cost: ${upgradeCost.toFixed(2)}`);
                
                updateStats();
                saveGame();
            } else {
                addToTerminal(
                    `Not enough currency! You have ${currency.toFixed(2)} but need ${upgradeCost.toFixed(2)}`,
                    true
                );
            }
        }

        function buyBulkRoll() {
            if (bulkRollLevel >= MAX_BULK_ROLL_LEVEL) {
                addToTerminal('Bulk Roll is already maxed out!', true);
                return;
            }
            
            if (currency >= bulkRollCost) {
                currency -= bulkRollCost;
                bulkRollLevel++;
                
                addToTerminal(
                    `Bulk Roll purchased! Level: ${bulkRollLevel} | Rolls per click: ${bulkRollLevel + 1} | Currency: ${currency.toFixed(2)}`,
                    true
                );
                
                if (bulkRollLevel < MAX_BULK_ROLL_LEVEL) {
                    bulkRollCost *= BULK_ROLL_COST_MULTIPLIER;
                    addToTerminal(`Next Bulk Roll cost: ${bulkRollCost.toFixed(2)}`);
                } else {
                    addToTerminal('Bulk Roll is now MAXED!');
                }
                
                updateStats();
                saveGame();
            } else {
                addToTerminal(
                    `Not enough currency! You have ${currency.toFixed(2)} but need ${bulkRollCost.toFixed(2)}`,
                    true
                );
            }
        }

        // MODIFIED: To handle new ranks
        function showRarest() {
            if (highestFinalRoll.value === 0 && highestFinalRoll.rank !== "CORRUPTED") {
                addToTerminal('No rolls yet!', true);
            } else {
                const { className, color } = getRankClassAndColor(highestFinalRoll.value, highestFinalRoll.variants, highestFinalRoll.rank);
                let rankClass = className;
                let rollColor = color;
                const displayName = highestFinalRoll.rank;
                let displayValue = highestFinalRoll.value; // NEW
                let suffix = ""; // NEW

                if (displayName === "~Nonavacious~") {
                    rankClass += " secret-nonavacious";
                }
                
                // --- NEW: Apply CORRUPTED class ---
                if (displayName === "CORRUPTED") {
                    rankClass += " secret-corrupted";
                    rollColor = "#FFFFFF";
                }
                // --- END NEW ---
                
                // NEW: Special display for rarest
                if (displayName === "‚õßSatanic‚õß") {
                    suffix = ` (Actual: ${formatNumber(highestFinalRoll.value)})`;
                    displayValue = -666.66;
                }
                if (displayName === "Finale.. wait, how'd this get here?") {
                    suffix = ` (Actual: ${formatNumber(highestFinalRoll.value)})`;
                    displayValue = 1e10;
                }
                // END NEW

                let variantText = '';
                if (highestFinalRoll.variants && highestFinalRoll.variants.length > 0) {
                    variantText = highestFinalRoll.variants.map(v => `[${v.name}]`).join('') + ' ';
                }
                
                // MODIFIED: Added satanic wrapper
                addToTerminal(
                    `Rarest roll: ${variantText}<span class="satanic-wrapper"><span class="${rankClass}" style="color: ${rollColor};">${formatNumber(displayValue)} [${displayName}]${suffix}</span></span>`,
                    true
                );
            }
        }

        function clearTerminal() {
            const terminal = document.getElementById('terminal');
            const welcomeMsg = terminal.querySelector('.welcome-message');
            terminal.innerHTML = '';
            if (welcomeMsg) {
                terminal.appendChild(welcomeMsg);
            }
        }

        // --- NEW: Import/Export Functions ---
        
        function exportSave() {
            try {
                saveGame(); // Ensure current state is saved to localStorage first
                const saveData = localStorage.getItem('calisRNGGame');
                const encodedData = btoa(saveData); // Base64 encode it
                document.getElementById('saveDataTextarea').value = encodedData;
                addToTerminal('Save data exported to text box. Copy it to save it.', true);
            } catch (e) {
                console.error('Error exporting save:', e);
                addToTerminal('Error exporting save data. Check console.', true, 'rank-1000000-100000000');
            }
        }
        
        function importSave() {
            if (!confirm("Are you sure you want to import this save? This will OVERWRITE your current progress and reload the page.")) {
                return;
            }
            
            try {
                const encodedData = document.getElementById('saveDataTextarea').value;
                if (!encodedData) {
                    addToTerminal('Paste save data into the text box first!', true);
                    return;
                }
                const decodedData = atob(encodedData); // Base64 decode
                
                // Test if it's valid JSON
                JSON.parse(decodedData); 
                
                // If it is, save it and reload
                localStorage.setItem('calisRNGGame', decodedData);
                
                // Stop all intervals before reloading
                if (autoRollInterval) clearInterval(autoRollInterval);
                if (eventInterval) clearInterval(eventInterval);
                if (shapeInterval) clearInterval(shapeInterval);
                if (currentEvent && currentEvent.timeoutId) clearTimeout(currentEvent.timeoutId);
                for (const id in activeEuphoriaIntervals) {
                    clearInterval(activeEuphoriaIntervals[id]);
                }
                for (const id in activeBewildermentIntervals) {
                    clearInterval(activeBewildermentIntervals[id]);
                }
                
                addToTerminal('Import successful! Reloading game...', true, 'rank-1000000000-10000000000');
                
                // Wait 1 second then reload the page
                setTimeout(() => {
                    location.reload();
                }, 1000);
                
            } catch (e) {
                console.error('Error importing save:', e);
                addToTerminal('Error importing save data. Data might be corrupt or invalid. Check console.', true, 'rank-1000000-100000000');
            }
        }
        
        // --- END Import/Export Functions ---


        // --- NEW: SHAPE SYSTEM FUNCTIONS ---

        function addToShapeTerminal(text) {
            const terminal = document.getElementById('shape-spawn-output');
            const line = document.createElement('div');
            line.className = 'shape-spawn-line';
            line.innerHTML = text; 
            
            if (terminal.children.length > 20) {
                terminal.removeChild(terminal.firstChild);
            }
            
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
        }

        function calculateGeometrixGain(shape) {
            let baseGain = 0;
            if (shape.name === "Circle") {
                // formula for circle: Math.random() ** -1.5 (starts at 250)
                const base = Math.pow(Math.random(), -1.5);
                baseGain = base * 250;
            } else {
                // formula for others: actual rarity of polygon / 2
                baseGain = shape.rarity / 2;
            }
            
            // NEW: Apply GMX Multiplier from Clicker
            const gmxMultiplier = 1 + (gmxMultiLevel * 0.5);
            return baseGain * gmxMultiplier;
        }
        
        // NEW: Function to remove a shape from the array and DOM
        function despawnShape(shapeId, isCollected = false) {
            const shapeIndex = activeShapes.findIndex(s => s.id === shapeId);
            
            if (shapeIndex === -1) {
                return; // Already gone
            }

            const shapeData = activeShapes[shapeIndex];
            
            // Clear the timer if it exists (safety)
            if (shapeData.timerId) {
                clearTimeout(shapeData.timerId);
            }
            
            // Remove from array
            activeShapes.splice(shapeIndex, 1);
            
            // Remove from DOM
            const element = document.getElementById(`shape-${shapeId}`);
            if (element) {
                 if (isCollected) {
                    // Visual feedback for collected shape
                    element.style.transform = 'scale(1.5)';
                    element.style.opacity = '0';
                    setTimeout(() => element.remove(), 200);
                 } else {
                    element.remove();
                 }
            }
            
            if (!isCollected) {
                addToShapeTerminal(`A **${shapeData.name}** despawned (not collected)!`);
            }
            
            saveGame();
        }

        // NEW: Function to re-render shapes after a load (recreates DOM elements from saved data)
        function renderActiveShapes() {
            const shapesField = document.getElementById('shapes-field');
            shapesField.innerHTML = ''; 
            
            // Filter out expired shapes and create timers for remaining ones
            activeShapes = activeShapes.filter(shapeData => {
                const timeElapsed = Date.now() - shapeData.spawnTime;
                
                // If expired, skip and log as despawned
                if (timeElapsed >= SHAPE_DESPAWN_TIME_MS) {
                    addToShapeTerminal(`A **${shapeData.name}** despawned while you were away!`);
                    return false;
                }

                // If not expired, create DOM element
                const shapeElement = document.createElement('div');
                shapeElement.id = `shape-${shapeData.id}`;
                shapeElement.className = `clickable-shape shape-${shapeData.name.replace(/\s/g, '-')}`;
                shapeElement.style.backgroundColor = shapeData.color;
                shapeElement.style.left = `${shapeData.posX}px`;
                shapeElement.style.top = `${shapeData.posY}px`;
                shapeElement.textContent = shapeData.name[0];
                shapeElement.onclick = () => collectShape(shapeData.id);
                
                shapesField.appendChild(shapeElement);

                // Resume the timer for the remaining duration
                const remainingTime = SHAPE_DESPAWN_TIME_MS - timeElapsed;
                shapeData.timerId = setTimeout(() => {
                    despawnShape(shapeData.id, false); 
                }, remainingTime);

                return true; // Keep in the activeShapes array
            });
            
            // Save to ensure expired shapes are removed from save data immediately
            saveGame(); 
        }


        // MODIFIED: Now creates clickable visual elements and sets a despawn timer
        function spawnShape() {
            if (!shapesUnlocked) return;
            
            let totalPossibleGain = 0;
            let spawnedCount = 0;
            const spawnCount = bulkShapeLevel + 1; 

            const shapesField = document.getElementById('shapes-field');
            const fieldWidth = shapesField.clientWidth;
            const fieldHeight = shapesField.clientHeight;


            for (let j = 0; j < spawnCount; j++) {
                const cumulativeChances = [];
                let cumulativeSum = 0;

                for (const shape of SHAPES) {
                    // Apply shape luck (Upgrade 1) as a multiplier to the base chance
                    // The 'chance' property is now guaranteed to exist for all shapes.
                    const adjustedChance = shape.chance * (1 + shapeLuckBonus);
                    cumulativeSum += adjustedChance;
                    cumulativeChances.push({ maxChance: cumulativeSum, shape: shape });
                }
                
                let rand = Math.random() * cumulativeSum; 
                let selectedShape = null;

                for (const item of cumulativeChances) {
                    if (rand < item.maxChance) { 
                        selectedShape = item.shape;
                        break;
                    }
                }
                
                // Fallback to the most common shape (Triangle) to guarantee a spawn if something fails
                if (!selectedShape) {
                    selectedShape = SHAPES[0]; 
                }

                const gain = calculateGeometrixGain(selectedShape);
                totalPossibleGain += gain;
                spawnedCount++;
                
                // --- NEW VISUAL SPAWNING LOGIC ---
                const shapeId = Date.now().toString() + Math.random().toString(36).substring(2, 9);
                const shapeSize = 30;
                const posX = Math.random() * (fieldWidth - shapeSize); 
                const posY = Math.random() * (fieldHeight - shapeSize); 

                const shapeElement = document.createElement('div');
                shapeElement.id = `shape-${shapeId}`;
                shapeElement.className = `clickable-shape shape-${selectedShape.name.replace(/\s/g, '-')}`; 
                shapeElement.style.backgroundColor = selectedShape.color;
                shapeElement.style.left = `${posX}px`;
                shapeElement.style.top = `${posY}px`;
                shapeElement.textContent = selectedShape.name[0]; // First letter display

                // Store data 
                const shapeData = {
                    id: shapeId,
                    name: selectedShape.name,
                    gain: gain,
                    color: selectedShape.color,
                    posX: posX,
                    posY: posY,
                    spawnTime: Date.now(), // NEW: Record spawn time
                    timerId: null // Placeholder for the timeout ID
                };
                
                // Set the despawn timer and store the ID
                shapeData.timerId = setTimeout(() => {
                    despawnShape(shapeId, false); // isCollected = false
                }, SHAPE_DESPAWN_TIME_MS);

                activeShapes.push(shapeData);
                
                // Attach click handler
                shapeElement.onclick = () => collectShape(shapeData.id);
                
                shapesField.appendChild(shapeElement);
                // --- END NEW VISUAL SPAWNING LOGIC ---
            }
            
            // Display total GMX that can be collected (not collected yet)
            if (spawnedCount > 0) {
                addToShapeTerminal(`Spawned ${spawnedCount} shapes. Max collection: ${formatGeometrix(totalPossibleGain)} GMX.`);
            }
        }
        
        // MODIFIED: Function to collect a shape when clicked
        function collectShape(shapeId) {
            const shapeIndex = activeShapes.findIndex(s => s.id === shapeId);
            
            if (shapeIndex === -1) {
                return; 
            }

            const shapeData = activeShapes[shapeIndex];
            geometrix += shapeData.gain;
            
            addToTerminal(`Collected **${shapeData.name}** (+${formatGeometrix(shapeData.gain)} GMX)!`, true, 'command');

            // Remove the shape and clear its timer
            // Pass true to indicate it was collected, which adds a short visual transition
            despawnShape(shapeId, true); 
            
            updateStats();
        }

        // MODIFIED: No immediate spawn on interval start
        function startShapeInterval() {
            if (shapeInterval) clearInterval(shapeInterval);
            if (!shapesUnlocked) return;
            
            shapeInterval = setInterval(spawnShape, currentShapeCooldown);
            
            addToTerminal(`Shape spawning interval set to ${formatCooldown(currentShapeCooldown)}s.`, true, '#00FF00');
        }

        function unlockShapes() {
            if (currency >= UNLOCK_SHAPES_COST) {
                currency -= UNLOCK_SHAPES_COST;
                shapesUnlocked = true;
                addToTerminal(`**Shapes GUI unlocked!** Start collecting the clickable polygons.`, true, '#00FF00');
                updateCalculatedStats();
                startShapeInterval(); // Start the spawner
                updateStats();
                saveGame();
            } else {
                addToTerminal(`Not enough currency! Need ${formatNumber(UNLOCK_SHAPES_COST)} to unlock.`, true);
            }
        }

        // Upgrade 1
        function buyShapeLuckUpgrade() {
            if (shapeLuckLevel >= MAX_SHAPE_LUCK_LEVEL) {
                addToTerminal('Shape Luck is maxed out!', true, '#FF00FF');
                return;
            }
            if (geometrix >= shapeLuckCost) {
                geometrix -= shapeLuckCost;
                shapeLuckLevel++;
                
                addToTerminal(
                    `Shape Luck purchased! Level: ${shapeLuckLevel}/${MAX_SHAPE_LUCK_LEVEL}`,
                    true, '#00FF00'
                );
                
                shapeLuckCost *= SHAPE_LUCK_COST_MULTIPLIER;
                updateCalculatedStats();
                updateStats();
                saveGame();
            } else {
                addToTerminal(`Not enough Geometrix! Need ${formatGeometrix(shapeLuckCost)} GMX.`, true);
            }
        }
        
        // Upgrade 2
        function buyLuckMultiUpgrade() {
            if (geometrix >= luckMultiCost) {
                geometrix -= luckMultiCost;
                luckMultiLevel++;
                
                updateCalculatedStats(); // Recalculate multipliers

                addToTerminal(
                    `Luck Multiplier purchased! Level: ${luckMultiLevel} | New Multi: x${luckMultiValue.toFixed(2)}`,
                    true, '#00FF00'
                );
                
                luckMultiCost *= LUCK_MULTI_COST_MULTIPLIER;
                updateStats();
                saveGame();
            } else {
                addToTerminal(`Not enough Geometrix! Need ${formatGeometrix(luckMultiCost)} GMX.`, true);
            }
        }

        // Upgrade 3
        function buyBulkShapeUpgrade() {
            if (bulkShapeLevel >= MAX_BULK_SHAPE_LEVEL) {
                addToTerminal('Bulk/Cooldown is maxed out!', true, '#FF00FF');
                return;
            }
            if (geometrix >= bulkShapeCost) {
                geometrix -= bulkShapeCost;
                bulkShapeLevel++;
                
                updateCalculatedStats(); // Recalculate cooldown
                
                addToTerminal(
                    `Bulk/Cooldown purchased! Level: ${bulkShapeLevel}/${MAX_BULK_SHAPE_LEVEL} | Spawns: ${bulkShapeLevel + 1} | Cooldown: ${formatCooldown(currentShapeCooldown)}s`,
                    true, '#00FF00'
                );
                
                if (bulkShapeLevel < MAX_BULK_SHAPE_LEVEL) {
                    bulkShapeCost *= BULK_SHAPE_COST_MULTIPLIER;
                }
                
                startShapeInterval(); // Restart interval with new cooldown
                updateStats();
                saveGame();
            } else {
                addToTerminal(`Not enough Geometrix! Need ${formatGeometrix(bulkShapeCost)} GMX.`, true);
            }
        }
        // --- END SHAPES FUNCTIONS ---

        // --- NEW: CLICKER SYSTEM FUNCTIONS ---

        function unlockClicker() {
            if (clickerUnlocked) {
                addToTerminal('Clicker is already unlocked!', true);
                return;
            }
            if (geometrix >= UNLOCK_CLICKER_COST) {
                geometrix -= UNLOCK_CLICKER_COST;
                clickerUnlocked = true;
                addToTerminal(`**Clicker GUI unlocked!** Click the clover!`, true, '#FFD700');
                updateStats(); // This will show the UI
                saveGame();
            } else {
                addToTerminal(`Not enough Geometrix! Need ${formatGeometrix(UNLOCK_CLICKER_COST)} GMX.`, true);
            }
        }
        
        function clickClover() {
            const baseGain = Math.pow(Math.random(), -1.5);
            const finalGain = baseGain * (1 + fortuniumLuck);
            fortunium += finalGain;
            
            updateStats();
            // No save on click, that's too much.
        }
        
        // --- FIX: Refactored to move updateStats() and saveGame() into success blocks ---
        function buyFortuniumUpgrade(type) {
            if (!clickerUnlocked) return;
            
            if (type === 'gmx') {
                if (fortunium >= gmxMultiCost) {
                    fortunium -= gmxMultiCost;
                    gmxMultiLevel++;
                    gmxMultiCost *= 1.5;
                    addToTerminal(`GMX Multi upgrade purchased! GMX gain is now +${(gmxMultiLevel * 0.5).toFixed(1)}x`, true, '#FFD700');
                    updateStats();
                    saveGame();
                } else {
                    addToTerminal(`Not enough Fortunium! Need ${formatNumber(gmxMultiCost)} FOR.`, true);
                    return;
                }
            } 
            else if (type === 'fortuniumLuck') {
                if (fortunium >= fortuniumLuckCost) {
                    fortunium -= fortuniumLuckCost;
                    fortuniumLuckLevel++;
                    fortuniumLuck += 0.5; // Additive +0.5x
                    fortuniumLuckCost *= 1.25;
                    addToTerminal(`Fortunium Luck upgrade purchased! Fortunium Luck is now +${fortuniumLuck.toFixed(1)}x`, true, '#FFD700');
                    updateStats();
                    saveGame();
                } else {
                    addToTerminal(`Not enough Fortunium! Need ${formatNumber(fortuniumLuckCost)} FOR.`, true);
                    return;
                }
            }
            else if (type === 'luck') {
                if (clickerLuckLevel >= MAX_CLICKER_LUCK_LEVEL) {
                    addToTerminal('Clicker Luck upgrade is MAXED!', true, '#FF00FF');
                    return;
                }
                if (fortunium >= clickerLuckCost) {
                    fortunium -= clickerLuckCost;
                    clickerLuckLevel++;
                    clickerLuckCost *= 50;
                    addToTerminal(`Clicker Luck upgrade purchased! Level ${clickerLuckLevel}/${MAX_CLICKER_LUCK_LEVEL}.`, true, '#FFD700');
                    updateCalculatedStats(); // This upgrade affects main luck
                    updateStats();
                    saveGame();
                } else {
                    addToTerminal(`Not enough Fortunium! Need ${formatNumber(clickerLuckCost)} FOR.`, true);
                    return;
                }
            }
        }
        // --- END NEW FUNCTIONS ---

        // --- NEW: EUPHORIA Animation Function ---
        function initEuphoriaAnimation(elementId, baseText) {
            const element = document.getElementById(elementId);
            if (!element) return;
            
            // Clear existing interval for this element to prevent duplicates
            if (activeEuphoriaIntervals[elementId]) {
                clearInterval(activeEuphoriaIntervals[elementId]);
            }
            
            const originalHtml = element.innerHTML;
            const textChars = baseText.split('');
            
            const intervalId = setInterval(() => {
                const currentElement = document.getElementById(elementId);
                // Stop if element is gone
                if (!currentElement) {
                    clearInterval(activeEuphoriaIntervals[elementId]);
                    delete activeEuphoriaIntervals[elementId];
                    return;
                }
                
                // Find baseText in the full HTML
                const textIndex = currentElement.innerHTML.indexOf(baseText);
                if (textIndex === -1) {
                    // Text not found (maybe it was mid-animation), reset it
                    currentElement.innerHTML = originalHtml;
                    return;
                }
                
                // Get the parts of the string before and after the text to animate
                const prefix = currentElement.innerHTML.substring(0, textIndex);
                const suffix = currentElement.innerHTML.substring(textIndex + baseText.length);

                const newChars = [...textChars];
                
                // Pick 2 random, unique indices within the baseText
                let idx1 = Math.floor(Math.random() * newChars.length);
                let idx2 = Math.floor(Math.random() * newChars.length);
                while (idx1 === idx2) {
                    idx2 = Math.floor(Math.random() * newChars.length);
                }

                // Replace with symbols
                const sym1 = EUPHORIA_SYMBOLS[Math.floor(Math.random() * EUPHORIA_SYMBOLS.length)];
                const sym2 = EUPHORIA_SYMBOLS[Math.floor(Math.random() * EUPHORIA_SYMBOLS.length)];
                newChars[idx1] = `<span style="opacity: 0.7; display: inline-block; transform: scale(1.1);">${sym1}</span>`;
                newChars[idx2] = `<span style="opacity: 0.7; display: inline-block; transform: scale(1.1);">${sym2}</span>`;
                
                // Reconstruct the HTML
                currentElement.innerHTML = prefix + newChars.join('') + suffix;

                // Set a timeout to revert back to the original HTML
                setTimeout(() => {
                    const stillExists = document.getElementById(elementId);
                    if (stillExists && activeEuphoriaIntervals[elementId]) {
                        // Just reset to original HTML, it's safer and flicker-free
                        stillExists.innerHTML = originalHtml;
                    }
                }, 25); // Revert after 25ms

            }, 100); // Repeat the flicker every 100ms
            
            activeEuphoriaIntervals[elementId] = intervalId;
        }
        // --- END NEW FUNCTION ---


        // MODIFIED: To exclude the volatile timerId from saved data and include new settings
        function saveGame() {
            const gameState = {
                currency,
                totalUpgrades,
                upgradeCost,
                highestBaseRoll, 
                // FIX: Ensure highestFinalRoll has necessary properties for old saves 
                highestFinalRoll: highestFinalRoll || { 
                    value: 0, 
                    baseValue: 0, 
                    rank: 'None yet', 
                    variants: [], 
                    isSecret: false 
                },
                maxInventory,
                inventory,
                rollIndex,
                acceptedRolls: Array.from(acceptedRolls),
                discoveredRanks: Array.from(discoveredRanks),
                bulkRollLevel: bulkRollLevel,
                bulkRollCost: bulkRollCost,
                
                // NEW: Cutscene State 
                cutscenesEnabled: cutscenesEnabled,

                // FIX: Event State 
                currentEvent: currentEvent ? { name: currentEvent.name, duration: currentEvent.duration, description: currentEvent.description, targets: currentEvent.targets, multiplier: currentEvent.multiplier, eventChanceBoost: currentEvent.eventChanceBoost } : null,
                eventEndTime: eventEndTime,
                eventCheckChance: eventCheckChance,

                // NEW: Auto-Accept and Auto-Stop Settings
                autoAcceptThreshold,
                autoAcceptTrueRNGValue,
                autoAcceptSecretThresholdValue,
                autoAcceptOnNewRank,
                autoStopThreshold,
                autoStopTrueRNGValue,
                autoStopSecretThresholdValue,
                autoStopOnNewRank,

                // NEW: Shapes Save Data
                geometrix,
                shapesUnlocked,
                shapeLuckLevel,
                shapeLuckCost,
                luckMultiLevel,
                luckMultiCost,
                bulkShapeLevel,
                bulkShapeCost,
                // NEW: Active Shapes Array (only necessary properties)
                activeShapes: activeShapes.map(shape => ({
                    id: shape.id,
                    name: shape.name,
                    gain: shape.gain,
                    color: shape.color,
                    posX: shape.posX,
                    posY: shape.posY,
                    spawnTime: shape.spawnTime // Only save the spawn time
                })),
                
                // NEW: Clicker Save Data
                clickerUnlocked,
                fortunium,
                fortuniumLuck,
                gmxMultiLevel,
                gmxMultiCost,
                fortuniumLuckLevel,
                fortuniumLuckCost,
                clickerLuckLevel,
                clickerLuckCost
            };
            localStorage.setItem('calisRNGGame', JSON.stringify(gameState));
        }

        // MODIFIED: To load new save data (Cutscene state, Event state, activeShapes, Clicker, and new settings)
        function loadGame() {
            const saved = localStorage.getItem('calisRNGGame');
            if (saved) {
                try {
                    const gameState = JSON.parse(saved);
                    currency = gameState.currency || 0;
                    totalUpgrades = gameState.totalUpgrades || 0;
                    upgradeCost = gameState.upgradeCost || 50;
                    
                    // FIX: Safely load and initialize highestFinalRoll 
                    if (gameState.highestFinalRoll) {
                        highestFinalRoll = gameState.highestFinalRoll;
                        // Ensure isSecret property exists for old saves
                        if (typeof highestFinalRoll.isSecret === 'undefined') {
                             highestFinalRoll.isSecret = SECRET_RANKS_CHANCES.map(r => r.name).includes(highestFinalRoll.rank) || highestFinalRoll.rank === "morts luck" || highestFinalRoll.rank === "Unobtainable"; // MODIFIED: Added Unobtainable
                        }
                    } else {
                        const baseRoll = gameState.highestRoll || 0;
                        const rankInfo = getRankInfo(baseRoll);
                         highestFinalRoll = {
                            value: baseRoll,
                            baseValue: baseRoll,
                            rank: rankInfo.name,
                            variants: [],
                            isSecret: false
                        };
                    }
                    
                    highestBaseRoll = gameState.highestBaseRoll || (highestFinalRoll ? highestFinalRoll.baseValue : 0); // Safety check added

                    maxInventory = gameState.maxInventory || 10;
                    
                    inventory = (gameState.inventory || []).map(item => {
                        // Handle variant conversion for older saves
                        if (item.variant && !item.variants) {
                            item.variants = [item.variant];
                            delete item.variant;
                        } else if (!item.variants) {
                            item.variants = [];
                        }
                        // Ensure isSecret property exists for older saves
                         if (typeof item.isSecret === 'undefined') {
                            item.isSecret = SECRET_RANKS_CHANCES.map(r => r.name).includes(item.rank) || item.rank === "morts luck" || item.rank === "breaktime" || item.rank === "Unobtainable"; // MODIFIED: Added Unobtainable
                        }
                        return item;
                    });

                    rollIndex = gameState.rollIndex || 1;
                    acceptedRolls = new Set(gameState.acceptedRolls || []);
                    discoveredRanks = new Set(gameState.discoveredRanks || []);
                    bulkRollLevel = gameState.bulkRollLevel || 0;
                    bulkRollCost = gameState.bulkRollCost || 500000;
                    
                    // NEW: Load Cutscene State 
                    cutscenesEnabled = typeof gameState.cutscenesEnabled === 'boolean' ? gameState.cutscenesEnabled : true; 

                    // FIX: Load Event State 
                    currentEvent = gameState.currentEvent || null;
                    eventEndTime = gameState.eventEndTime || 0;
                    eventCheckChance = gameState.eventCheckChance || 1;

                    // NEW: Load Auto-Accept and Auto-Stop Settings
                    autoAcceptThreshold = gameState.autoAcceptThreshold || 0;
                    autoAcceptTrueRNGValue = gameState.autoAcceptTrueRNGValue || 0;
                    autoAcceptSecretThresholdValue = gameState.autoAcceptSecretThresholdValue || 0;
                    autoAcceptOnNewRank = gameState.autoAcceptOnNewRank || false;
                    
                    autoStopThreshold = gameState.autoStopThreshold || 0;
                    autoStopTrueRNGValue = gameState.autoStopTrueRNGValue || 0;
                    autoStopSecretThresholdValue = gameState.autoStopSecretThresholdValue || 0;
                    autoStopOnNewRank = gameState.autoStopOnNewRank || false;

                    // NEW: Load Shapes Data
                    geometrix = gameState.geometrix || 0;
                    shapesUnlocked = gameState.shapesUnlocked || false;
                    shapeLuckLevel = gameState.shapeLuckLevel || 0;
                    shapeLuckCost = gameState.shapeLuckCost || 5;
                    luckMultiLevel = gameState.luckMultiLevel || 0;
                    luckMultiCost = gameState.luckMultiCost || 100;
                    bulkShapeLevel = gameState.bulkShapeLevel || 0;
                    bulkShapeCost = gameState.bulkShapeCost || 50;
                    
                    // NEW: Load Active Shapes
                    activeShapes = gameState.activeShapes || [];

                    // NEW: Load Clicker Data
                    clickerUnlocked = gameState.clickerUnlocked || false;
                    fortunium = gameState.fortunium || 0;
                    fortuniumLuck = gameState.fortuniumLuck || 0;
                    gmxMultiLevel = gameState.gmxMultiLevel || 0;
                    gmxMultiCost = gameState.gmxMultiCost || 75;
                    fortuniumLuckLevel = gameState.fortuniumLuckLevel || 0;
                    fortuniumLuckCost = gameState.fortuniumLuckCost || 125;
                    clickerLuckLevel = gameState.clickerLuckLevel || 0;
                    clickerLuckCost = gameState.clickerLuckCost || 1000;


                    // Call the calculation function
                    updateCalculatedStats();
                    
                    // Start the shape spawner if it was unlocked
                    if (shapesUnlocked) {
                        // FIX: Re-render shapes and start/resume despawn timers on load
                        renderActiveShapes();
                        startShapeInterval();
                    }
                    
                    // FIX: Check and resume active event 
                    if (currentEvent && eventEndTime > Date.now()) {
                        const durationRemaining = eventEndTime - Date.now();
                        resumeEvent(currentEvent, durationRemaining);
                    } else if (currentEvent && eventEndTime <= Date.now()) {
                        // Event ended while offline - clean up
                        endEvent({ name: currentEvent.name, eventChanceBoost: currentEvent.eventChanceBoost });
                    }
                    
                    // Set input values for Auto-Accept and Auto-Stop
                    document.getElementById('autoAcceptThreshold').value = autoAcceptThreshold;
                    document.getElementById('autoAcceptTrueRNG').value = autoAcceptTrueRNGValue;
                    document.getElementById('autoAcceptSecretThreshold').value = autoAcceptSecretThresholdValue;
                    document.getElementById('autoAcceptNewRank').checked = autoAcceptOnNewRank;
                    
                    document.getElementById('autoStopThreshold').value = autoStopThreshold;
                    document.getElementById('autoStopTrueRNG').value = autoStopTrueRNGValue;
                    document.getElementById('autoStopSecretThreshold').value = autoStopSecretThresholdValue;
                    document.getElementById('autoStopNewRank').checked = autoStopOnNewRank;
                    
                    updateStats();
                    updateInventoryDisplay();
                    updateIndexDisplay();
                    addToTerminal('Game loaded!', true);
                } catch (e) {
                    console.error('Error loading game:', e);
                    // Fallback to default state if save is corrupt
                    updateCalculatedStats();
                    updateStats();
                    updateInventoryDisplay();
                    updateIndexDisplay();
                }
            } else {
                 // First time load
                updateCalculatedStats();
                updateStats();
                updateInventoryDisplay();
                updateIndexDisplay();
            }
        }

        document.addEventListener('keydown', function(e) {
            if (e.key === 'r' && e.target.tagName !== 'INPUT') {
                e.preventDefault();
                roll();
            }
        });
        
        // Add listeners for auto-accept settings
        document.getElementById('autoAcceptThreshold').addEventListener('change', (e) => {
            autoAcceptThreshold = parseFloat(e.target.value) || 0;
        });
        document.getElementById('autoAcceptSecretThreshold').addEventListener('change', (e) => {
            autoAcceptSecretThresholdValue = parseFloat(e.target.value) || 0;
        });
        document.getElementById('autoAcceptNewRank').addEventListener('change', (e) => {
            autoAcceptOnNewRank = e.target.checked;
        });
        document.getElementById('autoAcceptTrueRNG').addEventListener('change', (e) => {
            autoAcceptTrueRNGValue = parseFloat(e.target.value) || 0;
        });
        
        // Add listeners for auto-stop settings
        document.getElementById('autoStopThreshold').addEventListener('change', (e) => {
            autoStopThreshold = parseFloat(e.target.value) || 0;
        });
        document.getElementById('autoStopSecretThreshold').addEventListener('change', (e) => {
            autoStopSecretThresholdValue = parseFloat(e.target.value) || 0;
        });
        document.getElementById('autoStopNewRank').addEventListener('change', (e) => {
            autoStopOnNewRank = e.target.checked;
        });
        document.getElementById('autoStopTrueRNG').addEventListener('change', (e) => {
            autoStopTrueRNGValue = parseFloat(e.target.value) || 0;
        });

        // NEW: Add listener for clover click
        document.getElementById('clover-clicker').addEventListener('click', () => {
            if (!clickerUnlocked) return;
            clickClover();
            
            // Click animation
            const clover = document.getElementById('clover-clicker');
            clover.style.transform = 'scale(0.9)';
            setTimeout(() => {
                clover.style.transform = 'scale(1)';
            }, 100);
        });

        const welcomeLine = document.createElement('div');
        welcomeLine.className = 'output-line welcome-message';
        welcomeLine.textContent = 'Welcome to calis RNG game!';
        document.getElementById('terminal').appendChild(welcomeLine);
        addToTerminal('Click rolls to add them to your inventory!');
        
        loadGame();
        updateInventoryDisplay(); updateIndexDisplay();
        startEventLoop(); 
    </script>
    
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(error => {
                        console.log('ServiceWorker registration failed: ', error);
                    });
            });
        }
    </script>
    </body>
</html>
